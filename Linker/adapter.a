;/*****************************************************
;Project : Uni_interface_adapter
;Version :
;Date    : 04.02.2014
;Author  : Vlad
;
;Chip type               : ATmega128
;Program type            : Application
;AVR Core Clock frequency: 16,000000 MHz
;Data Stack size         : 1024
;*****************************************************/
;
;#define DEBUG
;
;#include <adapter.h>
;PCODE: $00000000 VOL: 0
	#ifndef __SLEEP_DEFINED__
;PCODE: $00000001 VOL: 0
	#define __SLEEP_DEFINED__
;PCODE: $00000002 VOL: 0
	.EQU __se_bit=0x20
;PCODE: $00000003 VOL: 0
	.EQU __sm_mask=0x1C
;PCODE: $00000004 VOL: 0
	.EQU __sm_powerdown=0x10
;PCODE: $00000005 VOL: 0
	.EQU __sm_powersave=0x18
;PCODE: $00000006 VOL: 0
	.EQU __sm_standby=0x14
;PCODE: $00000007 VOL: 0
	.EQU __sm_ext_standby=0x1C
;PCODE: $00000008 VOL: 0
	.EQU __sm_adc_noise_red=0x08
;PCODE: $00000009 VOL: 0
	.SET power_ctrl_reg=mcucr
;PCODE: $0000000A VOL: 0
	#endif
;PCODE: $0000000B VOL: 0
;PCODE: $0000000C VOL: 0
;/**********************************************
;****************PCD8544 Driver*****************
;***********************************************
;
;for original NOKIA 3310 & alternative "chinese" version of display
;
;48x84 dots, 6x14 symbols
;
;**********************************************/
;
;//#define china 1		// если определено - работаем по алгоритмам "китайского" дисплея, иначе - оригинального
;#define SOFT_SPI 1	// если определено - используем программный SPI, иначе - аппаратный
;
;#ifndef SOFT_SPI
;unsigned char SPCR_val = 0x50;	// режим
;unsigned char SPSR_val = 0x01;  // удвоение частоты
;#endif
;
;//LCD Port & pinout setup. Примечание: порты с "кривой" адресацией (типа порт G и т.п.) не поддерживаются
;#define LCD_DC_PORT  	PORTA	// выбор команда-данные; любой пин любого порта
;#define LCD_DC_DDR 	    DDRA
;#define LCD_DC_PIN 	    0
;
;#define LCD_CPORT 	    PORTA	// Chip-Select; любой пин любого порта
;#define LCD_CDDR   	    DDRA
;#define LCD_CPIN    	1
;
;#define LCD_RST_PORT 	PORTA	// сброс экрана; любой пин любого порта
;#define LCD_RST_DDR   	DDRA
;#define LCD_RST_PIN   	2
;
;#define LCD_MOSI_PORT 	PORTA	// выход данных SPI, должен быть соответствующий пин аппаратного SPI, если он используется
;#define LCD_MOSI_DDR	DDRA
;#define LCD_MOSI_PIN    3
;
;#define LCD_CLK_PORT	PORTA	// тактирование SPI, должен быть соответствующий пин аппаратного SPI, если он используется
;#define LCD_CLK_DDR     DDRA
;#define LCD_CLK_PIN     4
;
;
;
;#ifndef SOFT_SPI
;#define LCD_SS_PORT	    PORTB	// ChipSelect SPI, должен быть соответствующий пин аппаратного SPI и настроен на выход
;#define LCD_SS_DDR     	DDRB
;#define LCD_SS_PIN     	0
;#endif
;
;//***********************************************************
;//Настройки контроллера дисплея и переменные для работы с ним
;//***********************************************************
;
;#pragma used+
;
;unsigned char lcd_buf[15];		//текстовый буфер для вывода на LCD
;
;bit power_down = 0;			//power-down control: 0 - chip is active, 1 - chip is in PD-mode
;bit addressing = 0;			//направление адресации: 0 - горизонтальная, 1- вертикальная
;//bit instuct_set = 0;			//набор инструкций: 0 - стандартный, 1 - расширенный - в текущей версии не используется
;
;#ifdef china
;bit x_mirror = 0;			//зеркалирование по X: 0 - выкл., 1 - вкл.
;bit y_mirror = 0;			//зеркалирование по Y: 0 - выкл., 1 - вкл.
;bit SPI_invert = 0;			//порядок битов в SPI: 0 - MSB first, 1 - LSB first
;#endif
;
;//unsigned char set_y;			//адрес по У, 0..5 - в текущей версии не используется
;//unsigned char set_x;                 	//адрес по Х, 0..83 - в текущей версии не используется
;unsigned char temp_control = 3;  	//температурный коэффициент, 0..3
;unsigned char bias = 3;                 //смещение, 0..7
;unsigned char Vop = 70;			//рабочее напрядение LCD, 0..127 (определяет контрастность)
;unsigned char disp_config = 2;		//режим дисплея: 0 - blank, 1 - all on, 2 - normal, 3 - inverse
;
;#ifdef china
;unsigned char shift = 5;		//0..3F - сдвиг экрана вверх, в точках
;#endif
;
;#define PIXEL_OFF	0		//режимы отображения пикселя - используются в графических функциях
;#define PIXEL_ON	1
;#define PIXEL_XOR	2
;
;#define LCD_X_RES               84	//разрешение экрана
;#define LCD_Y_RES               48
;#define LCD_CACHSIZE          LCD_X_RES*LCD_Y_RES/8
;
;#define Cntr_X_RES              102    	//разрешение контроллера - предполагаемое - но работает))
;#define Cntr_Y_RES              64
;#define Cntr_buf_size           Cntr_X_RES*Cntr_Y_RES/8
;
;unsigned char  LcdCache [LCD_CACHSIZE];	//Cache buffer in SRAM 84*48 bits or 504 bytes
;unsigned int   LcdCacheIdx;              	//Cache index
;
;#define LCD_CMD         0
;#define LCD_DATA        1
;
;//***************************************************
;//****************Прототипы функций******************
;//***************************************************
;void LcdSend (unsigned char data, unsigned char cmd);    			//Sends data to display controller
;void LcdUpdate (void);   							//Copies the LCD cache into the device RAM
;void LcdClear (void);    							//Clears the display
;void LcdInit ( void );								//Настройка SPI и дисплея
;void LcdContrast (unsigned char contrast); 					//contrast -> Contrast value from 0x00 to 0x7F
;void LcdMode (unsigned char mode); 						//режимы дисплея: 0 - blank, 1 - all on, 2 - normal, 3 - inverse
;void LcdPwrMode (void);								//инвертирует состояние вкл/выкл дисплея
;void LcdImage (flash unsigned char *imageData);					//вывод изображения
;void LcdPixel (unsigned char x, unsigned char y, unsigned char mode);     	//Displays a pixel at given absolute (x, y) location, mode -> Off, On or Xor
;void LcdLine (int x1, int y1, int x2, int y2, unsigned char mode);  		//Draws a line between two points on the display
;void LcdCircle(char x, char y, char radius, unsigned char mode);		//рисуем круг с координатами центра и радиусом
;void LcdBatt(int x1, int y1, int x2, int y2, unsigned char persent);		//рисуем батарейку и заполняем ее на %
;void LcdGotoXYFont (unsigned char x, unsigned char y);   			//Sets cursor location to xy location. Range: 1,1 .. 14,6
;void clean_lcd_buf (void);							//очистка текстового буфера
;void LcdChr (int ch);								//Displays a character at current cursor location and increment cursor location
;void LcdString (unsigned char x, unsigned char y);				//Displays a string at current cursor location
;void LcdChrBold (int ch);							//Печатает символ на текущем месте, большой и жирный)
;void LcdStringBold (unsigned char x, unsigned char y);				//Печатает большую и жирную строку
;void LcdChrBig (int ch);							//Печатает символ на текущем месте, большой
;void LcdStringBig (unsigned char x, unsigned char y);				//Печатает большую строку
;//***************************************************
;// UPDATE ##1
;void LcdBar(int x1, int y1, int x2, int y2, unsigned char persent);		// рисует прогресс-бар и заполняет его на "процент"
;void LcdBarLine(unsigned char line, unsigned char persent);			// рисуем прошресс-бар в указанной строке
;void LcdStringInv (unsigned char x, unsigned char y);                           // печатает строку в инверсном шрифте (удобно для настроек)
;
;const char table[0x0500] =
;{
;0x00, 0x00, 0x00, 0x00, 0x00,// 00
;0x00, 0x00, 0x5F, 0x00, 0x00,// 01
;0x00, 0x07, 0x00, 0x07, 0x00,// 02
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 03
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 04
;0x23, 0x13, 0x08, 0x64, 0x62,// 05
;0x36, 0x49, 0x55, 0x22, 0x50,// 06
;0x00, 0x05, 0x03, 0x00, 0x00,// 07
;0x00, 0x1C, 0x22, 0x41, 0x00,// 08
;0x00, 0x41, 0x22, 0x1C, 0x00,// 09
;0x14, 0x08, 0x3E, 0x08, 0x14,// 0A
;0x08, 0x08, 0x3E, 0x08, 0x08,// 0B
;0x00, 0x50, 0x30, 0x00, 0x00,// 0C
;0x08, 0x08, 0x08, 0x08, 0x08,// 0D
;0x00, 0x60, 0x60, 0x00, 0x00,// 0E
;0x20, 0x10, 0x08, 0x04, 0x02,// 0F
;0x00, 0x00, 0x00, 0x00, 0x00,// 10
;0x00, 0x00, 0x5F, 0x00, 0x00,// 11
;0x00, 0x07, 0x00, 0x07, 0x00,// 12
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 13
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 14
;0x23, 0x13, 0x08, 0x64, 0x62,// 15
;0x36, 0x49, 0x55, 0x22, 0x50,// 16
;0x00, 0x05, 0x03, 0x00, 0x00,// 17
;0x00, 0x1C, 0x22, 0x41, 0x00,// 18
;0x00, 0x41, 0x22, 0x1C, 0x00,// 19
;0x14, 0x08, 0x3E, 0x08, 0x14,// 1A
;0x08, 0x08, 0x3E, 0x08, 0x08,// 1B
;0x00, 0x50, 0x30, 0x00, 0x00,// 1C
;0x08, 0x08, 0x08, 0x08, 0x08,// 1D
;0x00, 0x60, 0x60, 0x00, 0x00,// 1E
;0x20, 0x10, 0x08, 0x04, 0x02,// 1F
;0x00, 0x00, 0x00, 0x00, 0x00,// 20 space
;0x00, 0x00, 0x5F, 0x00, 0x00,// 21 !
;0x00, 0x07, 0x00, 0x07, 0x00,// 22 "
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 23 #
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 24 $
;0x23, 0x13, 0x08, 0x64, 0x62,// 25 %
;0x36, 0x49, 0x55, 0x22, 0x50,// 26 &
;0x00, 0x05, 0x03, 0x00, 0x00,// 27 '
;0x00, 0x1C, 0x22, 0x41, 0x00,// 28 (
;0x00, 0x41, 0x22, 0x1C, 0x00,// 29 )
;0x14, 0x08, 0x3E, 0x08, 0x14,// 2a *
;0x08, 0x08, 0x3E, 0x08, 0x08,// 2b +
;0x00, 0x50, 0x30, 0x00, 0x00,// 2c ,
;0x08, 0x08, 0x08, 0x08, 0x08,// 2d -
;0x00, 0x60, 0x60, 0x00, 0x00,// 2e .
;0x20, 0x10, 0x08, 0x04, 0x02,// 2f /
;0x3E, 0x51, 0x49, 0x45, 0x3E,// 30 0
;0x00, 0x42, 0x7F, 0x40, 0x00,// 31 1
;0x42, 0x61, 0x51, 0x49, 0x46,// 32 2
;0x21, 0x41, 0x45, 0x4B, 0x31,// 33 3
;0x18, 0x14, 0x12, 0x7F, 0x10,// 34 4
;0x27, 0x45, 0x45, 0x45, 0x39,// 35 5
;0x3C, 0x4A, 0x49, 0x49, 0x30,// 36 6
;0x01, 0x71, 0x09, 0x05, 0x03,// 37 7
;0x36, 0x49, 0x49, 0x49, 0x36,// 38 8
;0x06, 0x49, 0x49, 0x29, 0x1E,// 39 9
;0x00, 0x36, 0x36, 0x00, 0x00,// 3a :
;0x00, 0x56, 0x36, 0x00, 0x00,// 3b ;
;0x08, 0x14, 0x22, 0x41, 0x00,// 3c <
;0x14, 0x14, 0x14, 0x14, 0x14,// 3d =
;0x00, 0x41, 0x22, 0x14, 0x08,// 3e >
;0x02, 0x01, 0x51, 0x09, 0x06,// 3f ?
;0x32, 0x49, 0x79, 0x41, 0x3E,// 40 @
;0x7E, 0x11, 0x11, 0x11, 0x7E,// 41 A
;0x7F, 0x49, 0x49, 0x49, 0x36,// 42 B
;0x3E, 0x41, 0x41, 0x41, 0x22,// 43 C
;0x7F, 0x41, 0x41, 0x22, 0x1C,// 44 D
;0x7F, 0x49, 0x49, 0x49, 0x41,// 45 E
;0x7F, 0x09, 0x09, 0x09, 0x01,// 46 F
;0x3E, 0x41, 0x49, 0x49, 0x7A,// 47 G
;0x7F, 0x08, 0x08, 0x08, 0x7F,// 48 H
;0x00, 0x41, 0x7F, 0x41, 0x00,// 49 I
;0x20, 0x40, 0x41, 0x3F, 0x01,// 4a J
;0x7F, 0x08, 0x14, 0x22, 0x41,// 4b K
;0x7F, 0x40, 0x40, 0x40, 0x40,// 4c L
;0x7F, 0x02, 0x0C, 0x02, 0x7F,// 4d M
;0x7F, 0x04, 0x08, 0x10, 0x7F,// 4e N
;0x3E, 0x41, 0x41, 0x41, 0x3E,// 4f O
;0x7F, 0x09, 0x09, 0x09, 0x06,// 50 P
;0x3E, 0x41, 0x51, 0x21, 0x5E,// 51 Q
;0x7F, 0x09, 0x19, 0x29, 0x46,// 52 R
;0x46, 0x49, 0x49, 0x49, 0x31,// 53 S
;0x01, 0x01, 0x7F, 0x01, 0x01,// 54 T
;0x3F, 0x40, 0x40, 0x40, 0x3F,// 55 U
;0x1F, 0x20, 0x40, 0x20, 0x1F,// 56 V
;0x3F, 0x40, 0x38, 0x40, 0x3F,// 57 W
;0x63, 0x14, 0x08, 0x14, 0x63,// 58 X
;0x07, 0x08, 0x70, 0x08, 0x07,// 59 Y
;0x61, 0x51, 0x49, 0x45, 0x43,// 5a Z
;0x00, 0x7F, 0x41, 0x41, 0x00,// 5b [
;0x02, 0x04, 0x08, 0x10, 0x20,// 5c Yen Currency Sign
;0x00, 0x41, 0x41, 0x7F, 0x00,// 5d ]
;0x04, 0x02, 0x01, 0x02, 0x04,// 5e ^
;0x40, 0x40, 0x40, 0x40, 0x40,// 5f _
;0x00, 0x01, 0x02, 0x04, 0x00,// 60 `
;0x20, 0x54, 0x54, 0x54, 0x78,// 61 a
;0x7F, 0x48, 0x44, 0x44, 0x38,// 62 b
;0x38, 0x44, 0x44, 0x44, 0x20,// 63 c
;0x38, 0x44, 0x44, 0x48, 0x7F,// 64 d
;0x38, 0x54, 0x54, 0x54, 0x18,// 65 e
;0x08, 0x7E, 0x09, 0x01, 0x02,// 66 f
;0x0C, 0x52, 0x52, 0x52, 0x3E,// 67 g
;0x7F, 0x08, 0x04, 0x04, 0x78,// 68 h
;0x00, 0x44, 0x7D, 0x40, 0x00,// 69 i
;0x20, 0x40, 0x44, 0x3D, 0x00,// 6a j
;0x7F, 0x10, 0x28, 0x44, 0x00,// 6b k
;0x00, 0x41, 0x7F, 0x40, 0x00,// 6c l
;0x7C, 0x04, 0x18, 0x04, 0x78,// 6d m
;0x7C, 0x08, 0x04, 0x04, 0x78,// 6e n
;0x38, 0x44, 0x44, 0x44, 0x38,// 6f o
;0x7C, 0x14, 0x14, 0x14, 0x08,// 70 p
;0x08, 0x14, 0x14, 0x18, 0x7C,// 71 q
;0x7C, 0x08, 0x04, 0x04, 0x08,// 72 r
;0x48, 0x54, 0x54, 0x54, 0x20,// 73 s
;0x04, 0x3F, 0x44, 0x40, 0x20,// 74 t
;0x3C, 0x40, 0x40, 0x20, 0x7C,// 75 u
;0x1C, 0x20, 0x40, 0x20, 0x1C,// 76 v
;0x3C, 0x40, 0x30, 0x40, 0x3C,// 77 w
;0x44, 0x28, 0x10, 0x28, 0x44,// 78 x
;0x0C, 0x50, 0x50, 0x50, 0x3C,// 79 y
;0x44, 0x64, 0x54, 0x4C, 0x44,// 7a z
;0x00, 0x08, 0x36, 0x41, 0x00,// 7b <
;0x00, 0x00, 0x7F, 0x00, 0x00,// 7c |
;0x00, 0x41, 0x36, 0x08, 0x00,// 7d >
;0x10, 0x08, 0x08, 0x10, 0x08,// 7e Right Arrow ->
;0x78, 0x46, 0x41, 0x46, 0x78,// 7f Left Arrow <-
;0x00, 0x00, 0x00, 0x00, 0x00,// 80
;0x00, 0x00, 0x5F, 0x00, 0x00,// 81
;0x00, 0x07, 0x00, 0x07, 0x00,// 82
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 83
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 84
;0x23, 0x13, 0x08, 0x64, 0x62,// 85
;0x36, 0x49, 0x55, 0x22, 0x50,// 86
;0x00, 0x05, 0x03, 0x00, 0x00,// 87
;0x00, 0x1C, 0x22, 0x41, 0x00,// 88
;0x00, 0x41, 0x22, 0x1C, 0x00,// 89
;0x14, 0x08, 0x3E, 0x08, 0x14,// 8A
;0x08, 0x08, 0x3E, 0x08, 0x08,// 8B
;0x00, 0x50, 0x30, 0x00, 0x00,// 8C
;0x08, 0x08, 0x08, 0x08, 0x08,// 8D
;0x00, 0x60, 0x60, 0x00, 0x00,// 8E
;0x20, 0x10, 0x08, 0x04, 0x02,// 8F
;0x00, 0x00, 0x00, 0x00, 0x00,// 90
;0x00, 0x00, 0x5F, 0x00, 0x00,// 91
;0x00, 0x07, 0x00, 0x07, 0x00,// 92
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 93
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 94
;0x23, 0x13, 0x08, 0x64, 0x62,// 95
;0x36, 0x49, 0x55, 0x22, 0x50,// 96
;0x00, 0x05, 0x03, 0x00, 0x00,// 97
;0x00, 0x1C, 0x22, 0x41, 0x00,// 98
;0x00, 0x41, 0x22, 0x1C, 0x00,// 99
;0x14, 0x08, 0x3E, 0x08, 0x14,// 9A
;0x08, 0x08, 0x3E, 0x08, 0x08,// 9B
;0x00, 0x50, 0x30, 0x00, 0x00,// 9C
;0x08, 0x08, 0x08, 0x08, 0x08,// 9D
;0x00, 0x60, 0x60, 0x00, 0x00,// 9E
;0x20, 0x10, 0x08, 0x04, 0x02,// 9F
;0x00, 0x00, 0x00, 0x00, 0x00,// A0
;0x00, 0x00, 0x5F, 0x00, 0x00,// A1
;0x00, 0x07, 0x00, 0x07, 0x00,// A2
;0x14, 0x7F, 0x14, 0x7F, 0x14,// A3
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// A4
;0x23, 0x13, 0x08, 0x64, 0x62,// A5
;0x36, 0x49, 0x55, 0x22, 0x50,// A6
;0x00, 0x05, 0x03, 0x00, 0x00,// A7
;0x00, 0x1C, 0x22, 0x41, 0x00,// A8
;0x00, 0x41, 0x22, 0x1C, 0x00,// A9
;0x14, 0x08, 0x3E, 0x08, 0x14,// AA
;0x08, 0x08, 0x3E, 0x08, 0x08,// AB
;0x00, 0x50, 0x30, 0x00, 0x00,// AC
;0x08, 0x08, 0x08, 0x08, 0x08,// AD
;0x00, 0x60, 0x60, 0x00, 0x00,// AE
;0x20, 0x10, 0x08, 0x04, 0x02,// AF
;0x3E, 0x51, 0x49, 0x45, 0x3E,// B0
;0x00, 0x42, 0x7F, 0x40, 0x00,// B1
;0x42, 0x61, 0x51, 0x49, 0x46,// B2
;0x21, 0x41, 0x45, 0x4B, 0x31,// B3
;0x18, 0x14, 0x12, 0x7F, 0x10,// B4
;0x27, 0x45, 0x45, 0x45, 0x39,// B5
;0x3C, 0x4A, 0x49, 0x49, 0x30,// B6
;0x01, 0x71, 0x09, 0x05, 0x03,// B7
;0x36, 0x49, 0x49, 0x49, 0x36,// B8
;0x06, 0x49, 0x49, 0x29, 0x1E,// B9
;0x00, 0x36, 0x36, 0x00, 0x00,// BA
;0x00, 0x56, 0x36, 0x00, 0x00,// BB
;0x08, 0x14, 0x22, 0x41, 0x00,// BC
;0x14, 0x14, 0x14, 0x14, 0x14,// BD
;0x00, 0x41, 0x22, 0x14, 0x08,// BE
;0x02, 0x01, 0x51, 0x09, 0x06,// BF
;0x7E, 0x11, 0x11, 0x11, 0x7E,// C0 ?
;0x7F, 0x49, 0x49, 0x49, 0x31,// C1 ?
;0x7F, 0x49, 0x49, 0x49, 0x36,// C2 ?
;0x7F, 0x01, 0x01, 0x01, 0x03,// C3 ?
;0x70, 0x29, 0x27, 0x21, 0x7F,// C4 ?
;0x7F, 0x49, 0x49, 0x49, 0x41,// C5 ?
;0x77, 0x08, 0x7F, 0x08, 0x77,// C6 ?
;0x41, 0x41, 0x41, 0x49, 0x76,// C7 ?
;0x7F, 0x10, 0x08, 0x04, 0x7F,// C8 ?
;0x7F, 0x10, 0x09, 0x04, 0x7F,// C9 ?
;0x7F, 0x08, 0x14, 0x22, 0x41,// CA ?
;0x20, 0x41, 0x3F, 0x01, 0x7F,// CB ?
;0x7F, 0x02, 0x0C, 0x02, 0x7F,// CC ?
;0x7F, 0x08, 0x08, 0x08, 0x7F,// CD ?
;0x3E, 0x41, 0x41, 0x41, 0x3E,// CE ?
;0x7F, 0x01, 0x01, 0x01, 0x7F,// CF ?
;0x7F, 0x09, 0x09, 0x09, 0x06,// D0 ?
;0x3E, 0x41, 0x41, 0x41, 0x22,// D1 ?
;0x01, 0x01, 0x7F, 0x01, 0x01,// D2 ?
;0x47, 0x28, 0x10, 0x08, 0x07,// D3 ?
;0x1E, 0x21, 0x7F, 0x21, 0x1E,// D4 ?
;0x63, 0x14, 0x08, 0x14, 0x63,// D5 ?
;0x3F, 0x20, 0x20, 0x20, 0x5F,// D6 ?
;0x07, 0x08, 0x08, 0x08, 0x7F,// D7 ?
;0x7F, 0x40, 0x7F, 0x40, 0x7F,// D8 ?
;0x3F, 0x20, 0x3F, 0x20, 0x5F,// D9 ?
;0x01, 0x7F, 0x48, 0x48, 0x30,// DA ?
;0x7F, 0x48, 0x30, 0x00, 0x7F,// DB ?
;0x00, 0x7F, 0x48, 0x48, 0x30,// DC ?
;0x41, 0x41, 0x41, 0x49, 0x3E,// DD ?
;0x7F, 0x08, 0x3E, 0x41, 0x3E,// DE ?
;0x46, 0x29, 0x19, 0x09, 0x7F,// DF ?
;0x20, 0x54, 0x54, 0x54, 0x78,// E0 ?
;0x3C, 0x4A, 0x4A, 0x49, 0x31,// E1 ?
;0x7C, 0x54, 0x54, 0x28, 0x00,// E2 ?
;0x7C, 0x04, 0x04, 0x04, 0x0C,// E3 ?
;0x72, 0x2A, 0x26, 0x22, 0x7E,// E4 ?
;0x38, 0x54, 0x54, 0x54, 0x18,// E5 ?
;0x6C, 0x10, 0x7C, 0x10, 0x6C,// E6 ?
;0x44, 0x44, 0x54, 0x54, 0x38,// E7 ?
;0x7C, 0x20, 0x10, 0x08, 0x7C,// E8 ?
;0x7C, 0x21, 0x12, 0x09, 0x7C,// E9 ?
;0x7C, 0x10, 0x28, 0x44, 0x00,// EA ?
;0x20, 0x44, 0x3C, 0x04, 0x7C,// EB ?
;0x7C, 0x08, 0x10, 0x08, 0x7C,// EC ?
;0x7C, 0x10, 0x10, 0x10, 0x7C,// ED ?
;0x38, 0x44, 0x44, 0x44, 0x38,// EE ?
;0x7C, 0x04, 0x04, 0x04, 0x7C,// EF ?
;0x7C, 0x14, 0x14, 0x14, 0x08,// F0 ?
;0x38, 0x44, 0x44, 0x44, 0x20,// F1 ?
;0x04, 0x04, 0x7C, 0x04, 0x04,// F2 ?
;0x44, 0x28, 0x10, 0x08, 0x04,// F3 ?
;0x08, 0x14, 0x7E, 0x14, 0x08,// F4 ?
;0x44, 0x28, 0x10, 0x28, 0x44,// F5 ?
;0x3C, 0x40, 0x40, 0x7C, 0x40,// F6 ?
;0x0C, 0x10, 0x10, 0x10, 0x7C,// F7 ?
;0x7C, 0x40, 0x7C, 0x40, 0x7C,// F8 ?
;0x3C, 0x20, 0x3C, 0x20, 0x7C,// F9 ?
;0x04, 0x7C, 0x50, 0x50, 0x20,// FA ?
;0x7C, 0x50, 0x20, 0x00, 0x7C,// FB ?
;0x00, 0x7C, 0x50, 0x50, 0x20,// FC ?
;0x28, 0x44, 0x44, 0x54, 0x38,// FD ?
;0x7C, 0x10, 0x38, 0x44, 0x38,// FE ?
;0x48, 0x54, 0x34, 0x14, 0x7C }; // FF
;
;void LcdSend (unsigned char data, unsigned char cmd)    //Sends data to display controller
; 0000 000F         {

	.CSEG
;PCODE: $0000000D VOL: 0
;PCODE: $0000000E VOL: 0
;        #ifdef SOFT_SPI
;        unsigned char i, mask = 128;
;        #endif
;
;        LCD_CPORT.LCD_CPIN = 0;                //Enable display controller (active low)
;PCODE: $0000000F VOL: 0
;PCODE: $00000010 VOL: 0
;	data -> Y+3
;	cmd -> Y+2
;	i -> R17
;	mask -> R16
;PCODE: $00000011 VOL: 0
;PCODE: $00000012 VOL: 0
;PCODE: $00000013 VOL: 0
;PCODE: $00000014 VOL: 0
;         if (cmd) LCD_DC_PORT.LCD_DC_PIN = 1;	//выбираем команда или данные
;PCODE: $00000015 VOL: 0
;PCODE: $00000016 VOL: 0
;PCODE: $00000017 VOL: 0
;PCODE: $00000018 VOL: 0
;PCODE: $00000019 VOL: 0
;         else LCD_DC_PORT.LCD_DC_PIN = 0;
;PCODE: $0000001A VOL: 0
;PCODE: $0000001B VOL: 0
;PCODE: $0000001C VOL: 0
;PCODE: $0000001D VOL: 0
;
;        #ifdef SOFT_SPI
;        for (i=0;i<8;i++)
;PCODE: $0000001E VOL: 0
;PCODE: $0000001F VOL: 0
;PCODE: $00000020 VOL: 0
;PCODE: $00000021 VOL: 0
;PCODE: $00000022 VOL: 0
;PCODE: $00000023 VOL: 0
;PCODE: $00000024 VOL: 0
;PCODE: $00000025 VOL: 0
;PCODE: $00000026 VOL: 0
;PCODE: $00000027 VOL: 0
;          {
;            	if ((data&mask)!=0) LCD_MOSI_PORT.LCD_MOSI_PIN = 1;
;PCODE: $00000028 VOL: 0
;PCODE: $00000029 VOL: 0
;PCODE: $0000002A VOL: 0
;PCODE: $0000002B VOL: 0
;PCODE: $0000002C VOL: 0
;PCODE: $0000002D VOL: 0
;                else LCD_MOSI_PORT.LCD_MOSI_PIN = 0;
;PCODE: $0000002E VOL: 0
;PCODE: $0000002F VOL: 0
;PCODE: $00000030 VOL: 0
;PCODE: $00000031 VOL: 0
;        	mask = mask/2;
;PCODE: $00000032 VOL: 0
;PCODE: $00000033 VOL: 0
;        	LCD_CLK_PORT.LCD_CLK_PIN = 1;
;PCODE: $00000034 VOL: 0
;PCODE: $00000035 VOL: 0
;            LCD_CLK_PORT.LCD_CLK_PIN = 0;
;PCODE: $00000036 VOL: 0
;PCODE: $00000037 VOL: 0
;          }
;PCODE: $00000038 VOL: 0
;PCODE: $00000039 VOL: 0
;PCODE: $0000003A VOL: 0
;PCODE: $0000003B VOL: 0
;PCODE: $0000003C VOL: 0
;        #endif
;
;        #ifndef SOFT_SPI
;        SPDR = data;                            //Send data to display controller
;        while ( (SPSR & 0x80) != 0x80 );        //Wait until Tx register empty
;        #endif
;
;        LCD_CPORT.LCD_CPIN = 1;                //Disable display controller
;PCODE: $0000003D VOL: 0
;PCODE: $0000003E VOL: 0
;        }
;PCODE: $0000003F VOL: 0
;PCODE: $00000040 VOL: 0
;PCODE: $00000041 VOL: 0
;PCODE: $00000042 VOL: 0
;PCODE: $00000043 VOL: 0
;PCODE: $00000044 VOL: 0
;PCODE: $00000045 VOL: 0
;
;void LcdUpdate (void)   //Copies the LCD cache into the device RAM
;        {
;PCODE: $00000046 VOL: 0
;PCODE: $00000047 VOL: 0
;        int i;
;	#ifdef china
;	char j;
;	#endif
;
;        LcdSend(0x80, LCD_CMD);		//команды установки указателя памяти дисплея на 0,0
;PCODE: $00000048 VOL: 0
;PCODE: $00000049 VOL: 0
;	i -> R16,R17
;PCODE: $0000004A VOL: 0
;PCODE: $0000004B VOL: 0
;PCODE: $0000004C VOL: 0
;PCODE: $0000004D VOL: 0
;PCODE: $0000004E VOL: 0
;        LcdSend(0x40, LCD_CMD);
;PCODE: $0000004F VOL: 0
;PCODE: $00000050 VOL: 0
;PCODE: $00000051 VOL: 0
;PCODE: $00000052 VOL: 0
;PCODE: $00000053 VOL: 0
;
;    #ifdef china                    		//если китайский дисплей - грузим пустую строку
;		for (j = Cntr_X_RES; j>0; j--) LcdSend(0, LCD_DATA);
;	#endif
;
;        for (i = 0; i < LCD_CACHSIZE; i++)		//грузим данные
;PCODE: $00000054 VOL: 0
;PCODE: $00000055 VOL: 0
;PCODE: $00000056 VOL: 0
;PCODE: $00000057 VOL: 0
;PCODE: $00000058 VOL: 0
;PCODE: $00000059 VOL: 0
;PCODE: $0000005A VOL: 0
;PCODE: $0000005B VOL: 0
;PCODE: $0000005C VOL: 0
;                {
;                LcdSend(LcdCache[i], LCD_DATA);
;PCODE: $0000005D VOL: 0
;PCODE: $0000005E VOL: 0
;PCODE: $0000005F VOL: 0
;PCODE: $00000060 VOL: 0
;PCODE: $00000061 VOL: 0
;PCODE: $00000062 VOL: 0
;PCODE: $00000063 VOL: 0
;		#ifdef china				//если дисплей китайский - догружаем каждую строку до размера его буфера
;		if (++j == LCD_X_RES)
;			{
;			for (j = (Cntr_X_RES-LCD_X_RES); j>0; j--) LcdSend(0, LCD_DATA);
;			j=0;
;			}
;		#endif
;                }
;PCODE: $00000064 VOL: 0
;PCODE: $00000065 VOL: 0
;PCODE: $00000066 VOL: 0
;PCODE: $00000067 VOL: 0
;PCODE: $00000068 VOL: 0
;        }
;PCODE: $00000069 VOL: 0
;PCODE: $0000006A VOL: 0
;PCODE: $0000006B VOL: 0
;
;void LcdClear (void)    //Clears the display
;{
;PCODE: $0000006C VOL: 0
;PCODE: $0000006D VOL: 0
;        int i;
;	for (i = 0; i < LCD_CACHSIZE; i++) LcdCache[i] = 0;	//забиваем всю память 0
;PCODE: $0000006E VOL: 0
;PCODE: $0000006F VOL: 0
;	i -> R16,R17
;PCODE: $00000070 VOL: 0
;PCODE: $00000071 VOL: 0
;PCODE: $00000072 VOL: 0
;PCODE: $00000073 VOL: 0
;PCODE: $00000074 VOL: 0
;PCODE: $00000075 VOL: 0
;PCODE: $00000076 VOL: 0
;PCODE: $00000077 VOL: 0
;PCODE: $00000078 VOL: 0
;PCODE: $00000079 VOL: 0
;PCODE: $0000007A VOL: 0
;PCODE: $0000007B VOL: 0
;PCODE: $0000007C VOL: 0
;PCODE: $0000007D VOL: 0
;PCODE: $0000007E VOL: 0
;PCODE: $0000007F VOL: 0
;PCODE: $00000080 VOL: 0
;PCODE: $00000081 VOL: 0
;PCODE: $00000082 VOL: 0
;}
;PCODE: $00000083 VOL: 0
;PCODE: $00000084 VOL: 0
;PCODE: $00000085 VOL: 0
;
;/*     or
;void lcd_clear(void) // Clears the display   //Upd - 7
;{
;	lcdCacheIdx = 0;
;	lcd_base_addr(lcdCacheIdx);
;    // Set the entire cache to zero and write 0s to lcd
;    for(int i=0;i<LCD_CACHE_SIZE;i++) {
;		lcd_send(0, LCD_DATA);
;    }
;}
;*/
;
;void LcdInit ( void )	//инициализация SPI и дисплея
;        {
;PCODE: $00000086 VOL: 0
;PCODE: $00000087 VOL: 0
;        LCD_RST_PORT.LCD_RST_PIN = 1;       //настроили порты ввода/вывода
;PCODE: $00000088 VOL: 0
;PCODE: $00000089 VOL: 0
;        LCD_RST_DDR.LCD_RST_PIN = LCD_DC_DDR.LCD_DC_PIN = LCD_CDDR.LCD_CPIN = LCD_MOSI_DDR.LCD_MOSI_PIN = LCD_CLK_DDR.LCD_CLK_PIN = 1;
;PCODE: $0000008A VOL: 0
;PCODE: $0000008B VOL: 0
;PCODE: $0000008C VOL: 0
;PCODE: $0000008D VOL: 0
;PCODE: $0000008E VOL: 0
;PCODE: $0000008F VOL: 0
;PCODE: $00000090 VOL: 0
;PCODE: $00000091 VOL: 0
;PCODE: $00000092 VOL: 0
;PCODE: $00000093 VOL: 0
;        LCD_CLK_PORT.LCD_CLK_PIN = 0;
;PCODE: $00000094 VOL: 0
;PCODE: $00000095 VOL: 0
;        	#ifndef SOFT_SPI
;        LCD_SS_DDR.LCD_SS_PIN = 1;
;        LCD_SS_PORT.LCD_SS_PIN = 0;
;        	#endif
;        delay_ms(1);
;PCODE: $00000096 VOL: 0
;PCODE: $00000097 VOL: 0
;PCODE: $00000098 VOL: 0
;        	#ifndef SOFT_SPI
;        //SPCR = SPCR_val;
;        //SPSR = SPSR_val;
;        	#endif
;        LCD_RST_PORT.LCD_RST_PIN = 0;       //дернули ресет
;PCODE: $00000099 VOL: 0
;PCODE: $0000009A VOL: 0
;        delay_ms(20);
;PCODE: $0000009B VOL: 0
;PCODE: $0000009C VOL: 0
;PCODE: $0000009D VOL: 0
;        LCD_RST_PORT.LCD_RST_PIN = 1;
;PCODE: $0000009E VOL: 0
;PCODE: $0000009F VOL: 0
;
;        LCD_CPORT.LCD_CPIN = 1;        //Disable LCD controller
;PCODE: $000000A0 VOL: 0
;PCODE: $000000A1 VOL: 0
;
;/*
;    LCD_PORT |= LCD_SCE_PIN;    // Disable LCD controller
;    lcd_send(0x21, LCD_CMD);  // LCD Extended Commands
;    lcd_send(0xC8, LCD_CMD);  // Set LCD Vop(Contrast)
;    lcd_send(0x06, LCD_CMD);  // Set Temp coefficent
;    lcd_send(0x13, LCD_CMD);  // LCD bias mode 1:48
;    lcd_send(0x20, LCD_CMD);  // Standard Commands, Horizontal addressing
;    lcd_send(0x0C, LCD_CMD);  // LCD in normal mode
;*/
;        LcdSend( 0b00100001, LCD_CMD ); 				//LCD Extended Commands
;PCODE: $000000A2 VOL: 0
;PCODE: $000000A3 VOL: 0
;PCODE: $000000A4 VOL: 0
;PCODE: $000000A5 VOL: 0
;PCODE: $000000A6 VOL: 0
;        LcdSend( 0b00000100+temp_control, LCD_CMD ); 	//Set Temp coefficent   //! НА 128 - ГЛЮЧИТ
;PCODE: $000000A7 VOL: 0
;PCODE: $000000A8 VOL: 0
;PCODE: $000000A9 VOL: 0
;PCODE: $000000AA VOL: 0
;PCODE: $000000AB VOL: 0
;PCODE: $000000AC VOL: 0
;#ifdef china
;        LcdSend( 0b00001000|SPI_invert<<3, LCD_CMD ); 	//порядок битов в SPI
;#endif
;        LcdSend( 0b00010000+bias, LCD_CMD ); 			//LCD bias mode 1:48
;PCODE: $000000AD VOL: 0
;PCODE: $000000AE VOL: 0
;PCODE: $000000AF VOL: 0
;PCODE: $000000B0 VOL: 0
;PCODE: $000000B1 VOL: 0
;PCODE: $000000B2 VOL: 0
;#ifdef china
;        LcdSend( 0b01000000+shift, LCD_CMD ); 			//первая строка выше экрана, отображаем со второй
;#endif
;	    LcdSend( 0b10000000+Vop, LCD_CMD ); 			//Set LCD Vop (Contrast)
;PCODE: $000000B3 VOL: 0
;PCODE: $000000B4 VOL: 0
;PCODE: $000000B5 VOL: 0
;PCODE: $000000B6 VOL: 0
;PCODE: $000000B7 VOL: 0
;PCODE: $000000B8 VOL: 0
;#ifdef china
;	    LcdSend( 0x20|x_mirror<<5|y_mirror<<4|power_down<<3, LCD_CMD );			//LCD Standard Commands
;#endif
;#ifndef china
;        LcdSend( 0x20|power_down<<3|addressing<<2, LCD_CMD );				//LCD Standard Commands
;PCODE: $000000B9 VOL: 0
;PCODE: $000000BA VOL: 0
;PCODE: $000000BB VOL: 0
;PCODE: $000000BC VOL: 0
;PCODE: $000000BD VOL: 0
;PCODE: $000000BE VOL: 0
;PCODE: $000000BF VOL: 0
;PCODE: $000000C0 VOL: 0
;PCODE: $000000C1 VOL: 0
;PCODE: $000000C2 VOL: 0
;PCODE: $000000C3 VOL: 0
;PCODE: $000000C4 VOL: 0
;PCODE: $000000C5 VOL: 0
;PCODE: $000000C6 VOL: 0
;PCODE: $000000C7 VOL: 0
;#endif
;        LcdSend( 0b00001000|((disp_config<<1|disp_config)&0b00000101), LCD_CMD ); 	//LCD mode
;PCODE: $000000C8 VOL: 0
;PCODE: $000000C9 VOL: 0
;PCODE: $000000CA VOL: 0
;PCODE: $000000CB VOL: 0
;PCODE: $000000CC VOL: 0
;PCODE: $000000CD VOL: 0
;PCODE: $000000CE VOL: 0
;PCODE: $000000CF VOL: 0
;PCODE: $000000D0 VOL: 0
;        LcdClear();
;PCODE: $000000D1 VOL: 0
;        }
;PCODE: $000000D2 VOL: 0
;PCODE: $000000D3 VOL: 0
;
;void LcdContrast (unsigned char contrast) 	//contrast -> Contrast value from 0x00 to 0x7F
;        {
;PCODE: $000000D4 VOL: 0
;PCODE: $000000D5 VOL: 0
;        if (contrast > 0x7F) return;
;	contrast -> Y+0
;PCODE: $000000D6 VOL: 0
;PCODE: $000000D7 VOL: 0
;PCODE: $000000D8 VOL: 0
;PCODE: $000000D9 VOL: 0
;PCODE: $000000DA VOL: 0
;        LcdSend( 0x21, LCD_CMD );               //LCD Extended Commands
;PCODE: $000000DB VOL: 0
;PCODE: $000000DC VOL: 0
;PCODE: $000000DD VOL: 0
;PCODE: $000000DE VOL: 0
;PCODE: $000000DF VOL: 0
;PCODE: $000000E0 VOL: 0
;        LcdSend( 0x80 | contrast, LCD_CMD );    //Set LCD Vop (Contrast)
;PCODE: $000000E1 VOL: 0
;PCODE: $000000E2 VOL: 0
;PCODE: $000000E3 VOL: 0
;PCODE: $000000E4 VOL: 0
;PCODE: $000000E5 VOL: 0
;PCODE: $000000E6 VOL: 0
;        LcdSend( 0x20, LCD_CMD );               //LCD Standard Commands,Horizontal addressing mode
;PCODE: $000000E7 VOL: 0
;PCODE: $000000E8 VOL: 0
;PCODE: $000000E9 VOL: 0
;PCODE: $000000EA VOL: 0
;PCODE: $000000EB VOL: 0
;        }
;PCODE: $000000EC VOL: 0
;PCODE: $000000ED VOL: 0
;PCODE: $000000EE VOL: 0
;
;void LcdMode (unsigned char mode) 		//режим дисплея: 0 - blank, 1 - all on, 2 - normal, 3 - inverse
;        {
;PCODE: $000000EF VOL: 0
;PCODE: $000000F0 VOL: 0
;        if (mode > 3) return;
;	mode -> Y+0
;PCODE: $000000F1 VOL: 0
;PCODE: $000000F2 VOL: 0
;PCODE: $000000F3 VOL: 0
;PCODE: $000000F4 VOL: 0
;PCODE: $000000F5 VOL: 0
;        LcdSend( 0b00001000|((mode<<1|mode)&0b00000101), LCD_CMD ); 	//LCD mode
;PCODE: $000000F6 VOL: 0
;PCODE: $000000F7 VOL: 0
;PCODE: $000000F8 VOL: 0
;PCODE: $000000F9 VOL: 0
;PCODE: $000000FA VOL: 0
;PCODE: $000000FB VOL: 0
;PCODE: $000000FC VOL: 0
;PCODE: $000000FD VOL: 0
;PCODE: $000000FE VOL: 0
;PCODE: $000000FF VOL: 0
;PCODE: $00000100 VOL: 0
;        }
;PCODE: $00000101 VOL: 0
;PCODE: $00000102 VOL: 0
;PCODE: $00000103 VOL: 0
;
; void LcdPwrMode (void) 				//инвертирует состояние вкл/выкл дисплея
;        {
;PCODE: $00000104 VOL: 0
;PCODE: $00000105 VOL: 0
;        power_down = ~power_down;
;PCODE: $00000106 VOL: 0
;PCODE: $00000107 VOL: 0
;PCODE: $00000108 VOL: 0
;        LcdSend( 0x20|power_down<<3, LCD_CMD );
;PCODE: $00000109 VOL: 0
;PCODE: $0000010A VOL: 0
;PCODE: $0000010B VOL: 0
;PCODE: $0000010C VOL: 0
;PCODE: $0000010D VOL: 0
;PCODE: $0000010E VOL: 0
;PCODE: $0000010F VOL: 0
;PCODE: $00000110 VOL: 0
;PCODE: $00000111 VOL: 0
;        }
;PCODE: $00000112 VOL: 0
;PCODE: $00000113 VOL: 0
;/*
;void LcdPwrMode (void) 				//инвертирует состояние вкл/выкл дисплея
;        {
;        power_down = ~power_down;
;        	#ifdef china
;	LcdSend( 0x20|x_mirror<<4|y_mirror<<3|power_down<<2|addressing<<1, LCD_CMD );			//LCD Standard Commands
;        	#elif
;        LcdSend( 0x20|0<<2|addressing<<1, LCD_CMD );
;                #endif
;        }
;
;void Lcd_off (void) 				//выкл дисплея
;        {
;        	#ifdef china
;	LcdSend( 0x20|x_mirror<<4|y_mirror<<3|1<<2|addressing<<1, LCD_CMD );			//LCD Standard Commands
;        	#elif
;        LcdSend( 0x20|1<<2|addressing<<1, LCD_CMD );
;                #endif
;        }
;
;void Lcd_on (void) 				//вкл дисплея
;        {
;        	#ifdef china
;	LcdSend( 0x20|x_mirror<<4|y_mirror<<3|0<<2|addressing<<1, LCD_CMD );			//LCD Standard Commands
;        	#elif
;        LcdSend( 0x20|0<<2|addressing<<1, LCD_CMD );
;                #endif
;        }   */
;
;
;
;void LcdImage (flash unsigned char *imageData)	//вывод изображения
;        {
;PCODE: $00000114 VOL: 0
;PCODE: $00000115 VOL: 0
;        unsigned int i;
;
;        LcdSend(0x80, LCD_CMD);		//ставим указатель на 0,0
;PCODE: $00000116 VOL: 0
;PCODE: $00000117 VOL: 0
;	*imageData -> Y+2
;	i -> R16,R17
;PCODE: $00000118 VOL: 0
;PCODE: $00000119 VOL: 0
;PCODE: $0000011A VOL: 0
;PCODE: $0000011B VOL: 0
;PCODE: $0000011C VOL: 0
;        LcdSend(0x40, LCD_CMD);
;PCODE: $0000011D VOL: 0
;PCODE: $0000011E VOL: 0
;PCODE: $0000011F VOL: 0
;PCODE: $00000120 VOL: 0
;PCODE: $00000121 VOL: 0
;        for (i = 0; i < LCD_CACHSIZE; i++) LcdCache[i] = imageData[i];	//грузим данные
;PCODE: $00000122 VOL: 0
;PCODE: $00000123 VOL: 0
;PCODE: $00000124 VOL: 0
;PCODE: $00000125 VOL: 0
;PCODE: $00000126 VOL: 0
;PCODE: $00000127 VOL: 0
;PCODE: $00000128 VOL: 0
;PCODE: $00000129 VOL: 0
;PCODE: $0000012A VOL: 0
;PCODE: $0000012B VOL: 0
;PCODE: $0000012C VOL: 0
;PCODE: $0000012D VOL: 0
;PCODE: $0000012E VOL: 0
;PCODE: $0000012F VOL: 0
;PCODE: $00000130 VOL: 0
;PCODE: $00000131 VOL: 0
;PCODE: $00000132 VOL: 0
;PCODE: $00000133 VOL: 0
;PCODE: $00000134 VOL: 0
;PCODE: $00000135 VOL: 0
;PCODE: $00000136 VOL: 0
;PCODE: $00000137 VOL: 0
;PCODE: $00000138 VOL: 0
;PCODE: $00000139 VOL: 0
;PCODE: $0000013A VOL: 0
;PCODE: $0000013B VOL: 0
;PCODE: $0000013C VOL: 0
;PCODE: $0000013D VOL: 0
;PCODE: $0000013E VOL: 0
;PCODE: $0000013F VOL: 0
;
;void LcdPixel (unsigned char x, unsigned char y, unsigned char mode)     //Displays a pixel at given absolute (x, y) location, mode -> Off, On or Xor
;        {
;PCODE: $00000140 VOL: 0
;PCODE: $00000141 VOL: 0
;        int index;
;        unsigned char offset, data;
;
;        if ( x > LCD_X_RES ) return;	//если передали в функцию муть - выходим
;PCODE: $00000142 VOL: 0
;	x -> Y+6
;	y -> Y+5
;	mode -> Y+4
;	index -> R16,R17
;	offset -> R19
;	data -> R18
;PCODE: $00000143 VOL: 0
;PCODE: $00000144 VOL: 0
;PCODE: $00000145 VOL: 0
;PCODE: $00000146 VOL: 0
;PCODE: $00000147 VOL: 0
;PCODE: $00000148 VOL: 0
;        if ( y > LCD_Y_RES ) return;
;PCODE: $00000149 VOL: 0
;PCODE: $0000014A VOL: 0
;PCODE: $0000014B VOL: 0
;PCODE: $0000014C VOL: 0
;PCODE: $0000014D VOL: 0
;PCODE: $0000014E VOL: 0
;PCODE: $0000014F VOL: 0
;
;        index = (((int)(y)/8)*84)+x;    //считаем номер байта в массиве памяти дисплея
;PCODE: $00000150 VOL: 0
;PCODE: $00000151 VOL: 0
;PCODE: $00000152 VOL: 0
;PCODE: $00000153 VOL: 0
;PCODE: $00000154 VOL: 0
;PCODE: $00000155 VOL: 0
;PCODE: $00000156 VOL: 0
;PCODE: $00000157 VOL: 0
;PCODE: $00000158 VOL: 0
;PCODE: $00000159 VOL: 0
;PCODE: $0000015A VOL: 0
;PCODE: $0000015B VOL: 0
;        offset  = y-((y/8)*8);          //считаем номер бита в этом байте
;PCODE: $0000015C VOL: 0
;PCODE: $0000015D VOL: 0
;PCODE: $0000015E VOL: 0
;PCODE: $0000015F VOL: 0
;PCODE: $00000160 VOL: 0
;PCODE: $00000161 VOL: 0
;
;        data = LcdCache[index];         //берем байт по найденному индексу
;PCODE: $00000162 VOL: 0
;PCODE: $00000163 VOL: 0
;PCODE: $00000164 VOL: 0
;
;        if ( mode == PIXEL_OFF ) data &= ( ~( 0x01 << offset ) );	//редактируем бит в этом байте
;PCODE: $00000165 VOL: 0
;PCODE: $00000166 VOL: 0
;PCODE: $00000167 VOL: 0
;PCODE: $00000168 VOL: 0
;PCODE: $00000169 VOL: 0
;PCODE: $0000016A VOL: 0
;PCODE: $0000016B VOL: 0
;PCODE: $0000016C VOL: 0
;PCODE: $0000016D VOL: 0
;                else if ( mode == PIXEL_ON ) data |= ( 0x01 << offset );
;PCODE: $0000016E VOL: 0
;PCODE: $0000016F VOL: 0
;PCODE: $00000170 VOL: 0
;PCODE: $00000171 VOL: 0
;PCODE: $00000172 VOL: 0
;PCODE: $00000173 VOL: 0
;PCODE: $00000174 VOL: 0
;PCODE: $00000175 VOL: 0
;PCODE: $00000176 VOL: 0
;PCODE: $00000177 VOL: 0
;                        else if ( mode  == PIXEL_XOR ) data ^= ( 0x01 << offset );
;PCODE: $00000178 VOL: 0
;PCODE: $00000179 VOL: 0
;PCODE: $0000017A VOL: 0
;PCODE: $0000017B VOL: 0
;PCODE: $0000017C VOL: 0
;PCODE: $0000017D VOL: 0
;PCODE: $0000017E VOL: 0
;PCODE: $0000017F VOL: 0
;PCODE: $00000180 VOL: 0
;PCODE: $00000181 VOL: 0
;
;        LcdCache[index] = data;		//загружаем байт назад
;PCODE: $00000182 VOL: 0
;PCODE: $00000183 VOL: 0
;PCODE: $00000184 VOL: 0
;PCODE: $00000185 VOL: 0
;PCODE: $00000186 VOL: 0
;PCODE: $00000187 VOL: 0
;        }
;PCODE: $00000188 VOL: 0
;PCODE: $00000189 VOL: 0
;PCODE: $0000018A VOL: 0
;PCODE: $0000018B VOL: 0
;
;void LcdLine (int x1, int y1, int x2, int y2, unsigned char mode)  	//Draws a line between two points on the display - по Брезенхейму
;        {
;PCODE: $0000018C VOL: 0
;PCODE: $0000018D VOL: 0
;        signed int dy = 0;
;        signed int dx = 0;
;        signed int stepx = 0;
;        signed int stepy = 0;
;        signed int fraction = 0;
;
;        if (x1>LCD_X_RES || x2>LCD_X_RES || y1>LCD_Y_RES || y2>LCD_Y_RES) return;
;PCODE: $0000018E VOL: 0
;PCODE: $0000018F VOL: 0
;PCODE: $00000190 VOL: 0
;PCODE: $00000191 VOL: 0
;PCODE: $00000192 VOL: 0
;PCODE: $00000193 VOL: 0
;PCODE: $00000194 VOL: 0
;PCODE: $00000195 VOL: 0
;PCODE: $00000196 VOL: 0
;PCODE: $00000197 VOL: 0
;	x1 -> Y+17
;	y1 -> Y+15
;	x2 -> Y+13
;	y2 -> Y+11
;	mode -> Y+10
;	dy -> R16,R17
;	dx -> R18,R19
;	stepx -> R20,R21
;	stepy -> Y+8
;	fraction -> Y+6
;PCODE: $00000198 VOL: 0
;PCODE: $00000199 VOL: 0
;PCODE: $0000019A VOL: 0
;PCODE: $0000019B VOL: 0
;PCODE: $0000019C VOL: 0
;PCODE: $0000019D VOL: 0
;PCODE: $0000019E VOL: 0
;PCODE: $0000019F VOL: 0
;PCODE: $000001A0 VOL: 0
;PCODE: $000001A1 VOL: 0
;PCODE: $000001A2 VOL: 0
;PCODE: $000001A3 VOL: 0
;PCODE: $000001A4 VOL: 0
;PCODE: $000001A5 VOL: 0
;PCODE: $000001A6 VOL: 0
;PCODE: $000001A7 VOL: 0
;PCODE: $000001A8 VOL: 0
;PCODE: $000001A9 VOL: 0
;PCODE: $000001AA VOL: 0
;PCODE: $000001AB VOL: 0
;PCODE: $000001AC VOL: 0
;PCODE: $000001AD VOL: 0
;PCODE: $000001AE VOL: 0
;
;        dy = y2 - y1;
;PCODE: $000001AF VOL: 0
;PCODE: $000001B0 VOL: 0
;PCODE: $000001B1 VOL: 0
;PCODE: $000001B2 VOL: 0
;PCODE: $000001B3 VOL: 0
;        dx = x2 - x1;
;PCODE: $000001B4 VOL: 0
;PCODE: $000001B5 VOL: 0
;PCODE: $000001B6 VOL: 0
;PCODE: $000001B7 VOL: 0
;        if (dy < 0)
;PCODE: $000001B8 VOL: 0
;PCODE: $000001B9 VOL: 0
;                {
;                dy = -dy;
;PCODE: $000001BA VOL: 0
;PCODE: $000001BB VOL: 0
;PCODE: $000001BC VOL: 0
;                stepy = -1;
;PCODE: $000001BD VOL: 0
;PCODE: $000001BE VOL: 0
;                }
;                else stepy = 1;
;PCODE: $000001BF VOL: 0
;PCODE: $000001C0 VOL: 0
;PCODE: $000001C1 VOL: 0
;PCODE: $000001C2 VOL: 0
;        if (dx < 0)
;PCODE: $000001C3 VOL: 0
;PCODE: $000001C4 VOL: 0
;PCODE: $000001C5 VOL: 0
;                {
;                dx = -dx;
;PCODE: $000001C6 VOL: 0
;PCODE: $000001C7 VOL: 0
;PCODE: $000001C8 VOL: 0
;                stepx = -1;
;PCODE: $000001C9 VOL: 0
;PCODE: $000001CA VOL: 0
;                }
;                else stepx = 1;
;PCODE: $000001CB VOL: 0
;PCODE: $000001CC VOL: 0
;PCODE: $000001CD VOL: 0
;PCODE: $000001CE VOL: 0
;        dy <<= 1;
;PCODE: $000001CF VOL: 0
;PCODE: $000001D0 VOL: 0
;        dx <<= 1;
;PCODE: $000001D1 VOL: 0
;        LcdPixel(x1,y1,mode);
;PCODE: $000001D2 VOL: 0
;PCODE: $000001D3 VOL: 0
;PCODE: $000001D4 VOL: 0
;PCODE: $000001D5 VOL: 0
;PCODE: $000001D6 VOL: 0
;PCODE: $000001D7 VOL: 0
;PCODE: $000001D8 VOL: 0
;        if (dx > dy)
;PCODE: $000001D9 VOL: 0
;PCODE: $000001DA VOL: 0
;PCODE: $000001DB VOL: 0
;                {
;                fraction = dy - (dx >> 1);
;PCODE: $000001DC VOL: 0
;PCODE: $000001DD VOL: 0
;PCODE: $000001DE VOL: 0
;PCODE: $000001DF VOL: 0
;PCODE: $000001E0 VOL: 0
;PCODE: $000001E1 VOL: 0
;                while (x1 != x2)
;PCODE: $000001E2 VOL: 0
;PCODE: $000001E3 VOL: 0
;PCODE: $000001E4 VOL: 0
;PCODE: $000001E5 VOL: 0
;PCODE: $000001E6 VOL: 0
;                        {
;                        if (fraction >= 0)
;PCODE: $000001E7 VOL: 0
;PCODE: $000001E8 VOL: 0
;PCODE: $000001E9 VOL: 0
;                                {
;                                y1 += stepy;
;PCODE: $000001EA VOL: 0
;PCODE: $000001EB VOL: 0
;PCODE: $000001EC VOL: 0
;PCODE: $000001ED VOL: 0
;                                fraction -= dx;
;PCODE: $000001EE VOL: 0
;PCODE: $000001EF VOL: 0
;PCODE: $000001F0 VOL: 0
;                                }
;                        x1 += stepx;
;PCODE: $000001F1 VOL: 0
;PCODE: $000001F2 VOL: 0
;PCODE: $000001F3 VOL: 0
;PCODE: $000001F4 VOL: 0
;PCODE: $000001F5 VOL: 0
;                        fraction += dy;
;PCODE: $000001F6 VOL: 0
;PCODE: $000001F7 VOL: 0
;PCODE: $000001F8 VOL: 0
;PCODE: $000001F9 VOL: 0
;                        LcdPixel(x1,y1,mode);
;PCODE: $000001FA VOL: 0
;PCODE: $000001FB VOL: 0
;PCODE: $000001FC VOL: 0
;PCODE: $000001FD VOL: 0
;PCODE: $000001FE VOL: 0
;PCODE: $000001FF VOL: 0
;PCODE: $00000200 VOL: 0
;                        }
;PCODE: $00000201 VOL: 0
;PCODE: $00000202 VOL: 0
;                }
;                else
;PCODE: $00000203 VOL: 0
;PCODE: $00000204 VOL: 0
;                        {
;                        fraction = dx - (dy >> 1);
;PCODE: $00000205 VOL: 0
;PCODE: $00000206 VOL: 0
;PCODE: $00000207 VOL: 0
;PCODE: $00000208 VOL: 0
;PCODE: $00000209 VOL: 0
;PCODE: $0000020A VOL: 0
;                        while (y1 != y2)
;PCODE: $0000020B VOL: 0
;PCODE: $0000020C VOL: 0
;PCODE: $0000020D VOL: 0
;PCODE: $0000020E VOL: 0
;PCODE: $0000020F VOL: 0
;                                {
;                                if (fraction >= 0)
;PCODE: $00000210 VOL: 0
;PCODE: $00000211 VOL: 0
;PCODE: $00000212 VOL: 0
;                                        {
;                                        x1 += stepx;
;PCODE: $00000213 VOL: 0
;PCODE: $00000214 VOL: 0
;PCODE: $00000215 VOL: 0
;PCODE: $00000216 VOL: 0
;                                        fraction -= dy;
;PCODE: $00000217 VOL: 0
;PCODE: $00000218 VOL: 0
;PCODE: $00000219 VOL: 0
;                                        }
;                                y1 += stepy;
;PCODE: $0000021A VOL: 0
;PCODE: $0000021B VOL: 0
;PCODE: $0000021C VOL: 0
;PCODE: $0000021D VOL: 0
;PCODE: $0000021E VOL: 0
;                                fraction += dx;
;PCODE: $0000021F VOL: 0
;PCODE: $00000220 VOL: 0
;PCODE: $00000221 VOL: 0
;PCODE: $00000222 VOL: 0
;                                LcdPixel(x1,y1,mode);
;PCODE: $00000223 VOL: 0
;PCODE: $00000224 VOL: 0
;PCODE: $00000225 VOL: 0
;PCODE: $00000226 VOL: 0
;PCODE: $00000227 VOL: 0
;PCODE: $00000228 VOL: 0
;PCODE: $00000229 VOL: 0
;                                }
;PCODE: $0000022A VOL: 0
;PCODE: $0000022B VOL: 0
;                        }
;PCODE: $0000022C VOL: 0
;        }
;PCODE: $0000022D VOL: 0
;PCODE: $0000022E VOL: 0
;PCODE: $0000022F VOL: 0
;PCODE: $00000230 VOL: 0
;
;#warning Upd-7 not tested!
;// Set the base address of the lcd
;void lcd_base_addr(unsigned int addr) {   //Upd-7
;PCODE: $00000231 VOL: 0
;PCODE: $00000232 VOL: 0
;	LcdSend(0x80 |(addr % LCD_X_RES), LCD_CMD);
;	addr -> Y+0
;PCODE: $00000233 VOL: 0
;PCODE: $00000234 VOL: 0
;PCODE: $00000235 VOL: 0
;PCODE: $00000236 VOL: 0
;PCODE: $00000237 VOL: 0
;PCODE: $00000238 VOL: 0
;PCODE: $00000239 VOL: 0
;PCODE: $0000023A VOL: 0
;	LcdSend(0x40 |(addr / LCD_X_RES), LCD_CMD);
;PCODE: $0000023B VOL: 0
;PCODE: $0000023C VOL: 0
;PCODE: $0000023D VOL: 0
;PCODE: $0000023E VOL: 0
;PCODE: $0000023F VOL: 0
;PCODE: $00000240 VOL: 0
;PCODE: $00000241 VOL: 0
;PCODE: $00000242 VOL: 0
;}
;PCODE: $00000243 VOL: 0
;PCODE: $00000244 VOL: 0
;PCODE: $00000245 VOL: 0
;
;/* Clears an area on a line */    //Upd-7
;/*
;void lcd_clear_area(unsigned char line, unsigned char startX, unsigned char endX)
;{
;    // Start and end positions of line
;    int start = (line-1)*84+(startX-1);
;    int end = (line-1)*84+(endX-1);
;
;	lcd_base_addr(start);
;
;    // Clear all data in range from cache
;    for(uint16_t i=start;i<end;i++) {
;       LcdSend(0, LCD_DATA);
;    }
;}
;*/
;
;void LcdCircle(char x, char y, char radius, unsigned char mode)		//рисуем круг по координатам с радиусом - по Брезенхейму
;        {
;PCODE: $00000246 VOL: 0
;PCODE: $00000247 VOL: 0
;        signed char xc = 0;
;        signed char yc = 0;
;        signed char p = 0;
;
;        if (x>LCD_X_RES || y>LCD_Y_RES) return;
;PCODE: $00000248 VOL: 0
;	x -> Y+7
;	y -> Y+6
;	radius -> Y+5
;	mode -> Y+4
;	xc -> R17
;	yc -> R16
;	p -> R19
;PCODE: $00000249 VOL: 0
;PCODE: $0000024A VOL: 0
;PCODE: $0000024B VOL: 0
;PCODE: $0000024C VOL: 0
;PCODE: $0000024D VOL: 0
;PCODE: $0000024E VOL: 0
;PCODE: $0000024F VOL: 0
;PCODE: $00000250 VOL: 0
;PCODE: $00000251 VOL: 0
;PCODE: $00000252 VOL: 0
;PCODE: $00000253 VOL: 0
;PCODE: $00000254 VOL: 0
;PCODE: $00000255 VOL: 0
;PCODE: $00000256 VOL: 0
;PCODE: $00000257 VOL: 0
;PCODE: $00000258 VOL: 0
;PCODE: $00000259 VOL: 0
;
;        yc=radius;
;PCODE: $0000025A VOL: 0
;PCODE: $0000025B VOL: 0
;PCODE: $0000025C VOL: 0
;        p = 3 - (radius<<1);
;PCODE: $0000025D VOL: 0
;PCODE: $0000025E VOL: 0
;PCODE: $0000025F VOL: 0
;PCODE: $00000260 VOL: 0
;PCODE: $00000261 VOL: 0
;        while (xc <= yc)
;PCODE: $00000262 VOL: 0
;PCODE: $00000263 VOL: 0
;PCODE: $00000264 VOL: 0
;PCODE: $00000265 VOL: 0
;                {
;                LcdPixel(x + xc, y + yc, mode);
;PCODE: $00000266 VOL: 0
;PCODE: $00000267 VOL: 0
;PCODE: $00000268 VOL: 0
;PCODE: $00000269 VOL: 0
;PCODE: $0000026A VOL: 0
;PCODE: $0000026B VOL: 0
;PCODE: $0000026C VOL: 0
;PCODE: $0000026D VOL: 0
;PCODE: $0000026E VOL: 0
;PCODE: $0000026F VOL: 0
;PCODE: $00000270 VOL: 0
;                LcdPixel(x + xc, y - yc, mode);
;PCODE: $00000271 VOL: 0
;PCODE: $00000272 VOL: 0
;PCODE: $00000273 VOL: 0
;PCODE: $00000274 VOL: 0
;PCODE: $00000275 VOL: 0
;PCODE: $00000276 VOL: 0
;PCODE: $00000277 VOL: 0
;PCODE: $00000278 VOL: 0
;PCODE: $00000279 VOL: 0
;PCODE: $0000027A VOL: 0
;                LcdPixel(x - xc, y + yc, mode);
;PCODE: $0000027B VOL: 0
;PCODE: $0000027C VOL: 0
;PCODE: $0000027D VOL: 0
;PCODE: $0000027E VOL: 0
;PCODE: $0000027F VOL: 0
;PCODE: $00000280 VOL: 0
;PCODE: $00000281 VOL: 0
;PCODE: $00000282 VOL: 0
;PCODE: $00000283 VOL: 0
;PCODE: $00000284 VOL: 0
;                LcdPixel(x - xc, y - yc, mode);
;PCODE: $00000285 VOL: 0
;PCODE: $00000286 VOL: 0
;PCODE: $00000287 VOL: 0
;PCODE: $00000288 VOL: 0
;PCODE: $00000289 VOL: 0
;PCODE: $0000028A VOL: 0
;PCODE: $0000028B VOL: 0
;PCODE: $0000028C VOL: 0
;PCODE: $0000028D VOL: 0
;                LcdPixel(x + yc, y + xc, mode);
;PCODE: $0000028E VOL: 0
;PCODE: $0000028F VOL: 0
;PCODE: $00000290 VOL: 0
;PCODE: $00000291 VOL: 0
;PCODE: $00000292 VOL: 0
;PCODE: $00000293 VOL: 0
;PCODE: $00000294 VOL: 0
;PCODE: $00000295 VOL: 0
;PCODE: $00000296 VOL: 0
;PCODE: $00000297 VOL: 0
;PCODE: $00000298 VOL: 0
;                LcdPixel(x + yc, y - xc, mode);
;PCODE: $00000299 VOL: 0
;PCODE: $0000029A VOL: 0
;PCODE: $0000029B VOL: 0
;PCODE: $0000029C VOL: 0
;PCODE: $0000029D VOL: 0
;PCODE: $0000029E VOL: 0
;PCODE: $0000029F VOL: 0
;PCODE: $000002A0 VOL: 0
;PCODE: $000002A1 VOL: 0
;PCODE: $000002A2 VOL: 0
;                LcdPixel(x - yc, y + xc, mode);
;PCODE: $000002A3 VOL: 0
;PCODE: $000002A4 VOL: 0
;PCODE: $000002A5 VOL: 0
;PCODE: $000002A6 VOL: 0
;PCODE: $000002A7 VOL: 0
;PCODE: $000002A8 VOL: 0
;PCODE: $000002A9 VOL: 0
;PCODE: $000002AA VOL: 0
;PCODE: $000002AB VOL: 0
;PCODE: $000002AC VOL: 0
;                LcdPixel(x - yc, y - xc, mode);
;PCODE: $000002AD VOL: 0
;PCODE: $000002AE VOL: 0
;PCODE: $000002AF VOL: 0
;PCODE: $000002B0 VOL: 0
;PCODE: $000002B1 VOL: 0
;PCODE: $000002B2 VOL: 0
;PCODE: $000002B3 VOL: 0
;PCODE: $000002B4 VOL: 0
;PCODE: $000002B5 VOL: 0
;                if (p < 0) p += (xc++ << 2) + 6;
;PCODE: $000002B6 VOL: 0
;PCODE: $000002B7 VOL: 0
;PCODE: $000002B8 VOL: 0
;PCODE: $000002B9 VOL: 0
;PCODE: $000002BA VOL: 0
;PCODE: $000002BB VOL: 0
;PCODE: $000002BC VOL: 0
;PCODE: $000002BD VOL: 0
;PCODE: $000002BE VOL: 0
;PCODE: $000002BF VOL: 0
;                        else p += ((xc++ - yc--)<<2) + 10;
;PCODE: $000002C0 VOL: 0
;PCODE: $000002C1 VOL: 0
;PCODE: $000002C2 VOL: 0
;PCODE: $000002C3 VOL: 0
;PCODE: $000002C4 VOL: 0
;PCODE: $000002C5 VOL: 0
;PCODE: $000002C6 VOL: 0
;PCODE: $000002C7 VOL: 0
;PCODE: $000002C8 VOL: 0
;PCODE: $000002C9 VOL: 0
;PCODE: $000002CA VOL: 0
;PCODE: $000002CB VOL: 0
;PCODE: $000002CC VOL: 0
;PCODE: $000002CD VOL: 0
;PCODE: $000002CE VOL: 0
;                }
;PCODE: $000002CF VOL: 0
;PCODE: $000002D0 VOL: 0
;PCODE: $000002D1 VOL: 0
;        }
;PCODE: $000002D2 VOL: 0
;PCODE: $000002D3 VOL: 0
;PCODE: $000002D4 VOL: 0
;PCODE: $000002D5 VOL: 0
;
;void LcdBatt(int x1, int y1, int x2, int y2, unsigned char persent)	//рисуем батарейку с заполнением в %
;        {
;PCODE: $000002D6 VOL: 0
;PCODE: $000002D7 VOL: 0
;        unsigned char horizon_line,horizon_line2,i;
;        if(persent>100)return;
;PCODE: $000002D8 VOL: 0
;	x1 -> Y+11
;	y1 -> Y+9
;	x2 -> Y+7
;	y2 -> Y+5
;	persent -> Y+4
;	horizon_line -> R17
;	horizon_line2 -> R16
;	i -> R19
;PCODE: $000002D9 VOL: 0
;PCODE: $000002DA VOL: 0
;PCODE: $000002DB VOL: 0
;PCODE: $000002DC VOL: 0
;PCODE: $000002DD VOL: 0
;PCODE: $000002DE VOL: 0
;        LcdLine(x1,y2,x2,y2,1);  //down
;PCODE: $000002DF VOL: 0
;PCODE: $000002E0 VOL: 0
;PCODE: $000002E1 VOL: 0
;PCODE: $000002E2 VOL: 0
;PCODE: $000002E3 VOL: 0
;PCODE: $000002E4 VOL: 0
;PCODE: $000002E5 VOL: 0
;PCODE: $000002E6 VOL: 0
;PCODE: $000002E7 VOL: 0
;PCODE: $000002E8 VOL: 0
;PCODE: $000002E9 VOL: 0
;PCODE: $000002EA VOL: 0
;        LcdLine(x2,y1,x2,y2,1);  //right
;PCODE: $000002EB VOL: 0
;PCODE: $000002EC VOL: 0
;PCODE: $000002ED VOL: 0
;PCODE: $000002EE VOL: 0
;PCODE: $000002EF VOL: 0
;PCODE: $000002F0 VOL: 0
;PCODE: $000002F1 VOL: 0
;PCODE: $000002F2 VOL: 0
;PCODE: $000002F3 VOL: 0
;PCODE: $000002F4 VOL: 0
;PCODE: $000002F5 VOL: 0
;	LcdLine(x1,y1,x1,y2,1);  //left
;PCODE: $000002F6 VOL: 0
;PCODE: $000002F7 VOL: 0
;PCODE: $000002F8 VOL: 0
;PCODE: $000002F9 VOL: 0
;PCODE: $000002FA VOL: 0
;PCODE: $000002FB VOL: 0
;PCODE: $000002FC VOL: 0
;PCODE: $000002FD VOL: 0
;PCODE: $000002FE VOL: 0
;PCODE: $000002FF VOL: 0
;PCODE: $00000300 VOL: 0
;	LcdLine(x1,y1,x2,y1,1);  //up
;PCODE: $00000301 VOL: 0
;PCODE: $00000302 VOL: 0
;PCODE: $00000303 VOL: 0
;PCODE: $00000304 VOL: 0
;PCODE: $00000305 VOL: 0
;PCODE: $00000306 VOL: 0
;PCODE: $00000307 VOL: 0
;PCODE: $00000308 VOL: 0
;PCODE: $00000309 VOL: 0
;PCODE: $0000030A VOL: 0
;PCODE: $0000030B VOL: 0
;	LcdLine(x1+7,y1-1,x2-7,y1-1,1);
;PCODE: $0000030C VOL: 0
;PCODE: $0000030D VOL: 0
;PCODE: $0000030E VOL: 0
;PCODE: $0000030F VOL: 0
;PCODE: $00000310 VOL: 0
;PCODE: $00000311 VOL: 0
;PCODE: $00000312 VOL: 0
;PCODE: $00000313 VOL: 0
;PCODE: $00000314 VOL: 0
;PCODE: $00000315 VOL: 0
;PCODE: $00000316 VOL: 0
;PCODE: $00000317 VOL: 0
;PCODE: $00000318 VOL: 0
;PCODE: $00000319 VOL: 0
;PCODE: $0000031A VOL: 0
;	LcdLine(x1+7,y1-2,x2-7,y1-2,1);
;PCODE: $0000031B VOL: 0
;PCODE: $0000031C VOL: 0
;PCODE: $0000031D VOL: 0
;PCODE: $0000031E VOL: 0
;PCODE: $0000031F VOL: 0
;PCODE: $00000320 VOL: 0
;PCODE: $00000321 VOL: 0
;PCODE: $00000322 VOL: 0
;PCODE: $00000323 VOL: 0
;PCODE: $00000324 VOL: 0
;PCODE: $00000325 VOL: 0
;PCODE: $00000326 VOL: 0
;PCODE: $00000327 VOL: 0
;PCODE: $00000328 VOL: 0
;PCODE: $00000329 VOL: 0
;
;        horizon_line=persent*(y2-y1-3)/100;
;PCODE: $0000032A VOL: 0
;PCODE: $0000032B VOL: 0
;PCODE: $0000032C VOL: 0
;PCODE: $0000032D VOL: 0
;PCODE: $0000032E VOL: 0
;PCODE: $0000032F VOL: 0
;PCODE: $00000330 VOL: 0
;PCODE: $00000331 VOL: 0
;PCODE: $00000332 VOL: 0
;PCODE: $00000333 VOL: 0
;PCODE: $00000334 VOL: 0
;        for(i=0;i<horizon_line;i++) LcdLine(x1+2,y2-2-i,x2-2,y2-2-i,1);
;PCODE: $00000335 VOL: 0
;PCODE: $00000336 VOL: 0
;PCODE: $00000337 VOL: 0
;PCODE: $00000338 VOL: 0
;PCODE: $00000339 VOL: 0
;PCODE: $0000033A VOL: 0
;PCODE: $0000033B VOL: 0
;PCODE: $0000033C VOL: 0
;PCODE: $0000033D VOL: 0
;PCODE: $0000033E VOL: 0
;PCODE: $0000033F VOL: 0
;PCODE: $00000340 VOL: 0
;PCODE: $00000341 VOL: 0
;PCODE: $00000342 VOL: 0
;PCODE: $00000343 VOL: 0
;PCODE: $00000344 VOL: 0
;PCODE: $00000345 VOL: 0
;PCODE: $00000346 VOL: 0
;PCODE: $00000347 VOL: 0
;PCODE: $00000348 VOL: 0
;PCODE: $00000349 VOL: 0
;PCODE: $0000034A VOL: 0
;PCODE: $0000034B VOL: 0
;PCODE: $0000034C VOL: 0
;PCODE: $0000034D VOL: 0
;PCODE: $0000034E VOL: 0
;PCODE: $0000034F VOL: 0
;PCODE: $00000350 VOL: 0
;PCODE: $00000351 VOL: 0
;PCODE: $00000352 VOL: 0
;PCODE: $00000353 VOL: 0
;PCODE: $00000354 VOL: 0
;PCODE: $00000355 VOL: 0
;PCODE: $00000356 VOL: 0
;PCODE: $00000357 VOL: 0
;PCODE: $00000358 VOL: 0
;PCODE: $00000359 VOL: 0
;PCODE: $0000035A VOL: 0
;PCODE: $0000035B VOL: 0
;PCODE: $0000035C VOL: 0
;        for(i=horizon_line2;i>horizon_line;i--) LcdLine(x1+2,y2-2-i,x2-2,y2-2-i,0);
;PCODE: $0000035D VOL: 0
;PCODE: $0000035E VOL: 0
;PCODE: $0000035F VOL: 0
;PCODE: $00000360 VOL: 0
;PCODE: $00000361 VOL: 0
;PCODE: $00000362 VOL: 0
;PCODE: $00000363 VOL: 0
;PCODE: $00000364 VOL: 0
;PCODE: $00000365 VOL: 0
;PCODE: $00000366 VOL: 0
;PCODE: $00000367 VOL: 0
;PCODE: $00000368 VOL: 0
;PCODE: $00000369 VOL: 0
;PCODE: $0000036A VOL: 0
;PCODE: $0000036B VOL: 0
;PCODE: $0000036C VOL: 0
;PCODE: $0000036D VOL: 0
;PCODE: $0000036E VOL: 0
;PCODE: $0000036F VOL: 0
;PCODE: $00000370 VOL: 0
;PCODE: $00000371 VOL: 0
;PCODE: $00000372 VOL: 0
;PCODE: $00000373 VOL: 0
;PCODE: $00000374 VOL: 0
;PCODE: $00000375 VOL: 0
;PCODE: $00000376 VOL: 0
;PCODE: $00000377 VOL: 0
;PCODE: $00000378 VOL: 0
;PCODE: $00000379 VOL: 0
;PCODE: $0000037A VOL: 0
;PCODE: $0000037B VOL: 0
;PCODE: $0000037C VOL: 0
;PCODE: $0000037D VOL: 0
;PCODE: $0000037E VOL: 0
;PCODE: $0000037F VOL: 0
;PCODE: $00000380 VOL: 0
;PCODE: $00000381 VOL: 0
;PCODE: $00000382 VOL: 0
;PCODE: $00000383 VOL: 0
;
;void LcdBar(int x1, int y1, int x2, int y2, unsigned char persent)	//рисуем прогресс-бар
;        {
;PCODE: $00000384 VOL: 0
;PCODE: $00000385 VOL: 0
;        unsigned char line;
;        if(persent>100)return;
;PCODE: $00000386 VOL: 0
;	x1 -> Y+8
;	y1 -> Y+6
;	x2 -> Y+4
;	y2 -> Y+2
;	persent -> Y+1
;	line -> R17
;PCODE: $00000387 VOL: 0
;PCODE: $00000388 VOL: 0
;PCODE: $00000389 VOL: 0
;PCODE: $0000038A VOL: 0
;PCODE: $0000038B VOL: 0
;PCODE: $0000038C VOL: 0
;PCODE: $0000038D VOL: 0
;        LcdLine(x1+2,y2,x2-2,y2,1);  //down
;PCODE: $0000038E VOL: 0
;PCODE: $0000038F VOL: 0
;PCODE: $00000390 VOL: 0
;PCODE: $00000391 VOL: 0
;PCODE: $00000392 VOL: 0
;PCODE: $00000393 VOL: 0
;PCODE: $00000394 VOL: 0
;PCODE: $00000395 VOL: 0
;PCODE: $00000396 VOL: 0
;PCODE: $00000397 VOL: 0
;PCODE: $00000398 VOL: 0
;PCODE: $00000399 VOL: 0
;PCODE: $0000039A VOL: 0
;PCODE: $0000039B VOL: 0
;        LcdLine(x2-2,y1,x2-2,y2,1);  //right
;PCODE: $0000039C VOL: 0
;PCODE: $0000039D VOL: 0
;PCODE: $0000039E VOL: 0
;PCODE: $0000039F VOL: 0
;PCODE: $000003A0 VOL: 0
;PCODE: $000003A1 VOL: 0
;PCODE: $000003A2 VOL: 0
;PCODE: $000003A3 VOL: 0
;PCODE: $000003A4 VOL: 0
;PCODE: $000003A5 VOL: 0
;PCODE: $000003A6 VOL: 0
;PCODE: $000003A7 VOL: 0
;PCODE: $000003A8 VOL: 0
;	LcdLine(x1+2,y1,x1+2,y2,1);  //left
;PCODE: $000003A9 VOL: 0
;PCODE: $000003AA VOL: 0
;PCODE: $000003AB VOL: 0
;PCODE: $000003AC VOL: 0
;PCODE: $000003AD VOL: 0
;PCODE: $000003AE VOL: 0
;PCODE: $000003AF VOL: 0
;PCODE: $000003B0 VOL: 0
;PCODE: $000003B1 VOL: 0
;PCODE: $000003B2 VOL: 0
;PCODE: $000003B3 VOL: 0
;PCODE: $000003B4 VOL: 0
;PCODE: $000003B5 VOL: 0
;	LcdLine(x1+2,y1,x2-2,y1,1);  //up
;PCODE: $000003B6 VOL: 0
;PCODE: $000003B7 VOL: 0
;PCODE: $000003B8 VOL: 0
;PCODE: $000003B9 VOL: 0
;PCODE: $000003BA VOL: 0
;PCODE: $000003BB VOL: 0
;PCODE: $000003BC VOL: 0
;PCODE: $000003BD VOL: 0
;PCODE: $000003BE VOL: 0
;PCODE: $000003BF VOL: 0
;PCODE: $000003C0 VOL: 0
;PCODE: $000003C1 VOL: 0
;PCODE: $000003C2 VOL: 0
;
;        LcdLine(x2-1,y1+1,x2-1,y2-1,1);  //right
;PCODE: $000003C3 VOL: 0
;PCODE: $000003C4 VOL: 0
;PCODE: $000003C5 VOL: 0
;PCODE: $000003C6 VOL: 0
;PCODE: $000003C7 VOL: 0
;PCODE: $000003C8 VOL: 0
;PCODE: $000003C9 VOL: 0
;PCODE: $000003CA VOL: 0
;PCODE: $000003CB VOL: 0
;PCODE: $000003CC VOL: 0
;PCODE: $000003CD VOL: 0
;PCODE: $000003CE VOL: 0
;PCODE: $000003CF VOL: 0
;PCODE: $000003D0 VOL: 0
;PCODE: $000003D1 VOL: 0
;	LcdLine(x1+1,y1+1,x1+1,y2-1,1);  //left
;PCODE: $000003D2 VOL: 0
;PCODE: $000003D3 VOL: 0
;PCODE: $000003D4 VOL: 0
;PCODE: $000003D5 VOL: 0
;PCODE: $000003D6 VOL: 0
;PCODE: $000003D7 VOL: 0
;PCODE: $000003D8 VOL: 0
;PCODE: $000003D9 VOL: 0
;PCODE: $000003DA VOL: 0
;PCODE: $000003DB VOL: 0
;PCODE: $000003DC VOL: 0
;PCODE: $000003DD VOL: 0
;PCODE: $000003DE VOL: 0
;PCODE: $000003DF VOL: 0
;PCODE: $000003E0 VOL: 0
;
;        LcdLine(x2,y1+2,x2,y2-2,1);  //right
;PCODE: $000003E1 VOL: 0
;PCODE: $000003E2 VOL: 0
;PCODE: $000003E3 VOL: 0
;PCODE: $000003E4 VOL: 0
;PCODE: $000003E5 VOL: 0
;PCODE: $000003E6 VOL: 0
;PCODE: $000003E7 VOL: 0
;PCODE: $000003E8 VOL: 0
;PCODE: $000003E9 VOL: 0
;PCODE: $000003EA VOL: 0
;PCODE: $000003EB VOL: 0
;PCODE: $000003EC VOL: 0
;PCODE: $000003ED VOL: 0
;	LcdLine(x1,y1+2,x1,y2-2,1);  //left
;PCODE: $000003EE VOL: 0
;PCODE: $000003EF VOL: 0
;PCODE: $000003F0 VOL: 0
;PCODE: $000003F1 VOL: 0
;PCODE: $000003F2 VOL: 0
;PCODE: $000003F3 VOL: 0
;PCODE: $000003F4 VOL: 0
;PCODE: $000003F5 VOL: 0
;PCODE: $000003F6 VOL: 0
;PCODE: $000003F7 VOL: 0
;PCODE: $000003F8 VOL: 0
;PCODE: $000003F9 VOL: 0
;PCODE: $000003FA VOL: 0
;
;        line=persent*(x2-x1-7)/100-1;
;PCODE: $000003FB VOL: 0
;PCODE: $000003FC VOL: 0
;PCODE: $000003FD VOL: 0
;PCODE: $000003FE VOL: 0
;PCODE: $000003FF VOL: 0
;PCODE: $00000400 VOL: 0
;PCODE: $00000401 VOL: 0
;PCODE: $00000402 VOL: 0
;PCODE: $00000403 VOL: 0
;PCODE: $00000404 VOL: 0
;PCODE: $00000405 VOL: 0
;PCODE: $00000406 VOL: 0
;        LcdLine(x1+4,y1+2,x2-4,y2-2,0);
;PCODE: $00000407 VOL: 0
;PCODE: $00000408 VOL: 0
;PCODE: $00000409 VOL: 0
;PCODE: $0000040A VOL: 0
;PCODE: $0000040B VOL: 0
;PCODE: $0000040C VOL: 0
;PCODE: $0000040D VOL: 0
;PCODE: $0000040E VOL: 0
;PCODE: $0000040F VOL: 0
;PCODE: $00000410 VOL: 0
;PCODE: $00000411 VOL: 0
;PCODE: $00000412 VOL: 0
;PCODE: $00000413 VOL: 0
;PCODE: $00000414 VOL: 0
;PCODE: $00000415 VOL: 0
;        LcdLine(x1+4,y1+2,x1+4+line,y2-2,1);
;PCODE: $00000416 VOL: 0
;PCODE: $00000417 VOL: 0
;PCODE: $00000418 VOL: 0
;PCODE: $00000419 VOL: 0
;PCODE: $0000041A VOL: 0
;PCODE: $0000041B VOL: 0
;PCODE: $0000041C VOL: 0
;PCODE: $0000041D VOL: 0
;PCODE: $0000041E VOL: 0
;PCODE: $0000041F VOL: 0
;PCODE: $00000420 VOL: 0
;PCODE: $00000421 VOL: 0
;PCODE: $00000422 VOL: 0
;PCODE: $00000423 VOL: 0
;PCODE: $00000424 VOL: 0
;PCODE: $00000425 VOL: 0
;PCODE: $00000426 VOL: 0
;PCODE: $00000427 VOL: 0
;	}
;PCODE: $00000428 VOL: 0
;PCODE: $00000429 VOL: 0
;PCODE: $0000042A VOL: 0
;PCODE: $0000042B VOL: 0
;PCODE: $0000042C VOL: 0
;
;void LcdBarLine(unsigned char line, unsigned char persent)	//рисуем прошресс-бар
;        {
;PCODE: $0000042D VOL: 0
;PCODE: $0000042E VOL: 0
;        LcdBar(0, (line-1)*7+1, 83, (line-1)*7+5, persent);
;	line -> Y+1
;	persent -> Y+0
;PCODE: $0000042F VOL: 0
;PCODE: $00000430 VOL: 0
;PCODE: $00000431 VOL: 0
;PCODE: $00000432 VOL: 0
;PCODE: $00000433 VOL: 0
;PCODE: $00000434 VOL: 0
;PCODE: $00000435 VOL: 0
;PCODE: $00000436 VOL: 0
;PCODE: $00000437 VOL: 0
;PCODE: $00000438 VOL: 0
;PCODE: $00000439 VOL: 0
;PCODE: $0000043A VOL: 0
;PCODE: $0000043B VOL: 0
;PCODE: $0000043C VOL: 0
;PCODE: $0000043D VOL: 0
;PCODE: $0000043E VOL: 0
;PCODE: $0000043F VOL: 0
;PCODE: $00000440 VOL: 0
;PCODE: $00000441 VOL: 0
;PCODE: $00000442 VOL: 0
;PCODE: $00000443 VOL: 0
;        }
;PCODE: $00000444 VOL: 0
;PCODE: $00000445 VOL: 0
;PCODE: $00000446 VOL: 0
;
;void LcdGotoXYFont (unsigned char x, unsigned char y)   //Sets cursor location to xy location. Range: 1,1 .. 14,6
;        {
;PCODE: $00000447 VOL: 0
;PCODE: $00000448 VOL: 0
;        if (x <= 14 && y <= 6) LcdCacheIdx = ( (int)(y) - 1 ) * 84 + ( (int)(x) - 1 ) * 6;
;	x -> Y+1
;	y -> Y+0
;PCODE: $00000449 VOL: 0
;PCODE: $0000044A VOL: 0
;PCODE: $0000044B VOL: 0
;PCODE: $0000044C VOL: 0
;PCODE: $0000044D VOL: 0
;PCODE: $0000044E VOL: 0
;PCODE: $0000044F VOL: 0
;PCODE: $00000450 VOL: 0
;PCODE: $00000451 VOL: 0
;PCODE: $00000452 VOL: 0
;PCODE: $00000453 VOL: 0
;PCODE: $00000454 VOL: 0
;PCODE: $00000455 VOL: 0
;PCODE: $00000456 VOL: 0
;PCODE: $00000457 VOL: 0
;PCODE: $00000458 VOL: 0
;PCODE: $00000459 VOL: 0
;PCODE: $0000045A VOL: 0
;PCODE: $0000045B VOL: 0
;PCODE: $0000045C VOL: 0
;PCODE: $0000045D VOL: 0
;PCODE: $0000045E VOL: 0
;PCODE: $0000045F VOL: 0
;        }
;PCODE: $00000460 VOL: 0
;PCODE: $00000461 VOL: 0
;PCODE: $00000462 VOL: 0
;PCODE: $00000463 VOL: 0
;
;void clean_lcd_buf (void)	//очистка текстового буфера
;	{
;PCODE: $00000464 VOL: 0
;PCODE: $00000465 VOL: 0
;	char i;
;
;	for (i=0; i<14; i++) lcd_buf[i] = 0;
;PCODE: $00000466 VOL: 0
;	i -> R17
;PCODE: $00000467 VOL: 0
;PCODE: $00000468 VOL: 0
;PCODE: $00000469 VOL: 0
;PCODE: $0000046A VOL: 0
;PCODE: $0000046B VOL: 0
;PCODE: $0000046C VOL: 0
;PCODE: $0000046D VOL: 0
;PCODE: $0000046E VOL: 0
;PCODE: $0000046F VOL: 0
;PCODE: $00000470 VOL: 0
;PCODE: $00000471 VOL: 0
;PCODE: $00000472 VOL: 0
;PCODE: $00000473 VOL: 0
;PCODE: $00000474 VOL: 0
;PCODE: $00000475 VOL: 0
;PCODE: $00000476 VOL: 0
;PCODE: $00000477 VOL: 0
;PCODE: $00000478 VOL: 0
;PCODE: $00000479 VOL: 0
;PCODE: $0000047A VOL: 0
;PCODE: $0000047B VOL: 0
;PCODE: $0000047C VOL: 0
;
;void LcdChr (int ch)	//Displays a character at current cursor location and increment cursor location
; 	{
;PCODE: $0000047D VOL: 0
;PCODE: $0000047E VOL: 0
;     	unsigned char i;
;
;        for ( i = 0; i < 5; i++ ) LcdCache[LcdCacheIdx++] = table[(ch*5+i)];	//выделяем байт-столбик из символа и грузим в массив - 5 раз
;PCODE: $0000047F VOL: 0
;	ch -> Y+1
;	i -> R17
;PCODE: $00000480 VOL: 0
;PCODE: $00000481 VOL: 0
;PCODE: $00000482 VOL: 0
;PCODE: $00000483 VOL: 0
;PCODE: $00000484 VOL: 0
;PCODE: $00000485 VOL: 0
;PCODE: $00000486 VOL: 0
;PCODE: $00000487 VOL: 0
;PCODE: $00000488 VOL: 0
;PCODE: $00000489 VOL: 0
;PCODE: $0000048A VOL: 0
;PCODE: $0000048B VOL: 0
;PCODE: $0000048C VOL: 0
;PCODE: $0000048D VOL: 0
;PCODE: $0000048E VOL: 0
;PCODE: $0000048F VOL: 0
;PCODE: $00000490 VOL: 0
;PCODE: $00000491 VOL: 0
;PCODE: $00000492 VOL: 0
;PCODE: $00000493 VOL: 0
;PCODE: $00000494 VOL: 0
;PCODE: $00000495 VOL: 0
;PCODE: $00000496 VOL: 0
;PCODE: $00000497 VOL: 0
;PCODE: $00000498 VOL: 0
;PCODE: $00000499 VOL: 0
;PCODE: $0000049A VOL: 0
;PCODE: $0000049B VOL: 0
;PCODE: $0000049C VOL: 0
;PCODE: $0000049D VOL: 0
;PCODE: $0000049E VOL: 0
;PCODE: $0000049F VOL: 0
;PCODE: $000004A0 VOL: 0
;PCODE: $000004A1 VOL: 0
;PCODE: $000004A2 VOL: 0
;PCODE: $000004A3 VOL: 0
;PCODE: $000004A4 VOL: 0
;PCODE: $000004A5 VOL: 0
; 	}
;PCODE: $000004A6 VOL: 0
;PCODE: $000004A7 VOL: 0
;PCODE: $000004A8 VOL: 0
;PCODE: $000004A9 VOL: 0
;PCODE: $000004AA VOL: 0
;
;void LcdChrInv (int ch)	//Displays a character at current cursor location and increment cursor location
; 	{
;PCODE: $000004AB VOL: 0
;PCODE: $000004AC VOL: 0
;     	unsigned char i;
;
;        for ( i = 0; i < 5; i++ ) LcdCache[LcdCacheIdx++] = ~(table[(ch*5+i)]);	//выделяем байт-столбик из символа и грузим в массив - 5 раз
;PCODE: $000004AD VOL: 0
;	ch -> Y+1
;	i -> R17
;PCODE: $000004AE VOL: 0
;PCODE: $000004AF VOL: 0
;PCODE: $000004B0 VOL: 0
;PCODE: $000004B1 VOL: 0
;PCODE: $000004B2 VOL: 0
;PCODE: $000004B3 VOL: 0
;PCODE: $000004B4 VOL: 0
;PCODE: $000004B5 VOL: 0
;PCODE: $000004B6 VOL: 0
;PCODE: $000004B7 VOL: 0
;PCODE: $000004B8 VOL: 0
;PCODE: $000004B9 VOL: 0
;PCODE: $000004BA VOL: 0
;PCODE: $000004BB VOL: 0
;PCODE: $000004BC VOL: 0
;PCODE: $000004BD VOL: 0
;PCODE: $000004BE VOL: 0
;PCODE: $000004BF VOL: 0
;PCODE: $000004C0 VOL: 0
;PCODE: $000004C1 VOL: 0
;PCODE: $000004C2 VOL: 0
;PCODE: $000004C3 VOL: 0
;PCODE: $000004C4 VOL: 0
;PCODE: $000004C5 VOL: 0
;PCODE: $000004C6 VOL: 0
;PCODE: $000004C7 VOL: 0
;PCODE: $000004C8 VOL: 0
;PCODE: $000004C9 VOL: 0
;PCODE: $000004CA VOL: 0
;PCODE: $000004CB VOL: 0
;PCODE: $000004CC VOL: 0
;PCODE: $000004CD VOL: 0
;PCODE: $000004CE VOL: 0
;PCODE: $000004CF VOL: 0
;PCODE: $000004D0 VOL: 0
;PCODE: $000004D1 VOL: 0
;PCODE: $000004D2 VOL: 0
;PCODE: $000004D3 VOL: 0
;PCODE: $000004D4 VOL: 0
; 	}
;PCODE: $000004D5 VOL: 0
;PCODE: $000004D6 VOL: 0
;PCODE: $000004D7 VOL: 0
;PCODE: $000004D8 VOL: 0
;PCODE: $000004D9 VOL: 0
;
;void LcdString (unsigned char x, unsigned char y)	//Displays a string at current cursor location
;	{
;PCODE: $000004DA VOL: 0
;PCODE: $000004DB VOL: 0
;	unsigned char i;
;
;	if (x > 14 || y > 6) return;
;PCODE: $000004DC VOL: 0
;	x -> Y+2
;	y -> Y+1
;	i -> R17
;PCODE: $000004DD VOL: 0
;PCODE: $000004DE VOL: 0
;PCODE: $000004DF VOL: 0
;PCODE: $000004E0 VOL: 0
;PCODE: $000004E1 VOL: 0
;PCODE: $000004E2 VOL: 0
;PCODE: $000004E3 VOL: 0
;PCODE: $000004E4 VOL: 0
;PCODE: $000004E5 VOL: 0
;PCODE: $000004E6 VOL: 0
;PCODE: $000004E7 VOL: 0
;PCODE: $000004E8 VOL: 0
;	LcdGotoXYFont (x, y);
;PCODE: $000004E9 VOL: 0
;PCODE: $000004EA VOL: 0
;PCODE: $000004EB VOL: 0
;PCODE: $000004EC VOL: 0
;PCODE: $000004ED VOL: 0
;PCODE: $000004EE VOL: 0
;	for ( i = 0; i < 15-x; i++ ) if (lcd_buf[i]) LcdChr (lcd_buf[i]);
;PCODE: $000004EF VOL: 0
;PCODE: $000004F0 VOL: 0
;PCODE: $000004F1 VOL: 0
;PCODE: $000004F2 VOL: 0
;PCODE: $000004F3 VOL: 0
;PCODE: $000004F4 VOL: 0
;PCODE: $000004F5 VOL: 0
;PCODE: $000004F6 VOL: 0
;PCODE: $000004F7 VOL: 0
;PCODE: $000004F8 VOL: 0
;PCODE: $000004F9 VOL: 0
;PCODE: $000004FA VOL: 0
;PCODE: $000004FB VOL: 0
;PCODE: $000004FC VOL: 0
;PCODE: $000004FD VOL: 0
;PCODE: $000004FE VOL: 0
;PCODE: $000004FF VOL: 0
;PCODE: $00000500 VOL: 0
;PCODE: $00000501 VOL: 0
;PCODE: $00000502 VOL: 0
;PCODE: $00000503 VOL: 0
;PCODE: $00000504 VOL: 0
;PCODE: $00000505 VOL: 0
;PCODE: $00000506 VOL: 0
;	clean_lcd_buf();
;PCODE: $00000507 VOL: 0
;PCODE: $00000508 VOL: 0
;PCODE: $00000509 VOL: 0
;PCODE: $0000050A VOL: 0
;PCODE: $0000050B VOL: 0
;PCODE: $0000050C VOL: 0
;PCODE: $0000050D VOL: 0
;	}
;PCODE: $0000050E VOL: 0
;PCODE: $0000050F VOL: 0
;PCODE: $00000510 VOL: 0
;PCODE: $00000511 VOL: 0
;PCODE: $00000512 VOL: 0
;
;void LcdStringInv (unsigned char x, unsigned char y)	//Displays a string at current cursor location
;	{
;PCODE: $00000513 VOL: 0
;PCODE: $00000514 VOL: 0
;	unsigned char i;
;
;	if (x > 14 || y > 6) return;
;PCODE: $00000515 VOL: 0
;	x -> Y+2
;	y -> Y+1
;	i -> R17
;PCODE: $00000516 VOL: 0
;PCODE: $00000517 VOL: 0
;PCODE: $00000518 VOL: 0
;PCODE: $00000519 VOL: 0
;PCODE: $0000051A VOL: 0
;PCODE: $0000051B VOL: 0
;PCODE: $0000051C VOL: 0
;PCODE: $0000051D VOL: 0
;PCODE: $0000051E VOL: 0
;PCODE: $0000051F VOL: 0
;PCODE: $00000520 VOL: 0
;PCODE: $00000521 VOL: 0
;	LcdGotoXYFont (x, y);
;PCODE: $00000522 VOL: 0
;PCODE: $00000523 VOL: 0
;PCODE: $00000524 VOL: 0
;PCODE: $00000525 VOL: 0
;PCODE: $00000526 VOL: 0
;PCODE: $00000527 VOL: 0
;	for ( i = 0; i < 15-x; i++ ) if (lcd_buf[i]) LcdChrInv (lcd_buf[i]);
;PCODE: $00000528 VOL: 0
;PCODE: $00000529 VOL: 0
;PCODE: $0000052A VOL: 0
;PCODE: $0000052B VOL: 0
;PCODE: $0000052C VOL: 0
;PCODE: $0000052D VOL: 0
;PCODE: $0000052E VOL: 0
;PCODE: $0000052F VOL: 0
;PCODE: $00000530 VOL: 0
;PCODE: $00000531 VOL: 0
;PCODE: $00000532 VOL: 0
;PCODE: $00000533 VOL: 0
;PCODE: $00000534 VOL: 0
;PCODE: $00000535 VOL: 0
;PCODE: $00000536 VOL: 0
;PCODE: $00000537 VOL: 0
;PCODE: $00000538 VOL: 0
;PCODE: $00000539 VOL: 0
;PCODE: $0000053A VOL: 0
;PCODE: $0000053B VOL: 0
;PCODE: $0000053C VOL: 0
;PCODE: $0000053D VOL: 0
;PCODE: $0000053E VOL: 0
;PCODE: $0000053F VOL: 0
;	clean_lcd_buf();
;PCODE: $00000540 VOL: 0
;PCODE: $00000541 VOL: 0
;PCODE: $00000542 VOL: 0
;PCODE: $00000543 VOL: 0
;PCODE: $00000544 VOL: 0
;PCODE: $00000545 VOL: 0
;PCODE: $00000546 VOL: 0
;	}
;PCODE: $00000547 VOL: 0
;PCODE: $00000548 VOL: 0
;PCODE: $00000549 VOL: 0
;PCODE: $0000054A VOL: 0
;PCODE: $0000054B VOL: 0
;
;void LcdChrBold (int ch)	//Displays a bold character at current cursor location and increment cursor location
; 	{
;PCODE: $0000054C VOL: 0
;PCODE: $0000054D VOL: 0
;     	unsigned char i;
;     	unsigned char a = 0, b = 0, c = 0;
;
;     	for ( i = 0; i < 5; i++ )
;PCODE: $0000054E VOL: 0
;	ch -> Y+4
;	i -> R17
;	a -> R16
;	b -> R19
;	c -> R18
;PCODE: $0000054F VOL: 0
;PCODE: $00000550 VOL: 0
;PCODE: $00000551 VOL: 0
;PCODE: $00000552 VOL: 0
;PCODE: $00000553 VOL: 0
;PCODE: $00000554 VOL: 0
;PCODE: $00000555 VOL: 0
;PCODE: $00000556 VOL: 0
;PCODE: $00000557 VOL: 0
;PCODE: $00000558 VOL: 0
;PCODE: $00000559 VOL: 0
;PCODE: $0000055A VOL: 0
;PCODE: $0000055B VOL: 0
;PCODE: $0000055C VOL: 0
;PCODE: $0000055D VOL: 0
;     	        {
;     	        c = table[(ch*5+i)];		//выделяем столбец из символа
;PCODE: $0000055E VOL: 0
;PCODE: $0000055F VOL: 0
;PCODE: $00000560 VOL: 0
;PCODE: $00000561 VOL: 0
;PCODE: $00000562 VOL: 0
;PCODE: $00000563 VOL: 0
;PCODE: $00000564 VOL: 0
;PCODE: $00000565 VOL: 0
;PCODE: $00000566 VOL: 0
;
;     	        b =  (c & 0x01) * 3;            //"растягиваем" столбец на два байта
;PCODE: $00000567 VOL: 0
;PCODE: $00000568 VOL: 0
;PCODE: $00000569 VOL: 0
;PCODE: $0000056A VOL: 0
;PCODE: $0000056B VOL: 0
;              	b |= (c & 0x02) * 6;
;PCODE: $0000056C VOL: 0
;PCODE: $0000056D VOL: 0
;PCODE: $0000056E VOL: 0
;PCODE: $0000056F VOL: 0
;PCODE: $00000570 VOL: 0
;PCODE: $00000571 VOL: 0
;              	b |= (c & 0x04) * 12;
;PCODE: $00000572 VOL: 0
;PCODE: $00000573 VOL: 0
;PCODE: $00000574 VOL: 0
;PCODE: $00000575 VOL: 0
;PCODE: $00000576 VOL: 0
;PCODE: $00000577 VOL: 0
;              	b |= (c & 0x08) * 24;
;PCODE: $00000578 VOL: 0
;PCODE: $00000579 VOL: 0
;PCODE: $0000057A VOL: 0
;PCODE: $0000057B VOL: 0
;PCODE: $0000057C VOL: 0
;PCODE: $0000057D VOL: 0
;
;              	c >>= 4;
;PCODE: $0000057E VOL: 0
;              	a =  (c & 0x01) * 3;
;PCODE: $0000057F VOL: 0
;PCODE: $00000580 VOL: 0
;PCODE: $00000581 VOL: 0
;PCODE: $00000582 VOL: 0
;PCODE: $00000583 VOL: 0
;              	a |= (c & 0x02) * 6;
;PCODE: $00000584 VOL: 0
;PCODE: $00000585 VOL: 0
;PCODE: $00000586 VOL: 0
;PCODE: $00000587 VOL: 0
;PCODE: $00000588 VOL: 0
;PCODE: $00000589 VOL: 0
;              	a |= (c & 0x04) * 12;
;PCODE: $0000058A VOL: 0
;PCODE: $0000058B VOL: 0
;PCODE: $0000058C VOL: 0
;PCODE: $0000058D VOL: 0
;PCODE: $0000058E VOL: 0
;PCODE: $0000058F VOL: 0
;              	a |= (c & 0x08) * 24;
;PCODE: $00000590 VOL: 0
;PCODE: $00000591 VOL: 0
;PCODE: $00000592 VOL: 0
;PCODE: $00000593 VOL: 0
;PCODE: $00000594 VOL: 0
;PCODE: $00000595 VOL: 0
;
;     	        LcdCache[LcdCacheIdx] = b;	//копируем байты в экранный буфер
;PCODE: $00000596 VOL: 0
;PCODE: $00000597 VOL: 0
;PCODE: $00000598 VOL: 0
;     	        LcdCache[LcdCacheIdx+1] = b;    //дублируем для получения жирного шрифта
;PCODE: $00000599 VOL: 0
;PCODE: $0000059A VOL: 0
;PCODE: $0000059B VOL: 0
;PCODE: $0000059C VOL: 0
;     	        LcdCache[LcdCacheIdx+84] = a;
;PCODE: $0000059D VOL: 0
;PCODE: $0000059E VOL: 0
;PCODE: $0000059F VOL: 0
;PCODE: $000005A0 VOL: 0
;     	        LcdCache[LcdCacheIdx+85] = a;
;PCODE: $000005A1 VOL: 0
;PCODE: $000005A2 VOL: 0
;PCODE: $000005A3 VOL: 0
;PCODE: $000005A4 VOL: 0
;     	        LcdCacheIdx = LcdCacheIdx+2;
;PCODE: $000005A5 VOL: 0
;PCODE: $000005A6 VOL: 0
;PCODE: $000005A7 VOL: 0
;     	        }
;PCODE: $000005A8 VOL: 0
;PCODE: $000005A9 VOL: 0
;PCODE: $000005AA VOL: 0
;PCODE: $000005AB VOL: 0
;PCODE: $000005AC VOL: 0
;
;     	LcdCache[LcdCacheIdx++] = 0x00;	//для пробела между символами
;PCODE: $000005AD VOL: 0
;PCODE: $000005AE VOL: 0
;PCODE: $000005AF VOL: 0
;PCODE: $000005B0 VOL: 0
;PCODE: $000005B1 VOL: 0
;PCODE: $000005B2 VOL: 0
;PCODE: $000005B3 VOL: 0
;     	LcdCache[LcdCacheIdx++] = 0x00;
;PCODE: $000005B4 VOL: 0
;PCODE: $000005B5 VOL: 0
;PCODE: $000005B6 VOL: 0
;PCODE: $000005B7 VOL: 0
;PCODE: $000005B8 VOL: 0
;PCODE: $000005B9 VOL: 0
;PCODE: $000005BA VOL: 0
; 	}
;PCODE: $000005BB VOL: 0
;PCODE: $000005BC VOL: 0
;PCODE: $000005BD VOL: 0
;PCODE: $000005BE VOL: 0
;
;void LcdStringBold (unsigned char x, unsigned char y)	//Displays a string at current cursor location
;	{
;PCODE: $000005BF VOL: 0
;PCODE: $000005C0 VOL: 0
;	unsigned char i;
;
;	if (x > 13 || y > 5) return;
;PCODE: $000005C1 VOL: 0
;	x -> Y+2
;	y -> Y+1
;	i -> R17
;PCODE: $000005C2 VOL: 0
;PCODE: $000005C3 VOL: 0
;PCODE: $000005C4 VOL: 0
;PCODE: $000005C5 VOL: 0
;PCODE: $000005C6 VOL: 0
;PCODE: $000005C7 VOL: 0
;PCODE: $000005C8 VOL: 0
;PCODE: $000005C9 VOL: 0
;PCODE: $000005CA VOL: 0
;PCODE: $000005CB VOL: 0
;PCODE: $000005CC VOL: 0
;PCODE: $000005CD VOL: 0
;	LcdGotoXYFont (x, y);
;PCODE: $000005CE VOL: 0
;PCODE: $000005CF VOL: 0
;PCODE: $000005D0 VOL: 0
;PCODE: $000005D1 VOL: 0
;PCODE: $000005D2 VOL: 0
;PCODE: $000005D3 VOL: 0
;	for ( i = 0; i < 14-x; i++ ) if (lcd_buf[i]) LcdChrBold (lcd_buf[i]);
;PCODE: $000005D4 VOL: 0
;PCODE: $000005D5 VOL: 0
;PCODE: $000005D6 VOL: 0
;PCODE: $000005D7 VOL: 0
;PCODE: $000005D8 VOL: 0
;PCODE: $000005D9 VOL: 0
;PCODE: $000005DA VOL: 0
;PCODE: $000005DB VOL: 0
;PCODE: $000005DC VOL: 0
;PCODE: $000005DD VOL: 0
;PCODE: $000005DE VOL: 0
;PCODE: $000005DF VOL: 0
;PCODE: $000005E0 VOL: 0
;PCODE: $000005E1 VOL: 0
;PCODE: $000005E2 VOL: 0
;PCODE: $000005E3 VOL: 0
;PCODE: $000005E4 VOL: 0
;PCODE: $000005E5 VOL: 0
;PCODE: $000005E6 VOL: 0
;PCODE: $000005E7 VOL: 0
;PCODE: $000005E8 VOL: 0
;PCODE: $000005E9 VOL: 0
;PCODE: $000005EA VOL: 0
;PCODE: $000005EB VOL: 0
;	clean_lcd_buf();
;PCODE: $000005EC VOL: 0
;PCODE: $000005ED VOL: 0
;PCODE: $000005EE VOL: 0
;PCODE: $000005EF VOL: 0
;PCODE: $000005F0 VOL: 0
;PCODE: $000005F1 VOL: 0
;PCODE: $000005F2 VOL: 0
;	}
;PCODE: $000005F3 VOL: 0
;PCODE: $000005F4 VOL: 0
;PCODE: $000005F5 VOL: 0
;PCODE: $000005F6 VOL: 0
;PCODE: $000005F7 VOL: 0
;
;void LcdChrBig (int ch)	//Displays a character at current cursor location and increment cursor location
; 	{
;PCODE: $000005F8 VOL: 0
;PCODE: $000005F9 VOL: 0
;     	unsigned char i;
;     	unsigned char a = 0, b = 0, c = 0;
;
;     	for ( i = 0; i < 5; i++ )
;PCODE: $000005FA VOL: 0
;	ch -> Y+4
;	i -> R17
;	a -> R16
;	b -> R19
;	c -> R18
;PCODE: $000005FB VOL: 0
;PCODE: $000005FC VOL: 0
;PCODE: $000005FD VOL: 0
;PCODE: $000005FE VOL: 0
;PCODE: $000005FF VOL: 0
;PCODE: $00000600 VOL: 0
;PCODE: $00000601 VOL: 0
;PCODE: $00000602 VOL: 0
;PCODE: $00000603 VOL: 0
;PCODE: $00000604 VOL: 0
;PCODE: $00000605 VOL: 0
;PCODE: $00000606 VOL: 0
;PCODE: $00000607 VOL: 0
;PCODE: $00000608 VOL: 0
;PCODE: $00000609 VOL: 0
;     	        {
;     	        c = table[(ch*5+i)];		//выделяем столбец из символа
;PCODE: $0000060A VOL: 0
;PCODE: $0000060B VOL: 0
;PCODE: $0000060C VOL: 0
;PCODE: $0000060D VOL: 0
;PCODE: $0000060E VOL: 0
;PCODE: $0000060F VOL: 0
;PCODE: $00000610 VOL: 0
;PCODE: $00000611 VOL: 0
;PCODE: $00000612 VOL: 0
;
;     	        b =  (c & 0x01) * 3;            //"растягиваем" столбец на два байта
;PCODE: $00000613 VOL: 0
;PCODE: $00000614 VOL: 0
;PCODE: $00000615 VOL: 0
;PCODE: $00000616 VOL: 0
;PCODE: $00000617 VOL: 0
;              	b |= (c & 0x02) * 6;
;PCODE: $00000618 VOL: 0
;PCODE: $00000619 VOL: 0
;PCODE: $0000061A VOL: 0
;PCODE: $0000061B VOL: 0
;PCODE: $0000061C VOL: 0
;PCODE: $0000061D VOL: 0
;              	b |= (c & 0x04) * 12;
;PCODE: $0000061E VOL: 0
;PCODE: $0000061F VOL: 0
;PCODE: $00000620 VOL: 0
;PCODE: $00000621 VOL: 0
;PCODE: $00000622 VOL: 0
;PCODE: $00000623 VOL: 0
;              	b |= (c & 0x08) * 24;
;PCODE: $00000624 VOL: 0
;PCODE: $00000625 VOL: 0
;PCODE: $00000626 VOL: 0
;PCODE: $00000627 VOL: 0
;PCODE: $00000628 VOL: 0
;PCODE: $00000629 VOL: 0
;
;              	c >>= 4;
;PCODE: $0000062A VOL: 0
;              	a =  (c & 0x01) * 3;
;PCODE: $0000062B VOL: 0
;PCODE: $0000062C VOL: 0
;PCODE: $0000062D VOL: 0
;PCODE: $0000062E VOL: 0
;PCODE: $0000062F VOL: 0
;              	a |= (c & 0x02) * 6;
;PCODE: $00000630 VOL: 0
;PCODE: $00000631 VOL: 0
;PCODE: $00000632 VOL: 0
;PCODE: $00000633 VOL: 0
;PCODE: $00000634 VOL: 0
;PCODE: $00000635 VOL: 0
;              	a |= (c & 0x04) * 12;
;PCODE: $00000636 VOL: 0
;PCODE: $00000637 VOL: 0
;PCODE: $00000638 VOL: 0
;PCODE: $00000639 VOL: 0
;PCODE: $0000063A VOL: 0
;PCODE: $0000063B VOL: 0
;              	a |= (c & 0x08) * 24;
;PCODE: $0000063C VOL: 0
;PCODE: $0000063D VOL: 0
;PCODE: $0000063E VOL: 0
;PCODE: $0000063F VOL: 0
;PCODE: $00000640 VOL: 0
;PCODE: $00000641 VOL: 0
;     	        LcdCache[LcdCacheIdx] = b;
;PCODE: $00000642 VOL: 0
;PCODE: $00000643 VOL: 0
;PCODE: $00000644 VOL: 0
;     	        LcdCache[LcdCacheIdx+84] = a;
;PCODE: $00000645 VOL: 0
;PCODE: $00000646 VOL: 0
;PCODE: $00000647 VOL: 0
;PCODE: $00000648 VOL: 0
;     	        LcdCacheIdx = LcdCacheIdx+1;
;PCODE: $00000649 VOL: 0
;PCODE: $0000064A VOL: 0
;PCODE: $0000064B VOL: 0
;     	        }
;PCODE: $0000064C VOL: 0
;PCODE: $0000064D VOL: 0
;PCODE: $0000064E VOL: 0
;PCODE: $0000064F VOL: 0
;PCODE: $00000650 VOL: 0
;
;     	LcdCache[LcdCacheIdx++] = 0x00;
;PCODE: $00000651 VOL: 0
;PCODE: $00000652 VOL: 0
;PCODE: $00000653 VOL: 0
;PCODE: $00000654 VOL: 0
;PCODE: $00000655 VOL: 0
;PCODE: $00000656 VOL: 0
;PCODE: $00000657 VOL: 0
;     	}
;PCODE: $00000658 VOL: 0
;PCODE: $00000659 VOL: 0
;PCODE: $0000065A VOL: 0
;PCODE: $0000065B VOL: 0
;
;void LcdStringBig (unsigned char x, unsigned char y)	//Displays a string at current cursor location
;	{
;PCODE: $0000065C VOL: 0
;PCODE: $0000065D VOL: 0
;	unsigned char i;
;
;	if (x > 14 || y > 5) return;
;PCODE: $0000065E VOL: 0
;	x -> Y+2
;	y -> Y+1
;	i -> R17
;PCODE: $0000065F VOL: 0
;PCODE: $00000660 VOL: 0
;PCODE: $00000661 VOL: 0
;PCODE: $00000662 VOL: 0
;PCODE: $00000663 VOL: 0
;PCODE: $00000664 VOL: 0
;PCODE: $00000665 VOL: 0
;PCODE: $00000666 VOL: 0
;PCODE: $00000667 VOL: 0
;PCODE: $00000668 VOL: 0
;PCODE: $00000669 VOL: 0
;PCODE: $0000066A VOL: 0
;	LcdGotoXYFont (x, y);
;PCODE: $0000066B VOL: 0
;PCODE: $0000066C VOL: 0
;PCODE: $0000066D VOL: 0
;PCODE: $0000066E VOL: 0
;PCODE: $0000066F VOL: 0
;PCODE: $00000670 VOL: 0
;	for ( i = 0; i < 15-x; i++ ) if (lcd_buf[i]) LcdChrBig (lcd_buf[i]);
;PCODE: $00000671 VOL: 0
;PCODE: $00000672 VOL: 0
;PCODE: $00000673 VOL: 0
;PCODE: $00000674 VOL: 0
;PCODE: $00000675 VOL: 0
;PCODE: $00000676 VOL: 0
;PCODE: $00000677 VOL: 0
;PCODE: $00000678 VOL: 0
;PCODE: $00000679 VOL: 0
;PCODE: $0000067A VOL: 0
;PCODE: $0000067B VOL: 0
;PCODE: $0000067C VOL: 0
;PCODE: $0000067D VOL: 0
;PCODE: $0000067E VOL: 0
;PCODE: $0000067F VOL: 0
;PCODE: $00000680 VOL: 0
;PCODE: $00000681 VOL: 0
;PCODE: $00000682 VOL: 0
;PCODE: $00000683 VOL: 0
;PCODE: $00000684 VOL: 0
;PCODE: $00000685 VOL: 0
;PCODE: $00000686 VOL: 0
;PCODE: $00000687 VOL: 0
;PCODE: $00000688 VOL: 0
;	clean_lcd_buf();
;PCODE: $00000689 VOL: 0
;PCODE: $0000068A VOL: 0
;PCODE: $0000068B VOL: 0
;PCODE: $0000068C VOL: 0
;PCODE: $0000068D VOL: 0
;PCODE: $0000068E VOL: 0
;PCODE: $0000068F VOL: 0
;	}
;PCODE: $00000690 VOL: 0
;PCODE: $00000691 VOL: 0
;PCODE: $00000692 VOL: 0
;PCODE: $00000693 VOL: 0
;PCODE: $00000694 VOL: 0
;
;#pragma used-
;// картинки для 3310
;
;  flash unsigned char waitImage[] = {
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x20,0x20,
;  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0xF0,0x10,0x10,0x10,0x10,0xE0,0x00,0x00,0xF0,0x00,0x00,0x80,0x40,0x40,
;  0x40,0x80,0x00,0x00,0x80,0x40,0x40,0x40,0x80,0x00,0x00,0x80,0x40,0x40,0x40,0x80,
;  0x00,0x00,0x80,0x40,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x0F,0x11,0x31,0x31,0xD1,0xF1,0xD1,0xD1,0x31,0x11,0x11,0x0F,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x1F,0x00,
;  0x00,0x0F,0x12,0x12,0x12,0x0B,0x00,0x00,0x0C,0x12,0x12,0x0A,0x1F,0x00,0x00,0x09,
;  0x12,0x12,0x12,0x0C,0x00,0x00,0x0F,0x12,0x12,0x12,0x0B,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0xF0,0x18,0x86,0x86,0xE1,0xF1,0xE1,0xE1,0x86,0x18,0x18,
;  0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x80,0x00,0x80,
;  0x60,0x80,0x00,0x80,0x60,0x00,0x40,0x20,0x20,0x20,0xC0,0x00,0x00,0xE8,0x00,0x20,
;  0xF8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x07,0x07,0x07,0x07,0x07,
;  0x07,0x07,0x07,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x03,0x0C,0x03,0x00,0x03,0x0C,0x03,0x00,0x00,0x06,0x09,0x09,0x05,0x0F,0x00,
;  0x00,0x0F,0x00,0x00,0x0F,0x08,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,
;  0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
;  };
;
; flash unsigned char rad1Image[] = {	// простая
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
; 0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE,
; 0xFE,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFE,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x40,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x0F,0x03,0x01,0xF0,0xF8,0xFC,0xFC,0xFE,
; 0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF0,0x01,0x03,0x0F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE1,
; 0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F,0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
; 0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,
; 0x0E,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;
; flash unsigned char rad2Image[] = {	// простая+копирайт
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
; 0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE,
; 0xFC,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFE,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x40,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x0F,0x03,0x01,0xF0,0xF8,0xFC,0xFC,0xFE,
; 0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF0,0x01,0x03,0x0F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE1,
; 0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F,0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x70,0x88,0x70,0x50,0x88,0x70,0x00,0xC8,0xA8,0x90,0x00,0x70,
; 0x88,0x70,0x00,0x10,0xF8,0x00,0x70,0x88,0x70,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
; 0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,
; 0x0E,0x0C,0x00,0x00,0x00,0xF0,0x28,0xF0,0x00,0xF8,0x20,0xF8,0x00,0xF8,0xA8,0x88,
; 0x00,0x88,0xF8,0x88,0x00,0xF8,0x48,0xB0};
;
;flash unsigned char rad3Image[] = {	 //простая+копирайт+abc
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
;0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
;0x00,0x00,0x00,0x00,0x00,0xC0,0x20,0x20,0x20,0x40,0x80,0x40,0x20,0x10,0x0C,0x00,
;0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE,
;0xFC,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFE,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x41,0x02,0x02,0x02,0x01,0x00,0x01,
;0x02,0x02,0x41,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x7F,
;0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
;0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x0F,0x03,0x01,0xF0,0xF8,0xFC,0xFC,0xFE,
;0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF0,0x01,0x03,0x0F,0x7F,0x7F,0x7F,0x7F,
;0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
;0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0xF8,0x24,0x24,0x58,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE1,
;0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F,0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x30,0xC0,0xC0,0x30,0x0C,0x02,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x08,0x10,0x10,0x0F,0x02,0x04,0x84,0xC3,0xE0,0xF0,0xF8,0xFC,0xFE,
;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x0F,0x10,0x10,0x0F,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x70,0x88,0x70,0x50,0x88,0x70,0x00,0xC8,0xA8,0x90,0x00,0x70,
;0x88,0x70,0x00,0x10,0xF8,0x00,0x10,0xF8,0x00,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
; 0x88,0x70,0x00,0x10,0xF8,0x00,0x70,0x88,0x70,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
;0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,
;0x0E,0x0C,0x00,0x00,0x00,0xF0,0x28,0xF0,0x00,0xF8,0x20,0xF8,0x00,0xF8,0xA8,0x88,
;0x00,0x88,0xF8,0x88,0x00,0xF8,0x48,0xB0};
;
; flash unsigned char rad4Image[] = {	// простая+копирайт+abc(инв)
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
; 0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE,
; 0xFC,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFE,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0xEF,0xEF,0xEF,0x5F,0xBF,0x5F,0xEF,0xF7,0x79,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x40,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFB,0x67,0x9F,0x9F,0x67,0xF9,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7E,0x7E,0x7E,0x7F,0x7F,0x7F,
; 0x7E,0x7E,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x0F,0x03,0x01,0xF0,0xF8,0xFC,0xFC,0xFE,
; 0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF0,0x01,0x03,0x0F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x77,0x77,0x78,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE1,
; 0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F,0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0xDB,0xDB,0xA7,0x7F,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x70,0x88,0x70,0x50,0x88,0x70,0x00,0xC8,0xA8,0x90,0x00,0x70,
; 0x88,0x70,0x00,0x10,0xF8,0x00,0x70,0x88,0x70,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
; 0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xF7,0xEF,0xEF,0xF0,0xFD,0xFB,
; 0xFB,0xFC,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,
; 0x0E,0x0C,0x00,0x00,0x00,0xF0,0x28,0xF0,0x00,0xF8,0x20,0xF8,0x00,0xF8,0xA8,0x88,
; 0x00,0x88,0xF8,0x88,0x00,0xF8,0x48,0xB0};
;
;
; flash unsigned char mini_WIN[504] =
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xF0, 0x70,
;  0x70, 0x38, 0x38, 0x38, 0x38, 0x18, 0x18, 0x18, 0x1C, 0x1C, 0x1C, 0x1C,
;  0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C,
;  0x1C, 0x1C, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x38, 0x38, 0x38, 0x79, 0x70,
;  0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0xE0, 0xF0, 0xF8, 0x7C, 0x3E,
;  0x1F, 0x0F, 0x07, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0xC0, 0xE0, 0xF8, 0xF8, 0xF8, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
;  0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0x38, 0x10, 0x80, 0xC0,
;  0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
;  0xC0, 0xC0, 0xC0, 0xC1, 0xC1, 0x61, 0x23, 0x03, 0x07, 0x0F, 0x1F, 0x3E,
;  0x7E, 0x7C, 0xF8, 0xF0, 0xE0, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x03, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xEC,
;  0xE6, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
;  0xE7, 0xE7, 0xE7, 0xCF, 0x0F, 0x0F, 0x83, 0x81, 0x9C, 0x3E, 0x3F, 0x7F,
;  0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x3F,
;  0xBF, 0x1F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x3F, 0x7F, 0xFF, 0xFC, 0xF0, 0xE0,
;  0xC0, 0x80, 0x00, 0x00, 0x00, 0x30, 0x38, 0x1E, 0x1F, 0x1F, 0x1F, 0x1F,
;  0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F,
;  0x0F, 0x07, 0x41, 0xF0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x03,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0,
;  0xE0, 0xF0, 0xFE, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03,
;  0x07, 0x0F, 0x0F, 0x1E, 0x1E, 0x3C, 0x3C, 0x38, 0x38, 0x70, 0x70, 0xF0,
;  0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x80, 0x80,
;  0x80, 0x80, 0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
;  0x81, 0x81, 0x81, 0xC1, 0xC1, 0xC1, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xF0,
;  0x70, 0x70, 0x78, 0x38, 0x38, 0x3C, 0x3C, 0x1E, 0x0E, 0x0F, 0x07, 0x07,
;  0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0xF0, 0x10, 0x20, 0x11, 0xF1, 0x01, 0x01, 0xE9, 0x01, 0x03,
;  0xE3, 0x23, 0xE3, 0x03, 0x03, 0xEB, 0x03, 0x03, 0x03, 0x13, 0x23, 0x43,
;  0x83, 0x41, 0x21, 0x41, 0x81, 0x41, 0x21, 0x10, 0x00, 0x00, 0xE8, 0x00,
;  0x00, 0xE0, 0x20, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;
; static const char psydion [504]  =       //псайдион
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x80, 0x80, 0xC0, 0xC0, 0xE0, 0x60, 0x70, 0x30, 0x30, 0x18, 0x18, 0x18,
;  0x0C, 0x2C, 0x2C, 0x2C, 0x2C, 0xE6, 0xE6, 0xE6, 0xC6, 0x02, 0x02, 0x02,
;  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
;  0x02, 0x02, 0xC2, 0xE6, 0xE6, 0xE6, 0x26, 0x2C, 0x2C, 0x2C, 0x0C, 0x08,
;  0x18, 0x18, 0x18, 0x30, 0x30, 0x70, 0x60, 0xE0, 0xC0, 0xC0, 0x80, 0x80,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x80, 0xC0, 0xF0, 0x38, 0x1C, 0x8C, 0x0E, 0x06, 0x07,
;  0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x7F, 0x78, 0x60, 0x40,
;  0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0x40,
;  0x60, 0x78, 0x7F, 0x3F, 0x1F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03,
;  0x07, 0x06, 0x8E, 0x1C, 0x38, 0x78, 0xF0, 0xC0, 0x80, 0x00, 0x00, 0x00,
;  0x00, 0xF8, 0xFE, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x07, 0x06, 0x06, 0x0E,
;  0x0E, 0xEE, 0xEE, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8C, 0x9C, 0xF8,
;  0xF0, 0xC0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
;  0x80, 0xC0, 0xE0, 0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0xE0, 0xC0, 0x80, 0x80,
;  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xE0, 0xF8, 0xB8,
;  0x9C, 0x8C, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0xEE, 0xEE, 0x0E, 0x0E, 0x0E,
;  0x06, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1F, 0xFE, 0xF8, 0x00,
;  0x00, 0x3F, 0xFF, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xE0, 0xE0,
;  0xE0, 0xEF, 0xEF, 0xE3, 0xE3, 0xE3, 0xE3, 0x63, 0x73, 0x73, 0x3B, 0x3F,
;  0x1F, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
;  0x03, 0x07, 0x0F, 0xFF, 0xFD, 0xFE, 0xFD, 0xFF, 0x0F, 0x07, 0x03, 0x03,
;  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0F, 0x1F, 0x3B,
;  0x73, 0x73, 0x63, 0x63, 0xE3, 0xE3, 0xE3, 0xEF, 0xEF, 0xE0, 0xE0, 0xE0,
;  0xE0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xFF, 0x3F, 0x00,
;  0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x18, 0x30, 0x33, 0x60, 0xE0, 0xC0,
;  0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF8, 0xFC, 0xFC, 0x1C, 0x0E, 0x06,
;  0x86, 0x86, 0x86, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x86, 0x86, 0x86, 0x06,
;  0x0E, 0x1C, 0xFC, 0xF8, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0,
;  0xC0, 0xE0, 0x73, 0x38, 0x38, 0x1E, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x01, 0x03, 0x03, 0x07, 0x06, 0x0E, 0x0C, 0x0C, 0x18, 0x18, 0x38, 0x30,
;  0x20, 0x28, 0x28, 0x68, 0x6C, 0x6F, 0x6F, 0x67, 0x43, 0xC0, 0xC0, 0xC0,
;  0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC0,
;  0xC0, 0xC0, 0xC3, 0x47, 0x6F, 0x6F, 0x6C, 0x68, 0x68, 0x28, 0x20, 0x30,
;  0x30, 0x38, 0x18, 0x18, 0x0C, 0x0C, 0x0E, 0x06, 0x07, 0x03, 0x03, 0x01,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;  static const char psy[504] =                      // буква  псай
;{ 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x70, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
;  0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0xF0, 0xF0,
;  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
;  0xF0, 0xF0, 0xF0, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xC0, 0xE0, 0xE0,
;  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x70, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF,
;  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0xF0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F,
;  0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xF0, 0xE0,
;  0xC0, 0xC0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0xC0,
;  0xC0, 0xE0, 0xF0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F,
;  0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x07, 0x07,
;  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
;  0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
;  0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E,
;  0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
;  0x1F, 0x1E, 0x1E, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;  static const char owl[504] =                 //сова
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0xF2, 0x9E, 0x5C,
;  0xDC, 0xFC, 0xF8, 0x38, 0x08, 0xC0, 0xF0, 0xC0, 0x08, 0x38, 0xF8, 0xFC,
;  0xDC, 0x5C, 0x9E, 0xF2, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x7E, 0xE6, 0xDE, 0xBF, 0x77, 0xB3,
;  0x9F, 0xFF, 0xC7, 0x82, 0x00, 0x20, 0x71, 0x20, 0x00, 0x82, 0xC7, 0xFF,
;  0x9F, 0xB3, 0x77, 0xBF, 0xDE, 0xE6, 0x7E, 0x3C, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x02,
;  0x05, 0x01, 0x04, 0x6F, 0x3E, 0x0E, 0x7C, 0x0E, 0x3E, 0x6F, 0x04, 0x01,
;  0x05, 0x02, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x08, 0x0C, 0x0E, 0x0E, 0x0E, 0x0E, 0x1E, 0x1F, 0x1F, 0x3F,
;  0x3F, 0x3F, 0x37, 0x7B, 0xFB, 0x86, 0xFE, 0xEE, 0xE6, 0x3E, 0xCE, 0xFE,
;  0xBC, 0xCC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0x01, 0x39, 0xF9, 0xFF, 0xCF,
;  0xAE, 0xEE, 0xFC, 0x7C, 0x00, 0x60, 0xF8, 0x60, 0x00, 0x7C, 0xFC, 0xEE,
;  0xAE, 0xCF, 0xFF, 0xF9, 0x39, 0x01, 0xE0, 0xF0, 0xF8, 0xF8, 0xFC, 0xCC,
;  0xBC, 0xFE, 0xCE, 0x3E, 0xE6, 0xEE, 0xFE, 0x86, 0xFB, 0x7B, 0x37, 0x3F,
;  0x3F, 0x3F, 0x1F, 0x1F, 0x1E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0C, 0x08, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07, 0x01, 0x0F,
;  0x0F, 0x0B, 0x0D, 0x0E, 0x1E, 0x1F, 0x1F, 0x1F, 0x38, 0x07, 0x37, 0x75,
;  0xDB, 0xBF, 0xE7, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xE7, 0xBF,
;  0xDB, 0x75, 0x37, 0x07, 0x38, 0x1F, 0x1F, 0x1F, 0x1E, 0x0E, 0x0D, 0x0B,
;  0x0F, 0x0F, 0x01, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x01, 0x63, 0x73, 0x3F, 0xE7, 0xF7, 0x1E, 0xF7, 0xE7, 0x3F, 0x73, 0x63,
;  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;static const char BattFull[504] =
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x42, 0x5A,
;  0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x42, 0x7E, 0x3C,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;
;  static const char bell[504] =
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x80, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF8, 0xF8,
;  0xF8, 0x78, 0x7C, 0x7C, 0x7C, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x1E,
;  0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
;  0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x7C, 0x7C, 0x7C, 0xF8, 0xF8, 0xF8,
;  0xF8, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF,
;  0x7F, 0x7F, 0x1F, 0x1F, 0x0F, 0x07, 0x07, 0x03, 0x01, 0x01, 0x01, 0x00,
;  0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
;  0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xF0, 0xF0,
;  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x00,
;  0x01, 0x03, 0x03, 0x07, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0xFF, 0xFE,
;  0xFC, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0xC0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x01, 0x01,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
;  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x03, 0x01, 0x01, 0x01, 0x01,
;  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
;  0x01, 0x01, 0x03, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
;  0x07, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0xC0, 0x00, 0x00,
;  0x00, 0x07, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x80,
;  0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFF, 0xFF,
;  0xFF, 0xFF, 0xEF, 0xE7, 0xE3, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
;  0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
;  0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE3, 0xE7, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0xFF, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
;  0xE0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x07, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x7F, 0xFF,
;  0xFE, 0xFE, 0xF8, 0xF8, 0xF1, 0xE1, 0xE1, 0xC1, 0x81, 0x81, 0x01, 0x01,
;  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
;  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x01, 0x01,
;  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
;  0x81, 0xC1, 0xC1, 0xC1, 0xE1, 0xF1, 0xF0, 0xF8, 0xFC, 0xFC, 0xFF, 0xFF,
;  0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x0F, 0x0F, 0x1F, 0x1F, 0x1F,
;  0x3F, 0x3F, 0x3E, 0x3E, 0x3E, 0x3C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C,
;  0x7C, 0x78, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7C,
;  0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x3C, 0x3E, 0x3E, 0x3E, 0x3F, 0x1F, 0x1F,
;  0x1F, 0x1F, 0x0F, 0x0F, 0x07, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;
;
;
;flash unsigned char Batt0[16] = {0x7F,0x41,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};	 // степени заряда батареи
;flash unsigned char Batt1[16] = {0x7F,0x41,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt2[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt3[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt4[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt5[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt6[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt7[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt8[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt9[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt10[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x7F,0x3E};
;flash unsigned char Batt_done[16] = {0x7F,0x41,0x55,0x49,0x55,0x49,0x55,0x49,0x55,0x49,0x55,0x49,0x55,0x41,0x7F,0x3E};
;
;// flash unsigned char Card[7] = {0x7C,0x42,0x5D,0x55,0x49,0x41,0x7F};
;flash unsigned char Card[7] = {0x7C,0x42,0x41,0x41,0x41,0x41,0x7F};	  //простая карта памяти
;flash unsigned char CardFail[7] = {0x7C,0x62,0x55,0x49,0x55,0x63,0x7F};  // перечеркнутая карта - ошибка доступа
;flash unsigned char CardFull[7] = {0x7C,0x7E,0x7F,0x7F,0x7F,0x7F,0x7F};  // заполненная карта
;
;
;//flash unsigned char Power[14] = {0x14,0x14,0x3E,0x22,0x22,0x22,0x1C,0x08,0x04,0x04,0x08,0x10,0x10,0x08};	//  символ вилки
;
;//flash unsigned char USB[12] = {0x1E,0x20,0x20,0x1E,0x00,0x24,0x2A,0x12,0x00,0x3E,0x2A,0x14};	 // USB
;
;flash unsigned char Bell[9] = {0x20,0x50,0x4E,0x61,0x61,0x61,0x4E,0x50,0x20};                  //   будильник
;
;flash unsigned char Radar[8] = {0x03,0x44,0x68,0x78,0x54,0x22,0x20,0x20};                       //  GPS
;flash unsigned char RadarLocate[8] = {0x03,0x44,0x68,0x79,0x54,0x22,0x28,0x25};                 //  GPS со спутниками
;
;flash unsigned char Level0[2] = {0x60,0x60};                                                    //  диаграмма разного уровня
;flash unsigned char Level1[4] = {0x60,0x60,0x70,0x70};
;flash unsigned char Level2[6] = {0x60,0x60,0x70,0x70,0x78,0x78};
;flash unsigned char Level3[8] = {0x60,0x60,0x70,0x70,0x78,0x78,0x7C,0x7C};
;flash unsigned char Level4[10] = {0x60,0x60,0x70,0x70,0x78,0x78,0x7C,0x7C,0x7E,0x7E};
;flash unsigned char Level5[12] = {0x60,0x60,0x70,0x70,0x78,0x78,0x7C,0x7C,0x7E,0x7E,0x7F,0x7F};

	.DSEG
;//***************************************************************************
;//
;//  Author(s)...: Pashgan    http://ChipEnable.Ru
;//
;//
;//  Compiler....: CodeVision 2.04
;//
;//  Description.: USART/UART. Используем кольцевой буфер
;//
;//  Data........: 3.01.10
;//
;//***************************************************************************
;#include "usart.h"
;
;
;#warning заменить на структуру+ избавиться от Usart_rxCount!
;/*
;  struct {
;	u08 buff[TX_BUFFER_SIZE];
;	u08 head;
;	u08 tail;
;} TX_buff;
;
;struct {
;	u08 buff[RX_BUFFER_SIZE];
;	u08 head;
;	u08 tail;
;} RX_buff;
;*/
;//передающий буфер
;static volatile char Usart0_TX_buf[SIZE_BUF_TX];
;static volatile uint16_t Usart0_txBufTail = 0;
;static volatile uint16_t Usart0_txBufHead = 0;
;//static volatile uint16_t Usart0_txCount = 0;
;
;static volatile char Usart1_TX_buf[SIZE_BUF_TX];
;static volatile uint16_t Usart1_txBufTail = 0;
;static volatile uint16_t Usart1_txBufHead = 0;
;//static volatile uint16_t Usart1_txCount = 0;
; #warning  Usart0_txCount not used
;
;
;//приемный буфер
;static volatile char Usart0_RX_buf[SIZE_BUF_RX];
;static volatile uint16_t Usart0_rxBufTail = 0;
;static volatile uint16_t Usart0_rxBufHead = 0;
;static volatile uint16_t Usart0_rxCount = 0;
;
;static volatile char Usart1_RX_buf[SIZE_BUF_RX];
;static volatile uint16_t Usart1_rxBufTail = 0;
;static volatile uint16_t Usart1_rxBufHead = 0;
;static volatile uint16_t Usart1_rxCount = 0;
;
;#ifndef F_CPU
;#error "F_CPU is not defined"
;#endif
;
;void UartTxBufOvf_Handler(void){ //обработчик переполнения передающего буфера UART

	.CSEG
;PCODE: $00000695 VOL: 0
;PCODE: $00000696 VOL: 0
;PORTD.6=1;
;PCODE: $00000697 VOL: 0
;PCODE: $00000698 VOL: 0
;}
;PCODE: $00000699 VOL: 0
;PCODE: $0000069A VOL: 0
;
;
;uint16_t Calk_safe_baud(uint8_t mode, uint16_t input_baud){
;PCODE: $0000069B VOL: 0
;PCODE: $0000069C VOL: 0
; uint8_t max_total_err = 52; //порог ошибки, если больше - комуникация невозможна. 52 соответствует 2.1%
;
; uint32_t tmp0 = 0;
; uint16_t tmp1 = 0;
;
; if (mode == USART_NORMAL){tmp0 = 16UL*input_baud;}
;PCODE: $0000069D VOL: 0
;PCODE: $0000069E VOL: 0
;PCODE: $0000069F VOL: 0
;PCODE: $000006A0 VOL: 0
;PCODE: $000006A1 VOL: 0
;PCODE: $000006A2 VOL: 0
;PCODE: $000006A3 VOL: 0
;PCODE: $000006A4 VOL: 0
;PCODE: $000006A5 VOL: 0
;PCODE: $000006A6 VOL: 0
;	mode -> Y+10
;	input_baud -> Y+8
;	max_total_err -> R17
;	tmp0 -> Y+4
;	tmp1 -> R18,R19
;PCODE: $000006A7 VOL: 0
;PCODE: $000006A8 VOL: 0
;PCODE: $000006A9 VOL: 0
;PCODE: $000006AA VOL: 0
;PCODE: $000006AB VOL: 0
;PCODE: $000006AC VOL: 0
;PCODE: $000006AD VOL: 0
;PCODE: $000006AE VOL: 0
;PCODE: $000006AF VOL: 0
;PCODE: $000006B0 VOL: 0
;PCODE: $000006B1 VOL: 0
;PCODE: $000006B2 VOL: 0
; else {tmp0 = 8UL*input_baud;}
;PCODE: $000006B3 VOL: 0
;PCODE: $000006B4 VOL: 0
;PCODE: $000006B5 VOL: 0
;PCODE: $000006B6 VOL: 0
;PCODE: $000006B7 VOL: 0
;PCODE: $000006B8 VOL: 0
;PCODE: $000006B9 VOL: 0
;PCODE: $000006BA VOL: 0
;
; tmp1 = (F_CPU/100)/tmp0;   //{ubrrValue = F_CPU/(16UL*baudRate) - 1;}
;PCODE: $000006BB VOL: 0
;PCODE: $000006BC VOL: 0
;PCODE: $000006BD VOL: 0
;PCODE: $000006BE VOL: 0
; tmp1 = tmp1*tmp0;
;PCODE: $000006BF VOL: 0
;PCODE: $000006C0 VOL: 0
;PCODE: $000006C1 VOL: 0
;PCODE: $000006C2 VOL: 0
; tmp1 = ((F_CPU/100) - tmp1);
;PCODE: $000006C3 VOL: 0
;PCODE: $000006C4 VOL: 0
;PCODE: $000006C5 VOL: 0
;PCODE: $000006C6 VOL: 0
;PCODE: $000006C7 VOL: 0
;PCODE: $000006C8 VOL: 0
; tmp1 = tmp1>>5; // /32
;PCODE: $000006C9 VOL: 0
;PCODE: $000006CA VOL: 0
;PCODE: $000006CB VOL: 0
;PCODE: $000006CC VOL: 0
; if(tmp1 > max_total_err){tmp1 = 48;} //при большой потенциальной ошибке передачи (>2.1%) скорость будет 4800baud (не вызывает ошибки на ЛЮБЫХ частотах)
;PCODE: $000006CD VOL: 0
;PCODE: $000006CE VOL: 0
;PCODE: $000006CF VOL: 0
;PCODE: $000006D0 VOL: 0
;PCODE: $000006D1 VOL: 0
;PCODE: $000006D2 VOL: 0
;PCODE: $000006D3 VOL: 0
; else {tmp1 = input_baud;} //если всё ок, вернуть принятую скорость
;PCODE: $000006D4 VOL: 0
;PCODE: $000006D5 VOL: 0
;PCODE: $000006D6 VOL: 0
;PCODE: $000006D7 VOL: 0
;PCODE: $000006D8 VOL: 0
;return tmp1;
;PCODE: $000006D9 VOL: 0
;PCODE: $000006DA VOL: 0
;PCODE: $000006DB VOL: 0
;PCODE: $000006DC VOL: 0
;}
;PCODE: $000006DD VOL: 0
;
;
; void USART_Init (uint8_t sel, uint8_t mode, uint16_t baudRate) //инициализация usart`a
;{
;PCODE: $000006DE VOL: 0
;PCODE: $000006DF VOL: 0
;  uint16_t ubrrValue;
;__disable_interrupts();
;PCODE: $000006E0 VOL: 0
;PCODE: $000006E1 VOL: 0
;	sel -> Y+5
;	mode -> Y+4
;	baudRate -> Y+2
;	ubrrValue -> R16,R17
;PCODE: $000006E2 VOL: 0
;PCODE: $000006E3 VOL: 0
;PCODE: $000006E4 VOL: 1
;PCODE: $000006E5 VOL: 0
	cli
;PCODE: $000006E6 VOL: 0
;PCODE: $000006E7 VOL: 0
;PCODE: $000006E8 VOL: 0
;PCODE: $000006E9 VOL: 0
;PCODE: $000006EA VOL: 0
;
;#ifdef UART_BAUD-ERR-CONTROL_EN
;baudRate = Calk_safe_baud(mode, baudRate);// Проверка погрешности при выбраной скорости (зависит от F_CPU)
;#endif
;baudRate = baudRate * 100;
;PCODE: $000006EB VOL: 0
;PCODE: $000006EC VOL: 0
;PCODE: $000006ED VOL: 0
;PCODE: $000006EE VOL: 0
;if(sel==USART_0)
;PCODE: $000006EF VOL: 0
;PCODE: $000006F0 VOL: 0
;PCODE: $000006F1 VOL: 0
;{
;  Usart0_txBufTail = 0;  Usart0_txBufHead = 0;
;PCODE: $000006F2 VOL: 0
;PCODE: $000006F3 VOL: 1
;PCODE: $000006F4 VOL: 0
;PCODE: $000006F5 VOL: 1
;  Usart0_rxBufTail = 0;  Usart0_rxBufHead = 0;
;PCODE: $000006F6 VOL: 0
;PCODE: $000006F7 VOL: 1
;PCODE: $000006F8 VOL: 0
;PCODE: $000006F9 VOL: 1
;  Usart0_rxCount = 0;
;PCODE: $000006FA VOL: 0
;PCODE: $000006FB VOL: 1
;  UCSR0A = 0; // USART0 disabled
;PCODE: $000006FC VOL: 0
;PCODE: $000006FD VOL: 0
;  UCSR0B = 0;
;PCODE: $000006FE VOL: 0
;PCODE: $000006FF VOL: 0
;  UCSR0C = 0;
;PCODE: $00000700 VOL: 0
;PCODE: $00000701 VOL: 0
;
;    if (mode == USART_NORMAL){ubrrValue = F_CPU/(16UL*baudRate) - 1;}
;PCODE: $00000702 VOL: 0
;PCODE: $00000703 VOL: 0
;PCODE: $00000704 VOL: 0
;PCODE: $00000705 VOL: 0
;PCODE: $00000706 VOL: 0
;PCODE: $00000707 VOL: 0
;PCODE: $00000708 VOL: 0
;PCODE: $00000709 VOL: 0
;PCODE: $0000070A VOL: 0
;PCODE: $0000070B VOL: 0
;PCODE: $0000070C VOL: 0
;    else                     {ubrrValue = F_CPU/(8UL*baudRate) - 1; UCSR0A = (1<<U2X0);}//doubles speed
;PCODE: $0000070D VOL: 0
;PCODE: $0000070E VOL: 0
;PCODE: $0000070F VOL: 0
;PCODE: $00000710 VOL: 0
;PCODE: $00000711 VOL: 0
;PCODE: $00000712 VOL: 0
;PCODE: $00000713 VOL: 0
;PCODE: $00000714 VOL: 0
;PCODE: $00000715 VOL: 0
;PCODE: $00000716 VOL: 0
;PCODE: $00000717 VOL: 0
;PCODE: $00000718 VOL: 0
;PCODE: $00000719 VOL: 0
;
;  // Communication Parameters: 8 Data, 1 Stop, No Parity
;  // USART1 Receiver: On //Transmitter: On //Mode: Asynchronous
;  UBRR0H = (uint8_t)(ubrrValue >> 8);
;PCODE: $0000071A VOL: 0
;PCODE: $0000071B VOL: 0
;  UBRR0L = (uint8_t)ubrrValue;
;PCODE: $0000071C VOL: 0
;PCODE: $0000071D VOL: 0
;  UCSR0B = (1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0); //разр. прерыв при приеме и передачи, разр приема, разр передачи.
;PCODE: $0000071E VOL: 0
;PCODE: $0000071F VOL: 0
;  UCSR0C = (1<<UCSZ01)|(1<<UCSZ00); //размер слова 8 разрядов
;PCODE: $00000720 VOL: 0
;PCODE: $00000721 VOL: 0
;}
;else
;PCODE: $00000722 VOL: 0
;PCODE: $00000723 VOL: 0
;{
;  Usart1_txBufTail = 0;  Usart1_txBufHead = 0;
;PCODE: $00000724 VOL: 0
;PCODE: $00000725 VOL: 1
;PCODE: $00000726 VOL: 0
;PCODE: $00000727 VOL: 1
;  Usart1_rxBufTail = 0;  Usart1_rxBufHead = 0;
;PCODE: $00000728 VOL: 0
;PCODE: $00000729 VOL: 1
;PCODE: $0000072A VOL: 0
;PCODE: $0000072B VOL: 1
;  Usart1_rxCount = 0;
;PCODE: $0000072C VOL: 0
;PCODE: $0000072D VOL: 1
;  UCSR1A = 0;  // USART1 disabled
;PCODE: $0000072E VOL: 0
;PCODE: $0000072F VOL: 0
;  UCSR1B = 0;
;PCODE: $00000730 VOL: 0
;PCODE: $00000731 VOL: 0
;  UCSR1C = 0;
;PCODE: $00000732 VOL: 0
;PCODE: $00000733 VOL: 0
;
;    if (mode == USART_NORMAL){ubrrValue = F_CPU/(16UL*baudRate) - 1;}
;PCODE: $00000734 VOL: 0
;PCODE: $00000735 VOL: 0
;PCODE: $00000736 VOL: 0
;PCODE: $00000737 VOL: 0
;PCODE: $00000738 VOL: 0
;PCODE: $00000739 VOL: 0
;PCODE: $0000073A VOL: 0
;PCODE: $0000073B VOL: 0
;PCODE: $0000073C VOL: 0
;PCODE: $0000073D VOL: 0
;PCODE: $0000073E VOL: 0
;    else                     {ubrrValue = F_CPU/(8UL*baudRate) - 1; UCSR1A = (1<<U2X1);}//doubles speed
;PCODE: $0000073F VOL: 0
;PCODE: $00000740 VOL: 0
;PCODE: $00000741 VOL: 0
;PCODE: $00000742 VOL: 0
;PCODE: $00000743 VOL: 0
;PCODE: $00000744 VOL: 0
;PCODE: $00000745 VOL: 0
;PCODE: $00000746 VOL: 0
;PCODE: $00000747 VOL: 0
;PCODE: $00000748 VOL: 0
;PCODE: $00000749 VOL: 0
;PCODE: $0000074A VOL: 0
;PCODE: $0000074B VOL: 0
;
;  // Communication Parameters: 8 Data, 1 Stop, No Parity
;  // USART1 Receiver: On //Transmitter: On //Mode: Asynchronous
;  UBRR1H = (uint8_t)(ubrrValue >> 8);
;PCODE: $0000074C VOL: 0
;PCODE: $0000074D VOL: 0
;  UBRR1L = (uint8_t)ubrrValue;
;PCODE: $0000074E VOL: 0
;PCODE: $0000074F VOL: 0
;  UCSR1B = (1<<RXCIE1)|(1<<RXEN1)|(1<<TXEN1); //разр. прерыв при приеме и передачи, разр приема, разр передачи.
;PCODE: $00000750 VOL: 0
;PCODE: $00000751 VOL: 0
;  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10); //размер слова 8 разрядов
;PCODE: $00000752 VOL: 0
;PCODE: $00000753 VOL: 0
;}
;PCODE: $00000754 VOL: 0
;__restore_interrupts();
;PCODE: $00000755 VOL: 0
;PCODE: $00000756 VOL: 1
;PCODE: $00000757 VOL: 0
;PCODE: $00000758 VOL: 0
;}
;PCODE: $00000759 VOL: 0
;PCODE: $0000075A VOL: 0
;PCODE: $0000075B VOL: 0
;PCODE: $0000075C VOL: 0
;PCODE: $0000075D VOL: 0
;PCODE: $0000075E VOL: 0
;PCODE: $0000075F VOL: 0
;
;
;//______________________________________________________________________________
; /*
;unsigned char USART_Get_txCount(void) //возвращает колличество символов передающего буфера
;{
;  return Usart_txCount;
;}
;*/
;void USART_FlushTxBuf(uint8_t sel) //"очищает" передающий буфер
;{
;PCODE: $00000760 VOL: 0
;PCODE: $00000761 VOL: 0
;__disable_interrupts();
;	sel -> Y+0
;PCODE: $00000762 VOL: 0
;PCODE: $00000763 VOL: 0
;PCODE: $00000764 VOL: 1
;PCODE: $00000765 VOL: 0
	cli
;PCODE: $00000766 VOL: 0
;PCODE: $00000767 VOL: 0
;PCODE: $00000768 VOL: 0
;PCODE: $00000769 VOL: 0
;PCODE: $0000076A VOL: 0
;TX_CNT=0;
;PCODE: $0000076B VOL: 0
;PCODE: $0000076C VOL: 1
;
; switch (sel)
;PCODE: $0000076D VOL: 0
; {
;   case USART_0:
;PCODE: $0000076E VOL: 0
;PCODE: $0000076F VOL: 0
;Usart_0_flush:
;PCODE: $00000770 VOL: 0
;  Usart0_txBufTail = 0;
;PCODE: $00000771 VOL: 0
;PCODE: $00000772 VOL: 1
;  Usart0_txBufHead = 0;
;PCODE: $00000773 VOL: 0
;PCODE: $00000774 VOL: 1
;    //txCount = 0; //not used
;   break;
;PCODE: $00000775 VOL: 0
;   case USART_1:
;PCODE: $00000776 VOL: 0
;PCODE: $00000777 VOL: 0
;PCODE: $00000778 VOL: 0
;  Usart1_txBufTail = 0;
;PCODE: $00000779 VOL: 0
;PCODE: $0000077A VOL: 1
;  Usart1_txBufHead = 0;
;PCODE: $0000077B VOL: 0
;PCODE: $0000077C VOL: 1
;   break;
;PCODE: $0000077D VOL: 0
;     default:
;PCODE: $0000077E VOL: 0
; goto Usart_0_flush;
;PCODE: $0000077F VOL: 0
;   break;
;PCODE: $00000780 VOL: 0
;}
;PCODE: $00000781 VOL: 0
;__restore_interrupts();
;PCODE: $00000782 VOL: 0
;PCODE: $00000783 VOL: 1
;PCODE: $00000784 VOL: 0
;PCODE: $00000785 VOL: 0
;}
;PCODE: $00000786 VOL: 0
;PCODE: $00000787 VOL: 0
;PCODE: $00000788 VOL: 0
;
;
;//OPTIMISED!
;//помещает символ в буфер, инициирует начало передачи
;
;void USART_PutChar(uint8_t sel, unsigned char symbol) //помещает символ в буфер, инициирует начало передачи
;{
;PCODE: $00000789 VOL: 0
;PCODE: $0000078A VOL: 0
; uint16_t Tmp_0 = Usart0_txBufHead;
; uint16_t Tmp_1 = Usart1_txBufHead;
;
; switch (sel)
;PCODE: $0000078B VOL: 0
;	sel -> Y+5
;	symbol -> Y+4
;	Tmp_0 -> R16,R17
;	Tmp_1 -> R18,R19
;PCODE: $0000078C VOL: 0
;PCODE: $0000078D VOL: 0
;PCODE: $0000078E VOL: 0
;PCODE: $0000078F VOL: 0
;PCODE: $00000790 VOL: 0
; {
;   case USART_0:
;PCODE: $00000791 VOL: 0
;PCODE: $00000792 VOL: 0
; Usart_0:
;PCODE: $00000793 VOL: 0
;       // if(((UCSR0A & (1<<UDRE0)) == 1)) {UDR0 = symbol;} //если модуль usart свободен //((UCSRA & (1<<UDRE)) == 1) && (Usart0_txCount == 0)
;       //  else {                                                           //пишем символ прямо в регистр UDR
;               if((uint16_t)(Tmp_0 - Usart0_txBufTail ) <= (uint16_t) SIZE_BUF_TX){ // buffer full, wait until symbol transmitted in interrupt
;PCODE: $00000794 VOL: 0
;PCODE: $00000795 VOL: 1
;PCODE: $00000796 VOL: 0
;PCODE: $00000797 VOL: 0
;PCODE: $00000798 VOL: 0
;               Usart0_TX_buf[Tmp_0 & (SIZE_BUF_TX - 1)] = symbol;
;PCODE: $00000799 VOL: 0
;PCODE: $0000079A VOL: 0
;PCODE: $0000079B VOL: 1
;PCODE: $0000079C VOL: 0
;PCODE: $0000079D VOL: 0
;               ++Tmp_0;
;PCODE: $0000079E VOL: 0
;PCODE: $0000079F VOL: 0
;               __disable_interrupts();
;PCODE: $000007A0 VOL: 0
;PCODE: $000007A1 VOL: 0
;PCODE: $000007A2 VOL: 1
;PCODE: $000007A3 VOL: 0
	cli
;PCODE: $000007A4 VOL: 0
;PCODE: $000007A5 VOL: 0
;PCODE: $000007A6 VOL: 0
;PCODE: $000007A7 VOL: 0
;PCODE: $000007A8 VOL: 0
;               Usart0_txBufHead = Tmp_0;
;PCODE: $000007A9 VOL: 1
;PCODE: $000007AA VOL: 0
;               UCSR0B |= (1 << UDRIE0);
;PCODE: $000007AB VOL: 0
;PCODE: $000007AC VOL: 0
;               } else {UartTxBufOvf_Handler();}
;PCODE: $000007AD VOL: 0
;PCODE: $000007AE VOL: 0
;PCODE: $000007AF VOL: 0
;PCODE: $000007B0 VOL: 0
;         //    }
;   break;
;PCODE: $000007B1 VOL: 0
;   case USART_1:
;PCODE: $000007B2 VOL: 0
;PCODE: $000007B3 VOL: 0
;PCODE: $000007B4 VOL: 0
;      //  if(((UCSR1A & (1<<UDRE1)) == 1)) {UDR1 = symbol;} //если модуль usart свободен //((UCSRA & (1<<UDRE)) == 1) && (Usart0_txCount == 0)
;       //  else {                                                           //пишем символ прямо в регистр UDR
;               if((uint16_t)(Tmp_1 - Usart1_txBufTail) <= (uint16_t) SIZE_BUF_TX){ // buffer full, wait until symbol transmitted in interrupt
;PCODE: $000007B5 VOL: 0
;PCODE: $000007B6 VOL: 1
;PCODE: $000007B7 VOL: 0
;PCODE: $000007B8 VOL: 0
;PCODE: $000007B9 VOL: 0
;               Usart1_TX_buf[Tmp_1 & (SIZE_BUF_TX - 1)] = symbol;
;PCODE: $000007BA VOL: 0
;PCODE: $000007BB VOL: 0
;PCODE: $000007BC VOL: 1
;PCODE: $000007BD VOL: 0
;PCODE: $000007BE VOL: 0
;               ++Tmp_1;
;PCODE: $000007BF VOL: 0
;PCODE: $000007C0 VOL: 0
;               __disable_interrupts();
;PCODE: $000007C1 VOL: 0
;PCODE: $000007C2 VOL: 0
;PCODE: $000007C3 VOL: 1
;PCODE: $000007C4 VOL: 0
	cli
;PCODE: $000007C5 VOL: 0
;PCODE: $000007C6 VOL: 0
;PCODE: $000007C7 VOL: 0
;PCODE: $000007C8 VOL: 0
;PCODE: $000007C9 VOL: 0
;               Usart1_txBufHead = Tmp_1;
;PCODE: $000007CA VOL: 1
;PCODE: $000007CB VOL: 0
;               UCSR1B |= (1 << UDRIE1);
;PCODE: $000007CC VOL: 0
;PCODE: $000007CD VOL: 0
;PCODE: $000007CE VOL: 0
;               }else {UartTxBufOvf_Handler();}
;PCODE: $000007CF VOL: 0
;PCODE: $000007D0 VOL: 0
;PCODE: $000007D1 VOL: 0
;PCODE: $000007D2 VOL: 0
;          //   }
;   break;
;PCODE: $000007D3 VOL: 0
;     default:
;PCODE: $000007D4 VOL: 0
;     goto Usart_0;
;PCODE: $000007D5 VOL: 0
;     break;
;PCODE: $000007D6 VOL: 0
; }
;PCODE: $000007D7 VOL: 0
; __restore_interrupts();
;PCODE: $000007D8 VOL: 0
;PCODE: $000007D9 VOL: 1
;PCODE: $000007DA VOL: 0
;PCODE: $000007DB VOL: 0
;}
;PCODE: $000007DC VOL: 0
;PCODE: $000007DD VOL: 0
;PCODE: $000007DE VOL: 0
;PCODE: $000007DF VOL: 0
;
;
;
;void USART_SendStr(uint8_t sel, unsigned char * data)//функция посылающая строку по usart`у
;{
;PCODE: $000007E0 VOL: 0
;PCODE: $000007E1 VOL: 0
; // unsigned char symbol;
;  while(*data)
;	sel -> Y+2
;	*data -> Y+0
;PCODE: $000007E2 VOL: 0
;PCODE: $000007E3 VOL: 0
;PCODE: $000007E4 VOL: 0
;PCODE: $000007E5 VOL: 0
;PCODE: $000007E6 VOL: 0
;  {
;    //symbol = *data++;// USART_PutChar(sel,symbol);
;   USART_PutChar(sel, *data++);//Optimized
;PCODE: $000007E7 VOL: 0
;PCODE: $000007E8 VOL: 0
;PCODE: $000007E9 VOL: 0
;PCODE: $000007EA VOL: 0
;PCODE: $000007EB VOL: 0
;PCODE: $000007EC VOL: 0
;PCODE: $000007ED VOL: 0
;  }
;PCODE: $000007EE VOL: 0
;PCODE: $000007EF VOL: 0
;}
;PCODE: $000007F0 VOL: 0
;PCODE: $000007F1 VOL: 0
;PCODE: $000007F2 VOL: 0
;
;void USART_SendStrFl(uint8_t sel, unsigned char __flash * data) //функция посылающая строку из флэша по usart`у
;{
;PCODE: $000007F3 VOL: 0
;PCODE: $000007F4 VOL: 0
; // unsigned char symbol;
;  while(*data)
;	sel -> Y+2
;	*data -> Y+0
;PCODE: $000007F5 VOL: 0
;PCODE: $000007F6 VOL: 0
;PCODE: $000007F7 VOL: 0
;PCODE: $000007F8 VOL: 0
;PCODE: $000007F9 VOL: 0
;  {
;    //symbol = *data++; //USART_PutChar(sel, symbol);
;    USART_PutChar(sel, *data++);
;PCODE: $000007FA VOL: 0
;PCODE: $000007FB VOL: 0
;PCODE: $000007FC VOL: 0
;PCODE: $000007FD VOL: 0
;PCODE: $000007FE VOL: 0
;PCODE: $000007FF VOL: 0
;PCODE: $00000800 VOL: 0
;PCODE: $00000801 VOL: 0
;PCODE: $00000802 VOL: 0
;  }
;PCODE: $00000803 VOL: 0
;PCODE: $00000804 VOL: 0
;}
;PCODE: $00000805 VOL: 0
;PCODE: $00000806 VOL: 0
;PCODE: $00000807 VOL: 0
;
;
;  //Optimised
;//обработчик прерывания по завершению передачи
;interrupt [USART0_DRE] void usart0_dre_my(void)  //USART Data Register Empty Interrupt
;{
;PCODE: $00000808 VOL: 0
;PCODE: $00000809 VOL: 0
;uint16_t Tmp = Usart0_txBufTail; // use local variable instead of volatile
;
;      if(Tmp != Usart0_txBufHead) // Not all transmitted
;PCODE: $0000080A VOL: 0
;PCODE: $0000080B VOL: 0
;	Tmp -> R16,R17
;PCODE: $0000080C VOL: 0
;PCODE: $0000080D VOL: 0
;PCODE: $0000080E VOL: 1
;PCODE: $0000080F VOL: 0
;PCODE: $00000810 VOL: 0
;       {
;       UDR0 = Usart0_TX_buf[Tmp & (SIZE_BUF_TX - 1)];
;PCODE: $00000811 VOL: 0
;PCODE: $00000812 VOL: 0
;PCODE: $00000813 VOL: 1
;PCODE: $00000814 VOL: 0
;PCODE: $00000815 VOL: 0
;       ++Tmp;
;PCODE: $00000816 VOL: 0
;PCODE: $00000817 VOL: 0
;       Usart0_txBufTail = Tmp;
;PCODE: $00000818 VOL: 1
;PCODE: $00000819 VOL: 0
;       }
;       else{
;PCODE: $0000081A VOL: 0
;PCODE: $0000081B VOL: 0
;    // PORTD.6=0;
;         Usart0_txBufHead = 0; Usart0_txBufTail = 0;
;PCODE: $0000081C VOL: 0
;PCODE: $0000081D VOL: 1
;PCODE: $0000081E VOL: 0
;PCODE: $0000081F VOL: 1
;        UCSR0B &= ~(1 << UDRIE0); // disable this int
;PCODE: $00000820 VOL: 0
;PCODE: $00000821 VOL: 0
;       }
;PCODE: $00000822 VOL: 0
;#ifdef DEBUG
;TX_CNT++;
;PCODE: $00000823 VOL: 1
;PCODE: $00000824 VOL: 0
;PCODE: $00000825 VOL: 0
;PCODE: $00000826 VOL: 0
;#endif
;}
;PCODE: $00000827 VOL: 0
;PCODE: $00000828 VOL: 0
;PCODE: $00000829 VOL: 0
;PCODE: $0000082A VOL: 0
;
;//обработчик прерывания по завершению передачи
;interrupt [USART1_DRE] void usart1_dre_my(void)  //USART Data Register Empty Interrupt
;{
;PCODE: $0000082B VOL: 0
;PCODE: $0000082C VOL: 0
;uint16_t Tmp = Usart1_txBufTail; // use local variable instead of volatile
;        UDR1 = Usart1_TX_buf[Tmp & (SIZE_BUF_TX - 1)];
;PCODE: $0000082D VOL: 0
;PCODE: $0000082E VOL: 0
;	Tmp -> R16,R17
;PCODE: $0000082F VOL: 0
;PCODE: $00000830 VOL: 0
;PCODE: $00000831 VOL: 0
;PCODE: $00000832 VOL: 0
;PCODE: $00000833 VOL: 1
;PCODE: $00000834 VOL: 0
;PCODE: $00000835 VOL: 0
;       ++Tmp;
;PCODE: $00000836 VOL: 0
;PCODE: $00000837 VOL: 0
;       Usart1_txBufTail = Tmp;
;PCODE: $00000838 VOL: 1
;PCODE: $00000839 VOL: 0
;      if(Tmp == Usart1_txBufHead) // all transmitted
;PCODE: $0000083A VOL: 1
;PCODE: $0000083B VOL: 0
;PCODE: $0000083C VOL: 0
;       {
;       //PORTD.6=0;
;         Usart1_txBufHead = 0; Usart1_txBufTail = 0;
;PCODE: $0000083D VOL: 0
;PCODE: $0000083E VOL: 1
;PCODE: $0000083F VOL: 0
;PCODE: $00000840 VOL: 1
;        UCSR1B &= ~(1 << UDRIE1); // disable this int
;PCODE: $00000841 VOL: 0
;PCODE: $00000842 VOL: 0
;PCODE: $00000843 VOL: 0
;       }
;#ifdef DEBUG
;//TX_CNT++;
;#endif
;}
;PCODE: $00000844 VOL: 0
;PCODE: $00000845 VOL: 0
;PCODE: $00000846 VOL: 0
;PCODE: $00000847 VOL: 0
;PCODE: $00000848 VOL: 0
;/*
;ISR (USART_TXC_vect) {
;	if (TX_buff.head!=TX_buff.tail) {
;		UDR = TX_buff.buff[TX_buff.head];
;		TX_buff.head = (TX_buff.head+1)&(TX_BUFFER_SIZE-1);
;	} else {
;		UART_message = UART_TX_COMPLETE;
;		SendMessageWParam(MSG_UART, &UART_message);
;	}
;}
;*/
;//______________________________________________________________________________
;
;unsigned char USART_Get_rxCount(uint8_t sel) //возвращает колличество символов находящихся в приемном буфере
;{
;PCODE: $00000849 VOL: 0
;PCODE: $0000084A VOL: 0
;return  sel ? Usart1_rxCount : Usart0_rxCount;
;	sel -> Y+0
;PCODE: $0000084B VOL: 0
;PCODE: $0000084C VOL: 0
;PCODE: $0000084D VOL: 0
;PCODE: $0000084E VOL: 1
;PCODE: $0000084F VOL: 0
;PCODE: $00000850 VOL: 0
;PCODE: $00000851 VOL: 1
;PCODE: $00000852 VOL: 0
;PCODE: $00000853 VOL: 0
;PCODE: $00000854 VOL: 0
;PCODE: $00000855 VOL: 0
;}
;PCODE: $00000856 VOL: 0
;
;void USART_FlushRxBuf(uint8_t sel)//"очищает" приемный буфер
;{
;PCODE: $00000857 VOL: 0
;PCODE: $00000858 VOL: 0
;  // uint8_t saved_state;
;   RX_CNT = 0;
;	sel -> Y+0
;PCODE: $00000859 VOL: 0
;PCODE: $0000085A VOL: 1
;__disable_interrupts();
;PCODE: $0000085B VOL: 0
;PCODE: $0000085C VOL: 0
;PCODE: $0000085D VOL: 1
;PCODE: $0000085E VOL: 0
	cli
;PCODE: $0000085F VOL: 0
;PCODE: $00000860 VOL: 0
;PCODE: $00000861 VOL: 0
;PCODE: $00000862 VOL: 0
;PCODE: $00000863 VOL: 0
;if(!sel){
;PCODE: $00000864 VOL: 0
;PCODE: $00000865 VOL: 0
;PCODE: $00000866 VOL: 0
;  Usart0_rxBufTail = 0;
;PCODE: $00000867 VOL: 0
;PCODE: $00000868 VOL: 1
;  Usart0_rxBufHead = 0;
;PCODE: $00000869 VOL: 0
;PCODE: $0000086A VOL: 1
;  Usart0_rxCount = 0;
;PCODE: $0000086B VOL: 0
;PCODE: $0000086C VOL: 1
;} else{
;PCODE: $0000086D VOL: 0
;PCODE: $0000086E VOL: 0
;  Usart1_rxBufTail = 0;
;PCODE: $0000086F VOL: 0
;PCODE: $00000870 VOL: 1
;  Usart1_rxBufHead = 0;
;PCODE: $00000871 VOL: 0
;PCODE: $00000872 VOL: 1
;  Usart1_rxCount = 0;
;PCODE: $00000873 VOL: 0
;PCODE: $00000874 VOL: 1
;}
;PCODE: $00000875 VOL: 0
;__restore_interrupts();
;PCODE: $00000876 VOL: 0
;PCODE: $00000877 VOL: 1
;PCODE: $00000878 VOL: 0
;PCODE: $00000879 VOL: 0
;}
;PCODE: $0000087A VOL: 0
;PCODE: $0000087B VOL: 0
;PCODE: $0000087C VOL: 0
;
;
;char USART_GetChar(uint8_t sel) //чтение буфера
;{
;PCODE: $0000087D VOL: 0
;PCODE: $0000087E VOL: 0
;  unsigned char symbol;
;  uint8_t saved_state;
;if(!sel){
;PCODE: $0000087F VOL: 0
;PCODE: $00000880 VOL: 0
;	sel -> Y+2
;	symbol -> R17
;	saved_state -> R16
;PCODE: $00000881 VOL: 0
;PCODE: $00000882 VOL: 0
;PCODE: $00000883 VOL: 0
;  if (Usart0_rxCount > 0)        //если приемный буфер не пустой
;PCODE: $00000884 VOL: 1
;PCODE: $00000885 VOL: 0
;PCODE: $00000886 VOL: 0
;  {
;    symbol = Usart0_RX_buf[Usart0_rxBufHead];        //прочитать из него символ
;PCODE: $00000887 VOL: 1
;PCODE: $00000888 VOL: 1
;PCODE: $00000889 VOL: 0
;    Usart0_rxBufHead++;                        //инкрементировать индекс головы буфера
;PCODE: $0000088A VOL: 1
;PCODE: $0000088B VOL: 0
;PCODE: $0000088C VOL: 0
;PCODE: $0000088D VOL: 0
;    if (Usart0_rxBufHead == SIZE_BUF_RX) Usart0_rxBufHead = 0;
;PCODE: $0000088E VOL: 1
;PCODE: $0000088F VOL: 0
;PCODE: $00000890 VOL: 0
;PCODE: $00000891 VOL: 0
;PCODE: $00000892 VOL: 1
;__disable_interrupts();
;PCODE: $00000893 VOL: 0
;PCODE: $00000894 VOL: 0
;PCODE: $00000895 VOL: 0
;PCODE: $00000896 VOL: 0
;PCODE: $00000897 VOL: 0
	cli
;PCODE: $00000898 VOL: 0
;PCODE: $00000899 VOL: 0
;PCODE: $0000089A VOL: 0
;PCODE: $0000089B VOL: 0
;PCODE: $0000089C VOL: 0
;    Usart0_rxCount--;                          //уменьшить счетчик символов
;PCODE: $0000089D VOL: 1
;PCODE: $0000089E VOL: 0
;PCODE: $0000089F VOL: 0
;PCODE: $000008A0 VOL: 0
;__restore_interrupts();
;PCODE: $000008A1 VOL: 0
;PCODE: $000008A2 VOL: 0
;PCODE: $000008A3 VOL: 0
;    return symbol;                         //вернуть прочитанный символ
;PCODE: $000008A4 VOL: 0
;PCODE: $000008A5 VOL: 0
;PCODE: $000008A6 VOL: 0
;PCODE: $000008A7 VOL: 0
;PCODE: $000008A8 VOL: 0
;PCODE: $000008A9 VOL: 0
;PCODE: $000008AA VOL: 0
;  }
;  return 0;
;PCODE: $000008AB VOL: 0
;PCODE: $000008AC VOL: 0
;PCODE: $000008AD VOL: 0
;PCODE: $000008AE VOL: 0
;PCODE: $000008AF VOL: 0
;PCODE: $000008B0 VOL: 0
;PCODE: $000008B1 VOL: 0
;PCODE: $000008B2 VOL: 0
;  }
;  else
;PCODE: $000008B3 VOL: 0
;  {
;   if (Usart1_rxCount > 0)        //если приемный буфер не пустой
;PCODE: $000008B4 VOL: 1
;PCODE: $000008B5 VOL: 0
;PCODE: $000008B6 VOL: 0
;  {
;    symbol = Usart1_RX_buf[Usart1_rxBufHead];        //прочитать из него символ
;PCODE: $000008B7 VOL: 1
;PCODE: $000008B8 VOL: 1
;PCODE: $000008B9 VOL: 0
;    Usart1_rxBufHead++;                        //инкрементировать индекс головы буфера
;PCODE: $000008BA VOL: 1
;PCODE: $000008BB VOL: 0
;PCODE: $000008BC VOL: 0
;PCODE: $000008BD VOL: 0
;    if (Usart1_rxBufHead == SIZE_BUF_RX) Usart1_rxBufHead = 0;
;PCODE: $000008BE VOL: 1
;PCODE: $000008BF VOL: 0
;PCODE: $000008C0 VOL: 0
;PCODE: $000008C1 VOL: 0
;PCODE: $000008C2 VOL: 1
;__disable_interrupts();
;PCODE: $000008C3 VOL: 0
;PCODE: $000008C4 VOL: 0
;PCODE: $000008C5 VOL: 0
;PCODE: $000008C6 VOL: 0
;PCODE: $000008C7 VOL: 0
	cli
;PCODE: $000008C8 VOL: 0
;PCODE: $000008C9 VOL: 0
;PCODE: $000008CA VOL: 0
;PCODE: $000008CB VOL: 0
;PCODE: $000008CC VOL: 0
;    Usart1_rxCount--;                          //уменьшить счетчик символов
;PCODE: $000008CD VOL: 1
;PCODE: $000008CE VOL: 0
;PCODE: $000008CF VOL: 0
;PCODE: $000008D0 VOL: 0
;__restore_interrupts();
;PCODE: $000008D1 VOL: 0
;PCODE: $000008D2 VOL: 0
;PCODE: $000008D3 VOL: 0
;    return symbol;                         //вернуть прочитанный символ
;PCODE: $000008D4 VOL: 0
;PCODE: $000008D5 VOL: 0
;PCODE: $000008D6 VOL: 0
;PCODE: $000008D7 VOL: 0
;PCODE: $000008D8 VOL: 0
;PCODE: $000008D9 VOL: 0
;PCODE: $000008DA VOL: 0
;  }
;  return 0;
;PCODE: $000008DB VOL: 0
;PCODE: $000008DC VOL: 0
;PCODE: $000008DD VOL: 0
;PCODE: $000008DE VOL: 0
;PCODE: $000008DF VOL: 0
;PCODE: $000008E0 VOL: 0
;PCODE: $000008E1 VOL: 0
;PCODE: $000008E2 VOL: 0
;  }
;PCODE: $000008E3 VOL: 0
;}
;PCODE: $000008E4 VOL: 0
;PCODE: $000008E5 VOL: 0
;PCODE: $000008E6 VOL: 0
;PCODE: $000008E7 VOL: 0
;PCODE: $000008E8 VOL: 0
;PCODE: $000008E9 VOL: 0
;PCODE: $000008EA VOL: 0
;
;
;
;/*
;  ISR (USART_RXC_vect) {
;	u08 tmp = 0;
;	tmp = UDR;
;	if (((RX_buff.tail - RX_buff.head + 256) & (RX_BUFFER_SIZE-1)) < (RX_BUFFER_SIZE-1)) {
;		RX_buff.buff[RX_buff.tail] = tmp;
;		RX_buff.tail = (RX_buff.tail+1)&(RX_BUFFER_SIZE-1);
;		if (tmp == 0x0D) {										// found end string classifier
;			RX_buff.tail = (RX_buff.tail-1)&(RX_BUFFER_SIZE-1); // remove string end classifier from buffer
;			///RX_buff.buff[RX_buff.tail] = '\0';				// replace string end delimiter with C standard string end
;			UART_message = UART_RX_COMPLETE;
;			SendMessageWParam(MSG_UART, &UART_message);
;		}
;	} else {
;		sys_error = SYS_ERR_RX_BUF_FULL;
;	}
;}
;*/
; interrupt [USART0_RXC] void usart0_rxc(void) //прерывание по завершению приема
;{
;PCODE: $000008EB VOL: 0
;PCODE: $000008EC VOL: 0
;char data;//!
;data =  UDR0;//! read to clear RxC flag!
;PCODE: $000008ED VOL: 0
;	data -> R17
;PCODE: $000008EE VOL: 0
;PCODE: $000008EF VOL: 0
;    if (Usart0_rxCount < SIZE_BUF_RX) //если в буфере еще есть место
;PCODE: $000008F0 VOL: 1
;PCODE: $000008F1 VOL: 0
;PCODE: $000008F2 VOL: 0
;    {
;      //!//Usart0_RX_buf[Usart0_rxBufTail] = UDR;    //считать символ из UDR в буфер
;       Usart0_RX_buf[Usart0_rxBufTail] = data;//!    //считать символ в буфер
;PCODE: $000008F3 VOL: 1
;PCODE: $000008F4 VOL: 1
;PCODE: $000008F5 VOL: 0
;      Usart0_rxBufTail++;                    //увеличить индекс хвоста приемного буфера
;PCODE: $000008F6 VOL: 1
;PCODE: $000008F7 VOL: 0
;PCODE: $000008F8 VOL: 0
;PCODE: $000008F9 VOL: 0
;      Usart0_rxCount++;                      //увеличить счетчик принятых символов
;PCODE: $000008FA VOL: 1
;PCODE: $000008FB VOL: 0
;PCODE: $000008FC VOL: 0
;PCODE: $000008FD VOL: 0
;#warning проверить необходимость следующего куска
;     if (Usart0_rxBufTail == SIZE_BUF_RX)
;PCODE: $000008FE VOL: 1
;PCODE: $000008FF VOL: 0
;PCODE: $00000900 VOL: 0
;      {
;       Usart0_rxBufTail = 0;
;PCODE: $00000901 VOL: 0
;PCODE: $00000902 VOL: 1
;      }
;    }
;PCODE: $00000903 VOL: 0
;#ifdef DEBUG
;RX_CNT++;
;PCODE: $00000904 VOL: 0
;PCODE: $00000905 VOL: 1
;PCODE: $00000906 VOL: 0
;PCODE: $00000907 VOL: 0
;PCODE: $00000908 VOL: 0
;#endif
;}
;PCODE: $00000909 VOL: 0
;PCODE: $0000090A VOL: 0
;PCODE: $0000090B VOL: 0
;PCODE: $0000090C VOL: 0
;
;
;
;
; interrupt [USART1_RXC] void usart1_rxc(void) //прерывание по завершению приема
;{
;PCODE: $0000090D VOL: 0
;PCODE: $0000090E VOL: 0
;char data;//!
;data =  UDR1;//! read to clear RxC flag!
;PCODE: $0000090F VOL: 0
;	data -> R17
;PCODE: $00000910 VOL: 0
;PCODE: $00000911 VOL: 0
;    if (Usart1_rxCount < SIZE_BUF_RX) //если в буфере еще есть место
;PCODE: $00000912 VOL: 1
;PCODE: $00000913 VOL: 0
;PCODE: $00000914 VOL: 0
;    {
;      //!//Usart1_RX_buf[Usart1_rxBufTail] = UDR1;    //считать символ из UDR в буфер
;       Usart1_RX_buf[Usart1_rxBufTail] = data;//!    //считать символ  в буфер
;PCODE: $00000915 VOL: 1
;PCODE: $00000916 VOL: 1
;PCODE: $00000917 VOL: 0
;      Usart1_rxBufTail++;                    //увеличить индекс хвоста приемного буфера
;PCODE: $00000918 VOL: 1
;PCODE: $00000919 VOL: 0
;PCODE: $0000091A VOL: 0
;PCODE: $0000091B VOL: 0
;      Usart1_rxCount++;                      //увеличить счетчик принятых символов
;PCODE: $0000091C VOL: 1
;PCODE: $0000091D VOL: 0
;PCODE: $0000091E VOL: 0
;PCODE: $0000091F VOL: 0
;#warning проверить необходимость следующего куска
;    if (Usart1_rxBufTail == SIZE_BUF_RX)
;PCODE: $00000920 VOL: 1
;PCODE: $00000921 VOL: 0
;PCODE: $00000922 VOL: 0
;      {
;       Usart1_rxBufTail = 0;
;PCODE: $00000923 VOL: 0
;PCODE: $00000924 VOL: 1
;      }
;     }
;PCODE: $00000925 VOL: 0
;}
;PCODE: $00000926 VOL: 0
;PCODE: $00000927 VOL: 0
;PCODE: $00000928 VOL: 0
;PCODE: $00000929 VOL: 0
;PCODE: $0000092A VOL: 0
;
;
;//считает кол-во данных в кольцевом буфере
; uint16_t How_Much_data_in_buf (uint16_t BufTail, uint16_t BufHead)
;{
;PCODE: $0000092B VOL: 0
;PCODE: $0000092C VOL: 0
;    if (BufTail >=  BufHead)
;	BufTail -> Y+2
;	BufHead -> Y+0
;PCODE: $0000092D VOL: 0
;PCODE: $0000092E VOL: 0
;PCODE: $0000092F VOL: 0
;PCODE: $00000930 VOL: 0
;        return (BufTail -  BufHead);
;PCODE: $00000931 VOL: 0
;PCODE: $00000932 VOL: 0
;PCODE: $00000933 VOL: 0
;PCODE: $00000934 VOL: 0
;PCODE: $00000935 VOL: 0
;    else
;PCODE: $00000936 VOL: 0
;        return ((SIZE_BUF_TX -  BufHead) + BufTail);
;PCODE: $00000937 VOL: 0
;PCODE: $00000938 VOL: 0
;PCODE: $00000939 VOL: 0
;PCODE: $0000093A VOL: 0
;PCODE: $0000093B VOL: 0
;PCODE: $0000093C VOL: 0
;PCODE: $0000093D VOL: 0
;}
;PCODE: $0000093E VOL: 0
;PCODE: $0000093F VOL: 0
;PCODE: $00000940 VOL: 0
;PCODE: $00000941 VOL: 0
;
;
;
;/////// Отладочный кусок. Вывод лога работы конечного автомата в буфер памяти, а потом. По окончании работы через UART на волю
;static volatile char WorkLog[512];
;static volatile uint16_t LogIndex = 0;
;
;void WorkLogPutChar(unsigned char symbol){
;PCODE: $00000942 VOL: 0
;PCODE: $00000943 VOL: 0
;__disable_interrupts();
;	symbol -> Y+0
;PCODE: $00000944 VOL: 0
;PCODE: $00000945 VOL: 0
;PCODE: $00000946 VOL: 1
;PCODE: $00000947 VOL: 0
	cli
;PCODE: $00000948 VOL: 0
;PCODE: $00000949 VOL: 0
;PCODE: $0000094A VOL: 0
;PCODE: $0000094B VOL: 0
;PCODE: $0000094C VOL: 0
;if (LogIndex <1023)							// Если лог не переполнен
;PCODE: $0000094D VOL: 1
;PCODE: $0000094E VOL: 0
;PCODE: $0000094F VOL: 0
;{
;		WorkLog[LogIndex]= symbol;			// Пишем статус в лог
;PCODE: $00000950 VOL: 1
;PCODE: $00000951 VOL: 1
;PCODE: $00000952 VOL: 0
;PCODE: $00000953 VOL: 0
;		LogIndex++;
;PCODE: $00000954 VOL: 1
;PCODE: $00000955 VOL: 0
;PCODE: $00000956 VOL: 0
;PCODE: $00000957 VOL: 0
;}
; __restore_interrupts();
;PCODE: $00000958 VOL: 0
;PCODE: $00000959 VOL: 0
;PCODE: $0000095A VOL: 1
;PCODE: $0000095B VOL: 0
;PCODE: $0000095C VOL: 0
;}
;PCODE: $0000095D VOL: 0
;PCODE: $0000095E VOL: 0
;PCODE: $0000095F VOL: 0
;
;void Put_In_LogFl (unsigned char __flash* data){
;PCODE: $00000960 VOL: 0
;PCODE: $00000961 VOL: 0
;  while(*data)
;	*data -> Y+0
;PCODE: $00000962 VOL: 0
;PCODE: $00000963 VOL: 0
;PCODE: $00000964 VOL: 0
;PCODE: $00000965 VOL: 0
;PCODE: $00000966 VOL: 0
;  {
;    WorkLogPutChar(*data++);
;PCODE: $00000967 VOL: 0
;PCODE: $00000968 VOL: 0
;PCODE: $00000969 VOL: 0
;PCODE: $0000096A VOL: 0
;PCODE: $0000096B VOL: 0
;PCODE: $0000096C VOL: 0
;PCODE: $0000096D VOL: 0
;  }
;PCODE: $0000096E VOL: 0
;PCODE: $0000096F VOL: 0
;}
;PCODE: $00000970 VOL: 0
;PCODE: $00000971 VOL: 0
;PCODE: $00000972 VOL: 0
;
;void Put_In_Log (unsigned char * data){
;PCODE: $00000973 VOL: 0
;PCODE: $00000974 VOL: 0
;  while(*data)
;	*data -> Y+0
;PCODE: $00000975 VOL: 0
;PCODE: $00000976 VOL: 0
;PCODE: $00000977 VOL: 0
;PCODE: $00000978 VOL: 0
;PCODE: $00000979 VOL: 0
;  {
;    WorkLogPutChar(*data++);
;PCODE: $0000097A VOL: 0
;PCODE: $0000097B VOL: 0
;PCODE: $0000097C VOL: 0
;PCODE: $0000097D VOL: 0
;PCODE: $0000097E VOL: 0
;  }
;PCODE: $0000097F VOL: 0
;PCODE: $00000980 VOL: 0
;}
;PCODE: $00000981 VOL: 0
;PCODE: $00000982 VOL: 0
;PCODE: $00000983 VOL: 0
;/////////////
;
;
;
;
;
;
;#include "parser.h"
;
;char buf[SIZE_RECEIVE_BUF];
;char *argv[AMOUNT_PAR];
;uint8_t argc;
;
;uint8_t i = 0;
;uint8_t flag = 0;
;
;void PARSER_Init(void)
;{
;PCODE: $00000984 VOL: 0
;PCODE: $00000985 VOL: 0
;  argc = 0;
;PCODE: $00000986 VOL: 0
;  argv[0] = buf;
;PCODE: $00000987 VOL: 0
;PCODE: $00000988 VOL: 0
;  flag = FALSE;
;PCODE: $00000989 VOL: 0
;  i = 0;
;PCODE: $0000098A VOL: 0
;}
;PCODE: $0000098B VOL: 0
;PCODE: $0000098C VOL: 0
;
;void PARS_Parser(char symbol)
;{
;PCODE: $0000098D VOL: 0
;PCODE: $0000098E VOL: 0
;   if (symbol !='\r'){               //'\r' //end of string
;	symbol -> Y+0
;PCODE: $0000098F VOL: 0
;PCODE: $00000990 VOL: 0
;PCODE: $00000991 VOL: 0
;     if (i < SIZE_RECEIVE_BUF - 1){
;PCODE: $00000992 VOL: 0
;PCODE: $00000993 VOL: 0
;PCODE: $00000994 VOL: 0
;        if (symbol != ' '){
;PCODE: $00000995 VOL: 0
;PCODE: $00000996 VOL: 0
;PCODE: $00000997 VOL: 0
;           if (!argc){
;PCODE: $00000998 VOL: 0
;PCODE: $00000999 VOL: 0
;              argv[0] = buf;
;PCODE: $0000099A VOL: 0
;PCODE: $0000099B VOL: 0
;              argc++;
;PCODE: $0000099C VOL: 0
;           }
;
;           if (flag){
;PCODE: $0000099D VOL: 0
;PCODE: $0000099E VOL: 0
;PCODE: $0000099F VOL: 0
;              if (argc < AMOUNT_PAR){
;PCODE: $000009A0 VOL: 0
;PCODE: $000009A1 VOL: 0
;PCODE: $000009A2 VOL: 0
;                 argv[argc] = &buf[i];
;PCODE: $000009A3 VOL: 0
;PCODE: $000009A4 VOL: 0
;PCODE: $000009A5 VOL: 0
;PCODE: $000009A6 VOL: 0
;PCODE: $000009A7 VOL: 0
;PCODE: $000009A8 VOL: 0
;PCODE: $000009A9 VOL: 0
;PCODE: $000009AA VOL: 0
;PCODE: $000009AB VOL: 0
;                 argc++;
;PCODE: $000009AC VOL: 0
;              }
;              flag = FALSE;
;PCODE: $000009AD VOL: 0
;PCODE: $000009AE VOL: 0
;            }
;
;            buf[i] = symbol;
;PCODE: $000009AF VOL: 0
;PCODE: $000009B0 VOL: 0
;PCODE: $000009B1 VOL: 0
;PCODE: $000009B2 VOL: 0
;PCODE: $000009B3 VOL: 0
;PCODE: $000009B4 VOL: 0
;            i++;
;PCODE: $000009B5 VOL: 0
;        }
;        else{                 // "space" - is divider
;PCODE: $000009B6 VOL: 0
;PCODE: $000009B7 VOL: 0
;           if (!flag){
;PCODE: $000009B8 VOL: 0
;PCODE: $000009B9 VOL: 0
;              buf[i] = 0;
;PCODE: $000009BA VOL: 0
;PCODE: $000009BB VOL: 0
;PCODE: $000009BC VOL: 0
;PCODE: $000009BD VOL: 0
;PCODE: $000009BE VOL: 0
;              i++;
;PCODE: $000009BF VOL: 0
;              flag = TRUE;
;PCODE: $000009C0 VOL: 0
;PCODE: $000009C1 VOL: 0
;           }
;        }
;PCODE: $000009C2 VOL: 0
;PCODE: $000009C3 VOL: 0
;     }
;     buf[i] = 0;
;PCODE: $000009C4 VOL: 0
;PCODE: $000009C5 VOL: 0
;PCODE: $000009C6 VOL: 0
;PCODE: $000009C7 VOL: 0
;PCODE: $000009C8 VOL: 0
;PCODE: $000009C9 VOL: 0
;     return;
;PCODE: $000009CA VOL: 0
;PCODE: $000009CB VOL: 0
;   }
;   else{
;PCODE: $000009CC VOL: 0
;      buf[i] = 0;
;PCODE: $000009CD VOL: 0
;PCODE: $000009CE VOL: 0
;PCODE: $000009CF VOL: 0
;PCODE: $000009D0 VOL: 0
;PCODE: $000009D1 VOL: 0
;        if (argc)
;PCODE: $000009D2 VOL: 0
;PCODE: $000009D3 VOL: 0
;           {
;                PARS_Handler(argc, argv);
;PCODE: $000009D4 VOL: 0
;PCODE: $000009D5 VOL: 0
;PCODE: $000009D6 VOL: 0
;PCODE: $000009D7 VOL: 0
;           }
;      //   else{
;                  //сюда можно что-то добавить  ");
;       //      }
;      argc = 0;
;PCODE: $000009D8 VOL: 0
;PCODE: $000009D9 VOL: 0
;      flag = FALSE;
;PCODE: $000009DA VOL: 0
;      i = 0;
;PCODE: $000009DB VOL: 0
;   }
;PCODE: $000009DC VOL: 0
;}
;PCODE: $000009DD VOL: 0
;PCODE: $000009DE VOL: 0
;PCODE: $000009DF VOL: 0
;
;#ifdef  __GNUC__
;
;uint8_t PARS_EqualStrFl(char *s1, char const *s2)
;{
;  uint8_t i = 0;
;
;  while(s1[i] == pgm_read_byte(&s2[i]) && s1[i] != '\0' && pgm_read_byte(&s2[i]) != '\0')
;  {
;     i++;
;  }
;  if (s1[i] =='\0' && pgm_read_byte(&s2[i]) == '\0')
;  {
;     return TRUE;
;  }
;  else
;  {
;     return FALSE;
;  }
;}
;
;#else
;
;#warning standart strcmpf req less memory
;uint8_t PARS_EqualStrFl(char *s1, char __flash *s2)
;{
;PCODE: $000009E0 VOL: 0
;PCODE: $000009E1 VOL: 0
;  uint8_t i = 0;
;
;  while(s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
;PCODE: $000009E2 VOL: 0
;	*s1 -> Y+3
;	*s2 -> Y+1
;	i -> R17
;PCODE: $000009E3 VOL: 0
;PCODE: $000009E4 VOL: 0
;PCODE: $000009E5 VOL: 0
;PCODE: $000009E6 VOL: 0
;PCODE: $000009E7 VOL: 0
;PCODE: $000009E8 VOL: 0
;PCODE: $000009E9 VOL: 0
;PCODE: $000009EA VOL: 0
;PCODE: $000009EB VOL: 0
;PCODE: $000009EC VOL: 0
;PCODE: $000009ED VOL: 0
;PCODE: $000009EE VOL: 0
;PCODE: $000009EF VOL: 0
;PCODE: $000009F0 VOL: 0
;PCODE: $000009F1 VOL: 0
;PCODE: $000009F2 VOL: 0
;PCODE: $000009F3 VOL: 0
;PCODE: $000009F4 VOL: 0
;PCODE: $000009F5 VOL: 0
;PCODE: $000009F6 VOL: 0
;PCODE: $000009F7 VOL: 0
;PCODE: $000009F8 VOL: 0
;PCODE: $000009F9 VOL: 0
;PCODE: $000009FA VOL: 0
;PCODE: $000009FB VOL: 0
;PCODE: $000009FC VOL: 0
;PCODE: $000009FD VOL: 0
;PCODE: $000009FE VOL: 0
;PCODE: $000009FF VOL: 0
;  {
;     i++;
;PCODE: $00000A00 VOL: 0
;PCODE: $00000A01 VOL: 0
;  }
;PCODE: $00000A02 VOL: 0
;PCODE: $00000A03 VOL: 0
;  if (s1[i] =='\0' && s2[i] == '\0')
;PCODE: $00000A04 VOL: 0
;PCODE: $00000A05 VOL: 0
;PCODE: $00000A06 VOL: 0
;PCODE: $00000A07 VOL: 0
;PCODE: $00000A08 VOL: 0
;PCODE: $00000A09 VOL: 0
;PCODE: $00000A0A VOL: 0
;PCODE: $00000A0B VOL: 0
;PCODE: $00000A0C VOL: 0
;PCODE: $00000A0D VOL: 0
;PCODE: $00000A0E VOL: 0
;PCODE: $00000A0F VOL: 0
;PCODE: $00000A10 VOL: 0
;PCODE: $00000A11 VOL: 0
;PCODE: $00000A12 VOL: 0
;PCODE: $00000A13 VOL: 0
;  {
;     return TRUE;
;PCODE: $00000A14 VOL: 0
;PCODE: $00000A15 VOL: 0
;PCODE: $00000A16 VOL: 0
;PCODE: $00000A17 VOL: 0
;PCODE: $00000A18 VOL: 0
;  }
;  else
;PCODE: $00000A19 VOL: 0
;  {
;     return FALSE;
;PCODE: $00000A1A VOL: 0
;PCODE: $00000A1B VOL: 0
;PCODE: $00000A1C VOL: 0
;PCODE: $00000A1D VOL: 0
;PCODE: $00000A1E VOL: 0
;  }
;PCODE: $00000A1F VOL: 0
;}
;PCODE: $00000A20 VOL: 0
;PCODE: $00000A21 VOL: 0
;PCODE: $00000A22 VOL: 0
;PCODE: $00000A23 VOL: 0
;PCODE: $00000A24 VOL: 0
;
;#endif
;
;#warning standart strcmp req less memory
;uint8_t PARS_EqualStr(char *s1, char *s2)
;{
;PCODE: $00000A25 VOL: 0
;PCODE: $00000A26 VOL: 0
;  uint8_t i = 0;
;
;  while(s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
;PCODE: $00000A27 VOL: 0
;	*s1 -> Y+3
;	*s2 -> Y+1
;	i -> R17
;PCODE: $00000A28 VOL: 0
;PCODE: $00000A29 VOL: 0
;PCODE: $00000A2A VOL: 0
;PCODE: $00000A2B VOL: 0
;PCODE: $00000A2C VOL: 0
;PCODE: $00000A2D VOL: 0
;PCODE: $00000A2E VOL: 0
;PCODE: $00000A2F VOL: 0
;PCODE: $00000A30 VOL: 0
;PCODE: $00000A31 VOL: 0
;PCODE: $00000A32 VOL: 0
;PCODE: $00000A33 VOL: 0
;PCODE: $00000A34 VOL: 0
;PCODE: $00000A35 VOL: 0
;PCODE: $00000A36 VOL: 0
;PCODE: $00000A37 VOL: 0
;PCODE: $00000A38 VOL: 0
;PCODE: $00000A39 VOL: 0
;PCODE: $00000A3A VOL: 0
;PCODE: $00000A3B VOL: 0
;PCODE: $00000A3C VOL: 0
;PCODE: $00000A3D VOL: 0
;PCODE: $00000A3E VOL: 0
;PCODE: $00000A3F VOL: 0
;PCODE: $00000A40 VOL: 0
;  {
;     i++;
;PCODE: $00000A41 VOL: 0
;PCODE: $00000A42 VOL: 0
;  }
;PCODE: $00000A43 VOL: 0
;PCODE: $00000A44 VOL: 0
;  if (s1[i] =='\0' && s2[i] == '\0')
;PCODE: $00000A45 VOL: 0
;PCODE: $00000A46 VOL: 0
;PCODE: $00000A47 VOL: 0
;PCODE: $00000A48 VOL: 0
;PCODE: $00000A49 VOL: 0
;PCODE: $00000A4A VOL: 0
;PCODE: $00000A4B VOL: 0
;PCODE: $00000A4C VOL: 0
;PCODE: $00000A4D VOL: 0
;PCODE: $00000A4E VOL: 0
;PCODE: $00000A4F VOL: 0
;PCODE: $00000A50 VOL: 0
;PCODE: $00000A51 VOL: 0
;PCODE: $00000A52 VOL: 0
;  {
;     return TRUE;
;PCODE: $00000A53 VOL: 0
;PCODE: $00000A54 VOL: 0
;PCODE: $00000A55 VOL: 0
;PCODE: $00000A56 VOL: 0
;PCODE: $00000A57 VOL: 0
;  }
;  else
;PCODE: $00000A58 VOL: 0
;  {
;     return FALSE;
;PCODE: $00000A59 VOL: 0
;PCODE: $00000A5A VOL: 0
;PCODE: $00000A5B VOL: 0
;PCODE: $00000A5C VOL: 0
;PCODE: $00000A5D VOL: 0
;  }
;PCODE: $00000A5E VOL: 0
;}
;PCODE: $00000A5F VOL: 0
;PCODE: $00000A60 VOL: 0
;PCODE: $00000A61 VOL: 0
;PCODE: $00000A62 VOL: 0
;PCODE: $00000A63 VOL: 0
;
;uint8_t PARS_StrToUchar(char *s)
;{
;PCODE: $00000A64 VOL: 0
;PCODE: $00000A65 VOL: 0
;   uint8_t value = 0;
;  // while(*s == '0'){s++;} // For what?
;   while(*s)
;PCODE: $00000A66 VOL: 0
;	*s -> Y+1
;	value -> R17
;PCODE: $00000A67 VOL: 0
;PCODE: $00000A68 VOL: 0
;PCODE: $00000A69 VOL: 0
;PCODE: $00000A6A VOL: 0
;PCODE: $00000A6B VOL: 0
;PCODE: $00000A6C VOL: 0
;PCODE: $00000A6D VOL: 0
;   {
;      value += (*s - 0x30);
;PCODE: $00000A6E VOL: 0
;PCODE: $00000A6F VOL: 0
;PCODE: $00000A70 VOL: 0
;PCODE: $00000A71 VOL: 0
;PCODE: $00000A72 VOL: 0
;      s++;
;PCODE: $00000A73 VOL: 0
;PCODE: $00000A74 VOL: 0
;PCODE: $00000A75 VOL: 0
;      if (*s){
;PCODE: $00000A76 VOL: 0
;PCODE: $00000A77 VOL: 0
;PCODE: $00000A78 VOL: 0
;PCODE: $00000A79 VOL: 0
;         value *= 10;
;PCODE: $00000A7A VOL: 0
;PCODE: $00000A7B VOL: 0
;PCODE: $00000A7C VOL: 0
;      }
;   };
;PCODE: $00000A7D VOL: 0
;PCODE: $00000A7E VOL: 0
;PCODE: $00000A7F VOL: 0
;
;  return value;
;PCODE: $00000A80 VOL: 0
;PCODE: $00000A81 VOL: 0
;PCODE: $00000A82 VOL: 0
;PCODE: $00000A83 VOL: 0
;PCODE: $00000A84 VOL: 0
;}
;PCODE: $00000A85 VOL: 0
;
;uint16_t PARS_StrToUint(char *s)
;{
;PCODE: $00000A86 VOL: 0
;PCODE: $00000A87 VOL: 0
;   uint16_t value = 0;
;
;   //while(*s == '0'){s++;}
;
;   while(*s)
;PCODE: $00000A88 VOL: 0
;PCODE: $00000A89 VOL: 0
;	*s -> Y+2
;	value -> R16,R17
;PCODE: $00000A8A VOL: 0
;PCODE: $00000A8B VOL: 0
;PCODE: $00000A8C VOL: 0
;PCODE: $00000A8D VOL: 0
;PCODE: $00000A8E VOL: 0
;PCODE: $00000A8F VOL: 0
;PCODE: $00000A90 VOL: 0
;   {
;      value += (*s - 0x30);
;PCODE: $00000A91 VOL: 0
;PCODE: $00000A92 VOL: 0
;PCODE: $00000A93 VOL: 0
;PCODE: $00000A94 VOL: 0
;PCODE: $00000A95 VOL: 0
;PCODE: $00000A96 VOL: 0
;      s++;
;PCODE: $00000A97 VOL: 0
;PCODE: $00000A98 VOL: 0
;PCODE: $00000A99 VOL: 0
;      if (*s){
;PCODE: $00000A9A VOL: 0
;PCODE: $00000A9B VOL: 0
;PCODE: $00000A9C VOL: 0
;PCODE: $00000A9D VOL: 0
;         value *= 10;
;PCODE: $00000A9E VOL: 0
;PCODE: $00000A9F VOL: 0
;PCODE: $00000AA0 VOL: 0
;      }
;   };
;PCODE: $00000AA1 VOL: 0
;PCODE: $00000AA2 VOL: 0
;PCODE: $00000AA3 VOL: 0
;
;  return value;
;PCODE: $00000AA4 VOL: 0
;PCODE: $00000AA5 VOL: 0
;PCODE: $00000AA6 VOL: 0
;PCODE: $00000AA7 VOL: 0
;PCODE: $00000AA8 VOL: 0
;PCODE: $00000AA9 VOL: 0
;PCODE: $00000AAA VOL: 0
;}
;PCODE: $00000AAB VOL: 0
;//***************************************************************************
;//
;//  Author(s)...: Vlad
;//
;//  Target(s)...: Mega
;//
;//  Compiler....:
;//
;//  Description.: Драйвер SPI
;//
;//  Data........: 11.2.14
;//
;//***************************************************************************
;#include "spi.h"
;
;#include "RTOS/EERTOS.h"
;#include "RTOS/EERTOSHAL.h"
; #include "D_Tasks/task_list.h"
; /*
; Забирать значение из SPDR можно в прерывании таймера!
; */
;#warning заменить на структуру
;//передающий буфер
;static volatile char Spi0_TX_buf[SIZE_SPI_BUF_TX];
;static volatile uint16_t Spi0_txBufTail = 0;
;static volatile uint16_t Spi0_txBufHead = 0;
;
;static volatile char Spi1_TX_buf[SIZE_SPI_BUF_TX];
;static volatile uint16_t Spi1_txBufTail = 0;
;static volatile uint16_t Spi1_txBufHead = 0;
; #warning  Spi0_txCount not used
;
;
;//приемный буфер
;static volatile char Spi0_RX_buf[SIZE_SPI_BUF_RX];
;static volatile uint16_t Spi0_rxBufTail = 0;
;static volatile uint16_t Spi0_rxBufHead = 0;
;static volatile uint16_t Spi0_rxCount = 0;
;
;static volatile char Spi1_RX_buf[SIZE_SPI_BUF_RX];
;static volatile uint16_t Spi1_rxBufTail = 0;
;static volatile uint16_t Spi1_rxBufHead = 0;
;static volatile uint16_t Spi1_rxCount = 0;
;
;bool TX_flag = 0;
;bool RX_flag = 0;
;
;
;void SpiTxBufOvf_Handler(void){
;PCODE: $00000AAC VOL: 0
;PCODE: $00000AAD VOL: 0
;PORTD.7=0;
;PCODE: $00000AAE VOL: 0
;PCODE: $00000AAF VOL: 0
;}
;PCODE: $00000AB0 VOL: 0
;PCODE: $00000AB1 VOL: 0
;
;void SPI_FlushTxBuf(uint8_t sel) //"очищает" передающий буфер
;{
;PCODE: $00000AB2 VOL: 0
;PCODE: $00000AB3 VOL: 0
;  uint8_t saved_state;
;__disable_interrupts();
;PCODE: $00000AB4 VOL: 0
;	sel -> Y+1
;	saved_state -> R17
;PCODE: $00000AB5 VOL: 0
;PCODE: $00000AB6 VOL: 0
;PCODE: $00000AB7 VOL: 0
;PCODE: $00000AB8 VOL: 0
	cli
;PCODE: $00000AB9 VOL: 0
;PCODE: $00000ABA VOL: 0
;PCODE: $00000ABB VOL: 0
;PCODE: $00000ABC VOL: 0
;PCODE: $00000ABD VOL: 0
;
; switch (sel)
;PCODE: $00000ABE VOL: 0
; {
;   case SPI_0:
;PCODE: $00000ABF VOL: 0
;PCODE: $00000AC0 VOL: 0
;Spi_0_flush:
;PCODE: $00000AC1 VOL: 0
;  Spi0_txBufTail = 0;
;PCODE: $00000AC2 VOL: 0
;PCODE: $00000AC3 VOL: 1
;  Spi0_txBufHead = 0;
;PCODE: $00000AC4 VOL: 0
;PCODE: $00000AC5 VOL: 1
;   break;
;PCODE: $00000AC6 VOL: 0
;   case SPI_1:
;PCODE: $00000AC7 VOL: 0
;PCODE: $00000AC8 VOL: 0
;PCODE: $00000AC9 VOL: 0
;
;   break;
;PCODE: $00000ACA VOL: 0
;     default:
;PCODE: $00000ACB VOL: 0
; goto Spi_0_flush;
;PCODE: $00000ACC VOL: 0
;   break;
;PCODE: $00000ACD VOL: 0
;}
;PCODE: $00000ACE VOL: 0
;__restore_interrupts();
;PCODE: $00000ACF VOL: 0
;PCODE: $00000AD0 VOL: 0
;PCODE: $00000AD1 VOL: 0
;}
;PCODE: $00000AD2 VOL: 0
;PCODE: $00000AD3 VOL: 0
;PCODE: $00000AD4 VOL: 0
;PCODE: $00000AD5 VOL: 0
;PCODE: $00000AD6 VOL: 0
;
;
;///////////////////////////////////////////////////////////////
;////////////////////SOFTWARE SPI///////////////////////////////
;
;#warning наполовину софтовый!
;/*инициализация SPI*/
;void Soft_SPI_Master_Init(void)
;{
;PCODE: $00000AD7 VOL: 0
;PCODE: $00000AD8 VOL: 0
;  /*настройка портов ввода-вывода
;  все выводы, кроме MISO выходы*/
;  SPI_DDRX = (1<<SPI_MOSI)|(1<<SPI_SCK)|(1<<SPI_SS)|(0<<SPI_MISO);
;PCODE: $00000AD9 VOL: 0
;PCODE: $00000ADA VOL: 0
;  SPI_PORTX = (1<<SPI_MOSI)|(1<<SPI_SCK)|(1<<SPI_SS)|(1<<SPI_MISO);
;PCODE: $00000ADB VOL: 0
;PCODE: $00000ADC VOL: 0
;
;  /*разрешение spi,старший бит вперед,мастер, режим 0*/
;  SPCR = (1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(1<<SPR1)|(0<<SPR0);
;PCODE: $00000ADD VOL: 0
;PCODE: $00000ADE VOL: 0
; // SPSR = (0<<SPI2X);
; SPCR = (1<<SPIE); /* Enable SPI, Interrupt */
;PCODE: $00000ADF VOL: 0
;PCODE: $00000AE0 VOL: 0
;}
;PCODE: $00000AE1 VOL: 0
;PCODE: $00000AE2 VOL: 0
;
;////////////////////SOFTWARE SPI///////////////////////////////
;///////////////////////////////////////////////////////////////
;
;
;
;
;
;
;///////////////////////////////////////////////////////////////
;////////////////////HARDWARE SPI///////////////////////////////
;
;//---------------MASTER-----------------//
;
;void Hard_SPI_Master_Init_default(void)
;{
;PCODE: $00000AE3 VOL: 0
;PCODE: $00000AE4 VOL: 0
;SPCR = 0; /* Set MOSI and SCK output, all others input */
;PCODE: $00000AE5 VOL: 0
;PCODE: $00000AE6 VOL: 0
;  DDR_SPI = (1<<_MOSI)|(1<<_SCK)|(1<<_SS)|(0<<_MISO);;
;PCODE: $00000AE7 VOL: 0
;PCODE: $00000AE8 VOL: 0
;  PORT_SPI = (1<<_MOSI)|(1<<_SCK)|(1<<_SS)|(1<<_MISO);
;PCODE: $00000AE9 VOL: 0
;PCODE: $00000AEA VOL: 0
;/* Enable SPI, Master, set clock rate fck/16, Interrupt */
;
;SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
;PCODE: $00000AEB VOL: 0
;PCODE: $00000AEC VOL: 0
;//SPCR = (1<<SPIE)|(1<<SPE); /* Enable SPI, Interrupt */  в прерывание не переходит!
;}
;PCODE: $00000AED VOL: 0
;PCODE: $00000AEE VOL: 0
;
;
;void Hard_SPI_Master_Init(bool phase, bool polarity, uint8_t prescaller)
;{
;PCODE: $00000AEF VOL: 0
;PCODE: $00000AF0 VOL: 0
;SPCR = 0;
;	phase -> Y+2
;	polarity -> Y+1
;	prescaller -> Y+0
;PCODE: $00000AF1 VOL: 0
;PCODE: $00000AF2 VOL: 0
;/* Set MOSI and SCK output, all others input */
;  DDR_SPI = (1<<_MOSI)|(1<<_SCK)|(1<<_SS);  DDR_SPI &=~(1<<_MISO);
;PCODE: $00000AF3 VOL: 0
;PCODE: $00000AF4 VOL: 0
;PCODE: $00000AF5 VOL: 0
;PCODE: $00000AF6 VOL: 0
;  PORT_SPI = (1<<_MOSI)|(1<<_SCK)|(1<<_SS);//|(1<<_MISO);//Лучше с подтяжкой!
;PCODE: $00000AF7 VOL: 0
;PCODE: $00000AF8 VOL: 0
;
;  SPCR = (phase<<CPHA) | (polarity<<CPOL);
;PCODE: $00000AF9 VOL: 0
;PCODE: $00000AFA VOL: 0
;PCODE: $00000AFB VOL: 0
;PCODE: $00000AFC VOL: 0
;PCODE: $00000AFD VOL: 0
;PCODE: $00000AFE VOL: 0
;PCODE: $00000AFF VOL: 0
;
;        switch(prescaller)  //prescaller
;PCODE: $00000B00 VOL: 0
;        {
;          case 2:
;PCODE: $00000B01 VOL: 0
;PCODE: $00000B02 VOL: 0
;           SPSR = (1<<SPI2X);
;PCODE: $00000B03 VOL: 0
;PCODE: $00000B04 VOL: 0
;          break;
;PCODE: $00000B05 VOL: 0
;          case 4:
;PCODE: $00000B06 VOL: 0
;PCODE: $00000B07 VOL: 0
;PCODE: $00000B08 VOL: 0
;           SPCR = (0<<SPR1) | (0<<SPR0);
;PCODE: $00000B09 VOL: 0
;PCODE: $00000B0A VOL: 0
;          break;
;PCODE: $00000B0B VOL: 0
;          case 8:
;PCODE: $00000B0C VOL: 0
;PCODE: $00000B0D VOL: 0
;PCODE: $00000B0E VOL: 0
;           SPSR |= (1<<SPI2X);
;PCODE: $00000B0F VOL: 0
;PCODE: $00000B10 VOL: 0
;           SPCR |= (1<<SPR0);
;PCODE: $00000B11 VOL: 0
;PCODE: $00000B12 VOL: 0
;          break;
;PCODE: $00000B13 VOL: 0
;          case 16:
;PCODE: $00000B14 VOL: 0
;PCODE: $00000B15 VOL: 0
;PCODE: $00000B16 VOL: 0
;            SPCR = (1<<SPR0);
;PCODE: $00000B17 VOL: 0
;PCODE: $00000B18 VOL: 0
;          break;
;PCODE: $00000B19 VOL: 0
;          case 32:
;PCODE: $00000B1A VOL: 0
;PCODE: $00000B1B VOL: 0
;PCODE: $00000B1C VOL: 0
;           SPSR = (1<<SPI2X);
;PCODE: $00000B1D VOL: 0
;PCODE: $00000B1E VOL: 0
;           SPCR = (1<<SPR1);
;PCODE: $00000B1F VOL: 0
;PCODE: $00000B20 VOL: 0
;          break;
;PCODE: $00000B21 VOL: 0
;          case 64:
;PCODE: $00000B22 VOL: 0
;PCODE: $00000B23 VOL: 0
;PCODE: $00000B24 VOL: 0
;           SPCR = (1<<SPR0);
;PCODE: $00000B25 VOL: 0
;PCODE: $00000B26 VOL: 0
;          break;
;PCODE: $00000B27 VOL: 0
;          case 128:
;PCODE: $00000B28 VOL: 0
;PCODE: $00000B29 VOL: 0
;PCODE: $00000B2A VOL: 0
;            SPCR = (1<<SPR0) | (1<<SPR0);
;PCODE: $00000B2B VOL: 0
;PCODE: $00000B2C VOL: 0
;          break;
;PCODE: $00000B2D VOL: 0
;          default:
;PCODE: $00000B2E VOL: 0
;            SPCR = (1<<SPR0);
;PCODE: $00000B2F VOL: 0
;PCODE: $00000B30 VOL: 0
;          break;
;PCODE: $00000B31 VOL: 0
;        }
;PCODE: $00000B32 VOL: 0
;SPCR = (1<<SPE)|(1<<MSTR);
;PCODE: $00000B33 VOL: 0
;PCODE: $00000B34 VOL: 0
;}
;PCODE: $00000B35 VOL: 0
;PCODE: $00000B36 VOL: 0
;PCODE: $00000B37 VOL: 0
;
;/*
;sel - number of spi(0 - hardware)
;mode - master/slave
;*/
;
;void SPI_init(char sel, bool mode, bool phase, bool polarity, uint8_t prescaller){
;PCODE: $00000B38 VOL: 0
;PCODE: $00000B39 VOL: 0
; switch (sel)
;	sel -> Y+4
;	mode -> Y+3
;	phase -> Y+2
;	polarity -> Y+1
;	prescaller -> Y+0
;PCODE: $00000B3A VOL: 0
; {
;  case SPI_0:
;PCODE: $00000B3B VOL: 0
;PCODE: $00000B3C VOL: 0
;   SPCR = 0;
;PCODE: $00000B3D VOL: 0
;PCODE: $00000B3E VOL: 0
;   SPSR = 0;
;PCODE: $00000B3F VOL: 0
;PCODE: $00000B40 VOL: 0
;     if(mode == SPI_MASTER)
;PCODE: $00000B41 VOL: 0
;PCODE: $00000B42 VOL: 0
;PCODE: $00000B43 VOL: 0
;     {
;       Hard_SPI_Master_Init(phase, polarity, prescaller);
;PCODE: $00000B44 VOL: 0
;PCODE: $00000B45 VOL: 0
;PCODE: $00000B46 VOL: 0
;PCODE: $00000B47 VOL: 0
;PCODE: $00000B48 VOL: 0
;PCODE: $00000B49 VOL: 0
;PCODE: $00000B4A VOL: 0
;     }
;     else //SLAVE
;PCODE: $00000B4B VOL: 0
;PCODE: $00000B4C VOL: 0
;     {
;       Hard_SPI_Slave_Init();
;PCODE: $00000B4D VOL: 0
;     }
;PCODE: $00000B4E VOL: 0
;  break;
;PCODE: $00000B4F VOL: 0
;  /*
;   case SPI_1:  //soft spi
;   break;
;  */
;  default:
;PCODE: $00000B50 VOL: 0
;  Hard_SPI_Master_Init_default();
;PCODE: $00000B51 VOL: 0
;  break;
;PCODE: $00000B52 VOL: 0
; }
;PCODE: $00000B53 VOL: 0
;}
;PCODE: $00000B54 VOL: 0
;PCODE: $00000B55 VOL: 0
;PCODE: $00000B56 VOL: 0
;
;#warning can be optimized!
;void SPI_RW_Buf(uint8_t num, uint8_t *data_tx, uint8_t *data_rx)   //SPI write-read
;{
;PCODE: $00000B57 VOL: 0
;PCODE: $00000B58 VOL: 0
;uint8_t i=0; //char data;
;   SPI_PORTX &= ~(1<<SPI_SS);
;PCODE: $00000B59 VOL: 0
;	num -> Y+5
;	*data_tx -> Y+3
;	*data_rx -> Y+1
;	i -> R17
;PCODE: $00000B5A VOL: 0
;PCODE: $00000B5B VOL: 0
;PCODE: $00000B5C VOL: 0
;PCODE: $00000B5D VOL: 0
;/*
;while(num)
;{
;      SPDR = data_tx[i];  data_tx[i] = 0;
;      while(!(SPSR & (1<<SPIF)));
;      data_rx[i] = SPDR;
;      // *data_tx++; *data_rx++;
;       --num;
;        i++;
;}  */
;
;
; while(*data_tx)
;PCODE: $00000B5E VOL: 0
;PCODE: $00000B5F VOL: 0
;PCODE: $00000B60 VOL: 0
;PCODE: $00000B61 VOL: 0
;PCODE: $00000B62 VOL: 0
;  {
;      SPDR = *data_tx++;  //data_tx[i] = 0;
;PCODE: $00000B63 VOL: 0
;PCODE: $00000B64 VOL: 0
;PCODE: $00000B65 VOL: 0
;PCODE: $00000B66 VOL: 0
;      while(!(SPSR & (1<<SPIF)));
;PCODE: $00000B67 VOL: 0
;PCODE: $00000B68 VOL: 0
;PCODE: $00000B69 VOL: 0
;PCODE: $00000B6A VOL: 0
;PCODE: $00000B6B VOL: 0
;PCODE: $00000B6C VOL: 0
;      if(i<SIZE_SPI_BUF_RX){data_rx[i] = SPDR;}
;PCODE: $00000B6D VOL: 0
;PCODE: $00000B6E VOL: 0
;PCODE: $00000B6F VOL: 0
;PCODE: $00000B70 VOL: 0
;PCODE: $00000B71 VOL: 0
;PCODE: $00000B72 VOL: 0
;PCODE: $00000B73 VOL: 0
;      i++;
;PCODE: $00000B74 VOL: 0
;PCODE: $00000B75 VOL: 0
;PCODE: $00000B76 VOL: 0
;  }
;PCODE: $00000B77 VOL: 0
;PCODE: $00000B78 VOL: 0
;   SPI_PORTX |= (1<<SPI_SS);
;PCODE: $00000B79 VOL: 0
;PCODE: $00000B7A VOL: 0
;  SetTask(Task_SPI_ClrBuf); //починить
;PCODE: $00000B7B VOL: 0
;PCODE: $00000B7C VOL: 0
;PCODE: $00000B7D VOL: 0
;}
;PCODE: $00000B7E VOL: 0
;PCODE: $00000B7F VOL: 0
;PCODE: $00000B80 VOL: 0
;PCODE: $00000B81 VOL: 0
;PCODE: $00000B82 VOL: 0
;//---------------END_MASTER-----------------//
;
;
;//---------------SLAVE------------------------//
;void Hard_SPI_Slave_Init(void)
;{
;PCODE: $00000B83 VOL: 0
;PCODE: $00000B84 VOL: 0
;SPCR = 0;
;PCODE: $00000B85 VOL: 0
;PCODE: $00000B86 VOL: 0
;DDR_SPI = (1<<_MISO);/* Set MISO output, all others input */
;PCODE: $00000B87 VOL: 0
;PCODE: $00000B88 VOL: 0
;SPCR = (1<<SPE);/* Enable SPI */
;PCODE: $00000B89 VOL: 0
;PCODE: $00000B8A VOL: 0
;}
;PCODE: $00000B8B VOL: 0
;PCODE: $00000B8C VOL: 0
;//---------------END SLAVE----------------------//
;
;
;////////////////////HARDWARE SPI///////////////////////////////
;///////////////////////////////////////////////////////////////
;
;
;
;//обработчик прерывания по завершению передачи/приёма
;interrupt [SPI_STC] void spi_isr(void)  //разобраться с приёмом/передачей!!!!!
;{
;PCODE: $00000B8D VOL: 0
;PCODE: $00000B8E VOL: 0
;char data;
;uint8_t Tmp = Spi0_txBufTail; // use local variable instead of volatile
; SPCR = (1<<MSTR);  //Master
;PCODE: $00000B8F VOL: 0
;PCODE: $00000B90 VOL: 0
;	data -> R17
;	Tmp -> R16
;PCODE: $00000B91 VOL: 0
;PCODE: $00000B92 VOL: 0
;PCODE: $00000B93 VOL: 0
;PCODE: $00000B94 VOL: 0
;  PORTD.6^=1;
;PCODE: $00000B95 VOL: 0
;PCODE: $00000B96 VOL: 0
;PCODE: $00000B97 VOL: 0
;PCODE: $00000B98 VOL: 0
;PCODE: $00000B99 VOL: 0
;PCODE: $00000B9A VOL: 0
;PCODE: $00000B9B VOL: 0
;PCODE: $00000B9C VOL: 0
;PCODE: $00000B9D VOL: 0
;PCODE: $00000B9E VOL: 0
;PCODE: $00000B9F VOL: 0
;PCODE: $00000BA0 VOL: 0
;////////RX
;data =  SPDR;
;PCODE: $00000BA1 VOL: 0
;PCODE: $00000BA2 VOL: 0
;/*
;    if (Spi0_rxCount < SIZE_SPI_BUF_RX) //если в буфере еще есть место
;    {
;       Spi0_RX_buf[Spi0_rxBufTail] = data;//!    //считать символ из SPDR в буфер
;       Spi0_rxBufTail++;                    //увеличить индекс хвоста приемного буфера
;      if (Spi0_rxBufTail == SIZE_BUF_RX)
;      {
;       Spi0_rxBufTail = 0;
;      }
;      Spi0_rxCount++;                      //увеличить счетчик принятых символов
;    }
;    */
;///////////
;
;//////////TX
;/*
; if(Tmp != Spi0_txBufHead) // all transmitted
;  {
;  // SPDR = Spi0_TX_buf[Tmp & (SIZE_SPI_BUF_TX - 1)];
;   ++Tmp;
;   Spi0_txBufTail = Tmp;
;   SPDR = Spi0_TX_buf[Tmp & (SIZE_SPI_BUF_TX - 1)];
;  }
;   */
;/////////
;
;}
;PCODE: $00000BA3 VOL: 0
;PCODE: $00000BA4 VOL: 0
;PCODE: $00000BA5 VOL: 0
;PCODE: $00000BA6 VOL: 0
;
;
;
;
;
;
;
;
;
;
;/*
;unsigned char spi(unsigned char data)
;{
;_ATXMEGA_SPI_.DATA=data;
;while ((_ATXMEGA_SPI_.STATUS & SPI_IF_bm)==0);
;return _ATXMEGA_SPI_.DATA;
;}
;
;void spi_init(bool master_mode,bool lsb_first,SPI_MODE_t mode,bool clk2x,SPI_PRESCALER_t clock_div, unsigned char ss_pin)
;{
;if (master_mode)
;   {
;   // Init SS pin as output with wired AND and pull-up
;   _ATXMEGA_SPI_PORT_.DIRSET=ss_pin;
;   _ATXMEGA_SPI_PORT_.PIN4CTRL=PORT_OPC_WIREDANDPULL_gc;
;
;   // Set SS output to high
;   _ATXMEGA_SPI_PORT_.OUTSET=ss_pin;
;
;   // SPI master mode
;   _ATXMEGA_SPI_.CTRL=clock_div |                      // SPI prescaler.
;                      (clk2x ? SPI_CLK2X_bm : 0) |     // SPI Clock double.
;                      SPI_ENABLE_bm |                  // Enable SPI module.
;                      (lsb_first ? SPI_DORD_bm : 0) |  // Data order.
;                      SPI_MASTER_bm |                  // SPI master.
;                      mode;                            // SPI mode.
;
;   // MOSI and SCK as output
;   _ATXMEGA_SPI_PORT_.DIRSET=SPI_MOSI_bm | SPI_SCK_bm;
;   }
;else
;   {
;   // SPI slave mode
;   _ATXMEGA_SPI_.CTRL=SPI_ENABLE_bm |                 // Enable SPI module.
;                      (lsb_first ? SPI_DORD_bm : 0) | // Data order.
;	                  mode;                           // SPI mode.
;
;   // MISO as output
;   _ATXMEGA_SPI_PORT_.DIRSET=SPI_MISO_bm;
;   };
;// No interrupts, polled mode
;_ATXMEGA_SPI_.INTCTRL=SPI_INTLVL_OFF_gc;
;}
;*/
;PCODE: $00000BA7 VOL: 0
   .equ __i2c_port=0x1B ;PORTA
;PCODE: $00000BA8 VOL: 0
   .equ __sda_bit=0
;PCODE: $00000BA9 VOL: 0
   .equ __scl_bit=1
;PCODE: $00000BAA VOL: 0
;PCODE: $00000BAB VOL: 0
;//***************************************************************************
;//
;//  Author(s)...: Vlad
;//
;//  Target(s)...: Mega
;//
;//  Compiler....:
;//
;//  Description.: Драйвер I2C
;//
;//  Data........:
;//
;//***************************************************************************
;#include "I2C.h"
;
;
;/*
;TODO:
;Hard/Software implementations
;
;*/
;////////////////HARDWARE_TWI/I2C///////////////////////////
;///////////////////////////////////////////////////////////
;
;void hard_twi_init(void){// TWI initialization
;PCODE: $00000BAC VOL: 0
;PCODE: $00000BAD VOL: 0
;// Bit Rate: 400,000 kHz
;TWBR=0x02;
;PCODE: $00000BAE VOL: 0
;PCODE: $00000BAF VOL: 0
;// Two Wire Bus Slave Address: 0x0
;// General Call Recognition: Off
;TWAR=0x00;
;PCODE: $00000BB0 VOL: 0
;PCODE: $00000BB1 VOL: 0
;// Generate Acknowledge Pulse: Off
;// TWI Interrupt: On
;TWCR = (1<<TWIE)|(1<<TWEN) ;
;PCODE: $00000BB2 VOL: 0
;PCODE: $00000BB3 VOL: 0
;TWSR=0x00;
;PCODE: $00000BB4 VOL: 0
;PCODE: $00000BB5 VOL: 0
;}
;PCODE: $00000BB6 VOL: 0
;PCODE: $00000BB7 VOL: 0
;
;
;/*
;void hard_twi_init(void);
;void hard_twi_start(void);
;void hard_twi_stop(void);
;unsigned char hard_twi_read(unsigned char ack);
;unsigned char hard_twi_write(unsigned char data);
;*/
;
;void hard_twi_start() {
;PCODE: $00000BB8 VOL: 0
;PCODE: $00000BB9 VOL: 0
;	TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN); // send start condition
;PCODE: $00000BBA VOL: 0
;PCODE: $00000BBB VOL: 0
;	while (!(TWCR & (1 << TWINT)));
;PCODE: $00000BBC VOL: 0
;PCODE: $00000BBD VOL: 0
;PCODE: $00000BBE VOL: 0
;PCODE: $00000BBF VOL: 0
;PCODE: $00000BC0 VOL: 0
;PCODE: $00000BC1 VOL: 0
;    //возможно сдесь нужно очистить  TWSTA
;}
;PCODE: $00000BC2 VOL: 0
;PCODE: $00000BC3 VOL: 0
;
;void hard_twi_write_byte(char byte) {
;PCODE: $00000BC4 VOL: 0
;PCODE: $00000BC5 VOL: 0
;	TWDR = byte;
;	byte -> Y+0
;PCODE: $00000BC6 VOL: 0
;PCODE: $00000BC7 VOL: 0
;	TWCR = (1 << TWINT) | (1 << TWEN); // start address transmission
;PCODE: $00000BC8 VOL: 0
;PCODE: $00000BC9 VOL: 0
;	while (!(TWCR & (1 << TWINT)));
;PCODE: $00000BCA VOL: 0
;PCODE: $00000BCB VOL: 0
;PCODE: $00000BCC VOL: 0
;PCODE: $00000BCD VOL: 0
;PCODE: $00000BCE VOL: 0
;PCODE: $00000BCF VOL: 0
;}
;PCODE: $00000BD0 VOL: 0
;PCODE: $00000BD1 VOL: 0
;PCODE: $00000BD2 VOL: 0
;
;char hard_twi_read_byte() {
;PCODE: $00000BD3 VOL: 0
;PCODE: $00000BD4 VOL: 0
;	TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN); // start data reception, transmit ACK
;PCODE: $00000BD5 VOL: 0
;PCODE: $00000BD6 VOL: 0
;	while (!(TWCR & (1 << TWINT)));
;PCODE: $00000BD7 VOL: 0
;PCODE: $00000BD8 VOL: 0
;PCODE: $00000BD9 VOL: 0
;PCODE: $00000BDA VOL: 0
;PCODE: $00000BDB VOL: 0
;PCODE: $00000BDC VOL: 0
;	return TWDR;
;PCODE: $00000BDD VOL: 0
;PCODE: $00000BDE VOL: 0
;}
;PCODE: $00000BDF VOL: 0
;
;char hard_twi_read_last_byte() {
;PCODE: $00000BE0 VOL: 0
;PCODE: $00000BE1 VOL: 0
;	TWCR = (1 << TWINT) | (1 << TWEN); // start data reception
;PCODE: $00000BE2 VOL: 0
;PCODE: $00000BE3 VOL: 0
;	while (!(TWCR & (1 << TWINT)));
;PCODE: $00000BE4 VOL: 0
;PCODE: $00000BE5 VOL: 0
;PCODE: $00000BE6 VOL: 0
;PCODE: $00000BE7 VOL: 0
;PCODE: $00000BE8 VOL: 0
;PCODE: $00000BE9 VOL: 0
;	return TWDR;
;PCODE: $00000BEA VOL: 0
;PCODE: $00000BEB VOL: 0
;}
;PCODE: $00000BEC VOL: 0
;
;void hard_twi_stop() {
;PCODE: $00000BED VOL: 0
;PCODE: $00000BEE VOL: 0
;	  TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN); // send stop condition
;PCODE: $00000BEF VOL: 0
;PCODE: $00000BF0 VOL: 0
;}
;PCODE: $00000BF1 VOL: 0
;PCODE: $00000BF2 VOL: 0
;
;uint8_t hard_twi_read_ACK(void)
;{
;PCODE: $00000BF3 VOL: 0
;PCODE: $00000BF4 VOL: 0
;    TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
;PCODE: $00000BF5 VOL: 0
;PCODE: $00000BF6 VOL: 0
;    while ((TWCR & (1<<TWINT)) == 0);
;PCODE: $00000BF7 VOL: 0
;PCODE: $00000BF8 VOL: 0
;PCODE: $00000BF9 VOL: 0
;PCODE: $00000BFA VOL: 0
;PCODE: $00000BFB VOL: 0
;PCODE: $00000BFC VOL: 0
;    return TWDR;
;PCODE: $00000BFD VOL: 0
;PCODE: $00000BFE VOL: 0
;}
;PCODE: $00000BFF VOL: 0
;//read byte with NACK
;uint8_t hard_twi_read_NACK(void)
;{
;PCODE: $00000C00 VOL: 0
;PCODE: $00000C01 VOL: 0
;    TWCR = (1<<TWINT)|(1<<TWEN);
;PCODE: $00000C02 VOL: 0
;PCODE: $00000C03 VOL: 0
;    while ((TWCR & (1<<TWINT)) == 0);
;PCODE: $00000C04 VOL: 0
;PCODE: $00000C05 VOL: 0
;PCODE: $00000C06 VOL: 0
;PCODE: $00000C07 VOL: 0
;PCODE: $00000C08 VOL: 0
;PCODE: $00000C09 VOL: 0
;    return TWDR;
;PCODE: $00000C0A VOL: 0
;PCODE: $00000C0B VOL: 0
;}
;PCODE: $00000C0C VOL: 0
;
;uint8_t hard_twi_get_status(void)
;{
;PCODE: $00000C0D VOL: 0
;PCODE: $00000C0E VOL: 0
;    uint8_t status;
;    status = TWSR & 0xF8;     //mask status
;PCODE: $00000C0F VOL: 0
;	status -> R17
;PCODE: $00000C10 VOL: 0
;PCODE: $00000C11 VOL: 0
;PCODE: $00000C12 VOL: 0
;    return status;
;PCODE: $00000C13 VOL: 0
;PCODE: $00000C14 VOL: 0
;PCODE: $00000C15 VOL: 0
;}
;PCODE: $00000C16 VOL: 0
;
;/*
;// Two Wire bus interrupt service routine
;interrupt [TWI] void twi_isr(void)
;{
;
;TWCR = (1<<TWINT) ;// At the end - clear interrupt flag
;}
;*/

	.DSEG
;#include "ADC.h"
;
;void ADC_init(void){ // ADC initialization  //Upd-6

	.CSEG
;PCODE: $00000C17 VOL: 0
;PCODE: $00000C18 VOL: 0
;PORTF=0x00; DDRF=0x00;
;PCODE: $00000C19 VOL: 0
;PCODE: $00000C1A VOL: 0
;PCODE: $00000C1B VOL: 0
;PCODE: $00000C1C VOL: 0
;// ADC Clock frequency: 1000,000 kHz
;// ADC Voltage Reference: Int., cap. on AREF
;ADMUX=ADC_VREF_TYPE & 0xff;
;PCODE: $00000C1D VOL: 0
;PCODE: $00000C1E VOL: 0
;ADCSRA=0x8C;
;PCODE: $00000C1F VOL: 0
;PCODE: $00000C20 VOL: 0
;}
;PCODE: $00000C21 VOL: 0
;PCODE: $00000C22 VOL: 0
;
;void adc_use (void)
;{
;PCODE: $00000C23 VOL: 0
;PCODE: $00000C24 VOL: 0
;  ADCSRA=0b11011111;  //вкл
;PCODE: $00000C25 VOL: 0
;PCODE: $00000C26 VOL: 0
;};
;PCODE: $00000C27 VOL: 0
;PCODE: $00000C28 VOL: 0
;
;
;//-----------Функция автокалибровки АЦП-----------------   //Upd-7
;void adc_calibrate (void)   //Поиск оптимального напряжения Vref
;{
;PCODE: $00000C29 VOL: 0
;PCODE: $00000C2A VOL: 0
;  ADMUX &= 0xDF & 0x7F & 0xFE; ADMUX |= 0x40 | 0x0E;   //Регистр ADMUX: АЦП 10 бит, Vref=AVCC (5B), ИОН=1,23В
;PCODE: $00000C2B VOL: 0
;PCODE: $00000C2C VOL: 0
;PCODE: $00000C2D VOL: 0
;PCODE: $00000C2E VOL: 0
;PCODE: $00000C2F VOL: 0
;PCODE: $00000C30 VOL: 0
;  ADCSRA &= 0xDF & 0xFC; ADCSRA |= 0x80 | 0x40 | 0x04; //Регистр ADCSRA: вкл. АЦП, одиночный пуск, Fацп=62 кГц
;PCODE: $00000C31 VOL: 0
;PCODE: $00000C32 VOL: 0
;PCODE: $00000C33 VOL: 0
;PCODE: $00000C34 VOL: 0
;PCODE: $00000C35 VOL: 0
;PCODE: $00000C36 VOL: 0
;  for (volt=0, adc_calib_cnt=100; adc_calib_cnt>0; adc_calib_cnt--) //Усреднение 100 замеров
;PCODE: $00000C37 VOL: 0
;PCODE: $00000C38 VOL: 0
;PCODE: $00000C39 VOL: 0
;PCODE: $00000C3A VOL: 0
;PCODE: $00000C3B VOL: 0
;PCODE: $00000C3C VOL: 0
;PCODE: $00000C3D VOL: 0
;PCODE: $00000C3E VOL: 0
;PCODE: $00000C3F VOL: 0
;PCODE: $00000C40 VOL: 0
;PCODE: $00000C41 VOL: 0
;PCODE: $00000C42 VOL: 0
;PCODE: $00000C43 VOL: 0
;  {
;    ADCSRA |= 0x40;        //Запуск нового измерения АЦП
;PCODE: $00000C44 VOL: 0
;PCODE: $00000C45 VOL: 0
;    while (ADCSRA & 0x40);   //Проверка окончания замера
;PCODE: $00000C46 VOL: 0
;PCODE: $00000C47 VOL: 0
;PCODE: $00000C48 VOL: 0
;PCODE: $00000C49 VOL: 0
;PCODE: $00000C4A VOL: 0
;PCODE: $00000C4B VOL: 0
;    volt += ADCL;    //Чтение младших 8 битов результата
;PCODE: $00000C4C VOL: 0
;PCODE: $00000C4D VOL: 0
;PCODE: $00000C4E VOL: 0
;PCODE: $00000C4F VOL: 0
;PCODE: $00000C50 VOL: 0
;    volt += ((int)ADCH << 8);    //Плюс два старших бита
;PCODE: $00000C51 VOL: 0
;PCODE: $00000C52 VOL: 0
;PCODE: $00000C53 VOL: 0
;PCODE: $00000C54 VOL: 0
;PCODE: $00000C55 VOL: 0
;  }                   //Окончание 100 замеров напряжения
;PCODE: $00000C56 VOL: 0
;PCODE: $00000C57 VOL: 0
;PCODE: $00000C58 VOL: 0
;PCODE: $00000C59 VOL: 0
;PCODE: $00000C5A VOL: 0
;PCODE: $00000C5B VOL: 0
;PCODE: $00000C5C VOL: 0
;  for (avcc=4750; avcc<5250; avcc++) //Диапазон AVCC, мВ
;PCODE: $00000C5D VOL: 0
;PCODE: $00000C5E VOL: 0
;PCODE: $00000C5F VOL: 0
;PCODE: $00000C60 VOL: 0
;PCODE: $00000C61 VOL: 0
;PCODE: $00000C62 VOL: 0
;PCODE: $00000C63 VOL: 0
;PCODE: $00000C64 VOL: 0
;PCODE: $00000C65 VOL: 0
;PCODE: $00000C66 VOL: 0
;PCODE: $00000C67 VOL: 0
;  {
;     adc_tmp = volt*avcc/1024; //Текущее значение ИОН (1,23В)
;PCODE: $00000C68 VOL: 0
;PCODE: $00000C69 VOL: 0
;PCODE: $00000C6A VOL: 0
;PCODE: $00000C6B VOL: 0
;PCODE: $00000C6C VOL: 0
;PCODE: $00000C6D VOL: 0
;     if (adc_tmp > ION) {delta=adc_tmp-ION;}   //Положительная разность
;PCODE: $00000C6E VOL: 0
;PCODE: $00000C6F VOL: 0
;PCODE: $00000C70 VOL: 0
;PCODE: $00000C71 VOL: 0
;PCODE: $00000C72 VOL: 0
;PCODE: $00000C73 VOL: 0
;     else delta=ION-adc_tmp;           //Отрицательная разность
;PCODE: $00000C74 VOL: 0
;PCODE: $00000C75 VOL: 0
;PCODE: $00000C76 VOL: 0
;PCODE: $00000C77 VOL: 0
;PCODE: $00000C78 VOL: 0
;PCODE: $00000C79 VOL: 0
;     if (delta < d){d=delta; vref=avcc;} //Если меньше минимальной разности - запомнить новую минимальную разность и оптимальное напряжение Vref
;PCODE: $00000C7A VOL: 0
;PCODE: $00000C7B VOL: 0
;PCODE: $00000C7C VOL: 0
;PCODE: $00000C7D VOL: 0
;PCODE: $00000C7E VOL: 0
;PCODE: $00000C7F VOL: 0
;PCODE: $00000C80 VOL: 0
;PCODE: $00000C81 VOL: 0
;PCODE: $00000C82 VOL: 0
;  }                                      //Окончание сохранения новых значений, Окончание поиска оптимального напряжения Vref
;PCODE: $00000C83 VOL: 0
;PCODE: $00000C84 VOL: 0
;PCODE: $00000C85 VOL: 0
;PCODE: $00000C86 VOL: 0
;PCODE: $00000C87 VOL: 0
;PCODE: $00000C88 VOL: 0
;PCODE: $00000C89 VOL: 0
;PCODE: $00000C8A VOL: 0
;}                 //Окончание функции автокалибровки АЦП
;PCODE: $00000C8B VOL: 0
;PCODE: $00000C8C VOL: 0
;
;uint16_t adc_get_volt(void)
;{
;PCODE: $00000C8D VOL: 0
;PCODE: $00000C8E VOL: 0
;   return vref-adc_result*vref/1024;
;PCODE: $00000C8F VOL: 0
;PCODE: $00000C90 VOL: 1
;PCODE: $00000C91 VOL: 0
;PCODE: $00000C92 VOL: 0
;PCODE: $00000C93 VOL: 0
;PCODE: $00000C94 VOL: 0
;PCODE: $00000C95 VOL: 0
;PCODE: $00000C96 VOL: 0
;PCODE: $00000C97 VOL: 0
;}
;PCODE: $00000C98 VOL: 0
;
;/*
;//Автокалибровка АЦП,=AVR. Ступень 8=, РА, №9, 2005 г     =1
;//Make: avr83,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
;//Фьюзы: SUT0=CKSEL3=CKSEL2=CKSEL1="0" (Генератор 1 МГц)  =3
;#include <avr/io.h>             //Библиотека ввода-вывода =4
;#define RIZM 200  //Сопротивление измер. резистора в Омах =5
;#define ION 1298 //Напряжение внутреннего ИОН (1,23) в мВ =6
;extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =7
;extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =8
;extern void lcd_init(void);           //Инициализация ЖКИ =9
;unsigned char t0[]=" ==WATTMETER==          mWt     "; //=10
;unsigned long vref=0,volt,watt,delta,i,d=200,avcc;     //=11
;unsigned int a;                //Вспомогательный счетчик =12
;//-----------Функция автокалибровки АЦП----------------- =13
;void calib (void)   //Поиск оптимального напряжения Vref =14
;{ //Регистр ADMUX: АЦП 10 бит, Vref=AVCC (5B), ИОН=1,23В =15
;        ADMUX &= 0xDF & 0x7F & 0xFE; ADMUX |= 0x40 | 0x0E;   //=16
;//Регистр ADCSRA: вкл. АЦП, одиночный пуск, Fацп=62 кГц  =17
;        ADCSRA &= 0xDF & 0xFC; ADCSRA |= 0x80 | 0x40 | 0x04; //=18
;  for (volt=0, a=100; a>0; a--) //Усреднение 100 замеров =19
;  {    ADCSRA |= 0x40;        //Запуск нового измерения АЦП =20
;          while (ADCSRA & 0x40);   //Проверка окончания замера =21
;          volt += ADCL;    //Чтение младших 8 битов результата =22
;    volt += ((int)ADCH << 8);    //Плюс два старших бита =23
;        }                   //Окончание 100 замеров напряжения =24
;        for (avcc=4750; avcc<5250; avcc++) //Диапазон AVCC, мВ =25
;  { i = volt*avcc/102400; //Текущее значение ИОН (1,23В) =26
;          if (i > ION) delta=i-ION;   //Положительная разность =27
;          else delta=ION-i;           //Отрицательная разность =28
;          if (delta < d)    //Если меньше минимальной разности =29
;    { d=delta;    //Запомнить новую минимальную разность =30
;      vref=avcc; //Запомнить оптимальное напряжение Vref =31
;    }              //Окончание сохранения новых значений =32
;  }      //Окончание поиска оптимального напряжения Vref =33
;}                 //Окончание функции автокалибровки АЦП =34
;//================ОСНОВНАЯ ПРОГРАММА==================== =35
;int main(void)               //Начало основной программы =36
;{ PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =37
;  PORTC = 0xF0; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =38
;  lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =39
;  for (lcd_com(0x80), a=0; a<32; a++)  //Начальный текст =40
;        { if (a==16) lcd_com(0xC0); //Переход на нижнюю строку =41
;          lcd_dat(t0[a]);             //Вывод текущего символа =42
;        }       //Окончание вывода начальной надписи WATTMETER =43
;        calib(); //Автокалибровка АЦП по внутреннему ИОН 1,23В =44
;        ADMUX &= 0xF3; ADMUX |= 0x03;   //Подключение канала-3 =45
;        ADCSRA |= 0x20 | 0x40;   //Пуск постоянных замеров АЦП =46
;        while (1)                           //Бесконечный цикл =47
;        { for (a=65000; a>0; a--);       //Пауза для индикации =48
;          volt = ADCL;     //Чтение младших 8 битов результата =49
;    volt += ((int)ADCH << 8);    //Плюс два старших бита =50
;          watt=(vref-volt*vref/1024)*(volt*vref/1024)/RIZM; // =51
;                lcd_com(0xC4);               //Установка курсора ЖКИ =52
;                lcd_dat(watt/1000 + 0x30); //Единицы милливатт (мВт) =53
;				lcd_dat(',');	lcd_dat((watt/100)%10 +0x30); //0,1мВт =54
;		}                     //Переход к новому измерению АЦП =55
;}              //WinAVR-20050214, длина кода 1342 байтов =56
;
;
;
;//Осциллограф на ЖКИ (АЦП),=AVR. Ступень 9=, РА, №10-2005 =1
;//Make: avr91,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
;//Фьюзы: SUT0=CKSEL3=CKSEL1=CKSEL0="0" (Генератор 8 МГц)  =3
;#include <avr/io.h>             //Библиотека ввода-вывода =4
;extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =5
;extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =6
;extern void lcd_init(void);           //Инициализация ЖКИ =7
;unsigned char t[]="        јєc/гe» ";    //Текст заставки =8
;//================ОСНОВНАЯ ПРОГРАММА===================== =9
;int main(void)               //Начало основной программы =10
;{ unsigned char a, b, c, scan, ur, h;         //Счетчики =11
;  unsigned int izm, d, k;       //Счетчики больших чисел =12
;		unsigned int osc[32];   //Массив амплитуд осциллографа =13
;		PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =14
;  PORTC = 0xC2; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =15
;		ADMUX &= 0x7F; ADMUX |= 0x20 | 0x40;  //8-10 бит, AVCC =16
;//Регистр ADCSRA: вкл.АЦП, постоян. измерен., Fацп=1 МГц =17
;		ADCSRA &= 0xFB; ADCSRA |= 0x80 | 0x40 | 0x20 | 0x03; //=18
;		lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =19
;		lcd_com(0x40); lcd_dat(0x00); //Начало знакогенератора =20
;		for (a=1; a<63; a++)  //Загрузка 8 свободных знакомест =21
;		{ if (a%7 == 0) lcd_dat(0x1F);      //В строке 5 точек =22
;	   else lcd_dat(0x00);       //Пустая строка, нет точек =23
;		}       //Окончание загрузки 62 байтов знакогенератора =24
;		lcd_dat(0x00); //Последний (64-й) байт знакогенератора =25
;		for (lcd_com(0xC0), a=0; a<16; a++) lcd_dat(t[a]);  // =26
;		while (1)                 //Бесконечный цикл измерений =27
;		{ ADMUX &=0xF5; ADMUX |=0x05;     //Канал-5, РАЗВЕРТКА =28
;		  for (a=5; a>0; a--) for (d=60000; d>0; d--);	//Пауза =29
;				scan = (ADCH <= 5)? 1 : (ADCH - 4); //Развертка, мкс =30
;				ADMUX &=0xF4; ADMUX |=0x04; //Канал-4, УРОВЕНЬ СИНХР =31
;				lcd_com(0xC2);               //Установка курсора ЖКИ =32
;				for (k=13*scan, d=10000, b=5; b > 0; b--, d=d/10) // =33
;    { lcd_dat(((k / d)%10) + 0x30); //Вывод текущ. цифры =34
;    }  //Окончание вывода 5 цифр времени развертки в мкс =35
;				ur = (ADCH <= 10)? 0 : ADCH; //Уровень синхрониз., В =36
;		  ADMUX &= 0xF3; ADMUX |= 0x03; //Канал-3, ВХОД осцил. =37
;				for(lcd_com(0x80), a=0; a<32; a++)   //32 замера АЦП =38
;				{ for (izm=0, b=scan; b > 0; b--)  //Время развертки =39
;						{ while (!(ADCSRA & 0x10));   //Проверка измерения =40
;		      ADCSRA |= 0x10;   //Разрешение следующего замера =41
;        izm += ADCH;             //Накопление результата =42
;						}                //Окончание очередного замера АЦП =43
;						osc[a] = izm;        //Заполнение массива амплитуд =44
;				}              	//Окончание 32 замеров амплитуды АЦП =45
;				lcd_com(0x0D);               //Включение курсора ЖКИ =46
;				if (!ur)	for (a=0; a<16; a++) lcd_dat((osc[a]/scan)/32);
;				else  //Если синхронизация или остановка изображения =48
;				{	if (ur < 0xF0)    //Если нет остановки изображения =49
;				  { for (a=b=c=h=0; a<16; a++) //Поиск синхронизации =50
;        { if (bit_is_set(PINB,PB0)) c=1; //Кнопка SB1(+) =51
;								  else b=1;   //Иначе синхронизация от <+> к <-> =52
;								  if((osc[a+b]/scan<(ur-3))&&(osc[a+c]/scan>(ur+3)))
;								  { h=a; a=32;       //Досрочный выход из поиска =54
;										}            //Синхронизация выполнена успешно =55
;						  }     //Окончание процедуры поиска синхронизации =56
;						  for (a=h; a<(h+16); a++) lcd_dat((osc[a]/scan)/32);
;						}  //Окончание прорисовки графика с синхронизацией =58
;						else lcd_com(0x0C);  //Выкл. курсора при остановке =59
;				}        //Завершение процедуры поиска синхронизации =60
;		}               //Переход к новому циклу измерений АЦП =61
;}               //WinAVR-20050214, длина кода 882 байтов =62
;
;
;
;//Запоминающий осциллограф,=AVR. Ступень 10=, РА №11-2005 =1
;//Make:avr101,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
;//Фьюзы: SUT0=CKSEL3=CKSEL2=CKSEL1="0" (Генератор 1 МГц)  =3
;#include <avr/io.h>             //Библиотека ввода-вывода =4
;extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =5
;extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =6
;extern void lcd_init(void);           //Инициализация ЖКИ =7
;#define TIME 30 //Условная длительность одного замера АЦП =8
;unsigned char t[]="Cїapї ё·јepeЅё№";     //Текст заставки =9
;//================ОСНОВНАЯ ПРОГРАММА==================== =10
;int main(void)               //Начало основной программы =11
;{ unsigned char u1[450], u2[450]; //Массивы данных осцил.=12
;		unsigned int a, b, c, d, h=0;        //Счетчики данных =13
;  PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =14
;  PORTC = 0xC2; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =15
;		ADMUX &= 0x7F; ADMUX |= 0x20 | 0x40;  //8-10 бит, AVCC =16
;//Регистр ADCSRA: включить АЦП, однократно, Fацп=125 кГц =17
;		ADCSRA &= 0xDF & 0xFB; ADCSRA |= 0x80 | 0x40 | 0x03; //=18
;		lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =19
;		lcd_com(0x40); lcd_dat(0x00); //Начало знакогенератора =20
;		for (a=1; a<63; a++)  //Загрузка 8 свободных знакомест =21
;		{ if (a%7 == 0) lcd_dat(0x1F);      //В строке 5 точек =22
;	   else lcd_dat(0x00);       //Пустая строка, нет точек =23
;		}       //Окончание загрузки 62 байтов знакогенератора =24
;		lcd_dat(0x00); //Последний (64-й) байт знакогенератора =25
;		for(lcd_com(0x80),a=0; a<15; a++) lcd_dat(t[a]); //ЖКИ =26
;		do  //Цикл проверки снижения напряжения Uзап менее 4 В =27
;		{ ADMUX &=0xF3; ADMUX |=0x03; ADCSRA |=0x40; //Канал-3 =28
;		  while (ADCSRA & 0x40);   //Проверка окончания замера =29
;		} while (ADCH > 0xCC); //Проверять, пока уровень > 4 В =30
;		lcd_com(0x0C); //Выключение курсора при начале замеров =31
;		for (a=0; a<450; a++) //Цикл заполнения массива данных =32
;		{ for (c=d=0, b=TIME; b>0; b--)   //Усреднение замеров =33
;		  { ADMUX &=0xF4; ADMUX |=0x04; ADCSRA |=0x40; //Кан.4 =34
;		    while (ADCSRA & 0x40); //Проверка окончания замера =35
;		    c += ADCH;  //Накопление амплитуды АЦП по каналу-4 =36
;				  ADMUX &=0xF5; ADMUX |=0x05; ADCSRA |=0x40; //Кан.5 =37
;		    while (ADCSRA & 0x40); //Проверка окончания замера =38
;		    d += ADCH;  //Накопление амплитуды АЦП по каналу-5 =39
;				}         //Окончание цикла замеров с каналов-4 и -5 =40
;				u1[a] = c/(TIME*32);  //Усредненный текущий замер U1 =41
;				u2[a] = d/(TIME*32);  //Усредненный текущий замер U2 =42
;		}         //Окончание заполнения массива данных U1, U2 =43
;  while (1) //Бесконечный цикл индикации, повтор - сброс =44
;		{ lcd_com(0x80);  //Установка курсора в верхней строке =45
;		  for(a=h; a < h+15; a++) lcd_dat(u1[a]);  //График U1 =46
;				lcd_com(0xC0);   //Установка курсора в нижней строке =47
;				for(a=h; a < h+15; a++) lcd_dat(u2[a]);  //График U2 =48
;				lcd_dat(0x30 + h/15);  //Условный номер блока данных =49
;				if (bit_is_clear(PINB,PB0))     //Нажатие кнопки SB1 =50
;    { if ((h += 15) > 435) h=0;  //Следующий блок данных =51
;      for (c=65000; c>0; c--);  //Длительность индикации =52
;				}         //Окончание увеличения номера блока данных =53
;				if (bit_is_clear(PINB,PB1))     //Нажатие кнопки SB2 =54
;    { h = (h < 15)? 435 : (h-15); //Предыдущий блок дан. =55
;      for (c=65000; c>0; c--);  //Длительность индикации =56
;				}         //Окончание уменьшения номера блока данных =57
;		}               //Переход к прорисовке графиков данных =58
;}               //WinAVR-20050214, длина кода 752 байтов =59
;
;*/
;/**** A V R  A P P L I C A T I O N  NOTE 1 3 4 **************************
; *
; * Title:           Real Time Clock
; * Version:         2.00
; * Last Updated:    24.09.2013
; * Target:          ATmega128 (All AVR Devices with secondary external oscillator)
; *
; * Support E-mail:  avr@atmel.com
; *
; * Description
; * This application note shows how to implement a Real Time Clock utilizing a secondary
; * external oscilator. Included a test program that performs this function, which keeps
; * track of time, date, month, and year with auto leap-year configuration. 8 LEDs are used
; * to display the RTC. The 1st LED flashes every second, the next six represents the
; * minute, and the 8th LED represents the hour.
; *
; ******************************************************************************************/
;
;#ifdef _GCC_
;#include <avr/io.h>
;#include <avr/interrupt.h>
;#include <avr/sleep.h>
;#else
;
;#endif
;
;	time t;
;/*
;int main(void)
;{
;    rtc_init();	//Initialize registers and configure RTC.
;
;	while(1)
;	{
;		sleep_mode();										//Enter sleep mode. (Will wake up from timer overflow interrupt)
;		TCCR0=(1<<CS00)|(1<<CS02);							//Write dummy value to control register
;		while(ASSR&((1<<TCN0UB)|(1<<OCR0UB)|(1<<TCR0UB)));	//Wait until TC0 is updated
;	}
;}
;*/
;static void rtc_init(void)
;{
;PCODE: $00000C99 VOL: 0
;PCODE: $00000C9A VOL: 0
;   	TIMSK &= ~((1<<TOIE0)|(1<<OCIE0));						//Make sure all TC0 interrupts are disabled
;PCODE: $00000C9B VOL: 0
;PCODE: $00000C9C VOL: 0
;PCODE: $00000C9D VOL: 0
;	ASSR |= (1<<AS0);										//set Timer/counter0 to be asynchronous from the CPU clock
;PCODE: $00000C9E VOL: 0
;PCODE: $00000C9F VOL: 0
;PCODE: $00000CA0 VOL: 0
;															//with a second external clock (32,768kHz)driving it.
;	TCNT0 =0;												//Reset timer
;PCODE: $00000CA1 VOL: 0
;PCODE: $00000CA2 VOL: 0
;	TCCR0 =(1<<CS00)|(1<<CS02);								//Prescale the timer to be clock source/128 to make it
;PCODE: $00000CA3 VOL: 0
;PCODE: $00000CA4 VOL: 0
;															//exactly 1 second for every overflow to occur
;	while (ASSR & ((1<<TCN0UB)|(1<<OCR0UB)|(1<<TCR0UB))){ }	//Wait until TC0 is updated
;PCODE: $00000CA5 VOL: 0
;PCODE: $00000CA6 VOL: 0
;PCODE: $00000CA7 VOL: 0
;PCODE: $00000CA8 VOL: 0
;PCODE: $00000CA9 VOL: 0
;PCODE: $00000CAA VOL: 0
;	TIMSK |= (1<<TOIE0);									//Set 8-bit Timer/Counter0 Overflow Interrupt Enable
;PCODE: $00000CAB VOL: 0
;PCODE: $00000CAC VOL: 0
;PCODE: $00000CAD VOL: 0
;#asm("sei")													//Set the Global Interrupt Enable Bit
;PCODE: $00000CAE VOL: 0
	sei
;PCODE: $00000CAF VOL: 0
;}
;PCODE: $00000CB0 VOL: 0
;PCODE: $00000CB1 VOL: 0
;
;interrupt [TIM0_OVF] void timer0_ovf_isr(void)
;{
;PCODE: $00000CB2 VOL: 0
;PCODE: $00000CB3 VOL: 0
;	if (++t.second==60)        //keep track of time, date, month, and year
;PCODE: $00000CB4 VOL: 0
;PCODE: $00000CB5 VOL: 0
;PCODE: $00000CB6 VOL: 0
;PCODE: $00000CB7 VOL: 0
;PCODE: $00000CB8 VOL: 0
;PCODE: $00000CB9 VOL: 0
;PCODE: $00000CBA VOL: 0
;	{
;		t.second=0;
;PCODE: $00000CBB VOL: 0
;PCODE: $00000CBC VOL: 0
;PCODE: $00000CBD VOL: 0
;PCODE: $00000CBE VOL: 0
;		if (++t.minute==60)
;PCODE: $00000CBF VOL: 0
;PCODE: $00000CC0 VOL: 0
;PCODE: $00000CC1 VOL: 0
;PCODE: $00000CC2 VOL: 0
;PCODE: $00000CC3 VOL: 0
;PCODE: $00000CC4 VOL: 0
;PCODE: $00000CC5 VOL: 0
;		{
;			t.minute=0;
;PCODE: $00000CC6 VOL: 0
;PCODE: $00000CC7 VOL: 0
;PCODE: $00000CC8 VOL: 0
;PCODE: $00000CC9 VOL: 0
;			if (++t.hour==24)
;PCODE: $00000CCA VOL: 0
;PCODE: $00000CCB VOL: 0
;PCODE: $00000CCC VOL: 0
;PCODE: $00000CCD VOL: 0
;PCODE: $00000CCE VOL: 0
;PCODE: $00000CCF VOL: 0
;PCODE: $00000CD0 VOL: 0
;			{
;				t.hour=0;
;PCODE: $00000CD1 VOL: 0
;PCODE: $00000CD2 VOL: 0
;PCODE: $00000CD3 VOL: 0
;PCODE: $00000CD4 VOL: 0
;PCODE: $00000CD5 VOL: 0
;				if (++t.date==32)
;PCODE: $00000CD6 VOL: 0
;PCODE: $00000CD7 VOL: 0
;PCODE: $00000CD8 VOL: 0
;PCODE: $00000CD9 VOL: 0
;PCODE: $00000CDA VOL: 0
;PCODE: $00000CDB VOL: 0
;PCODE: $00000CDC VOL: 0
;				{
;					t.month++;
;PCODE: $00000CDD VOL: 0
;PCODE: $00000CDE VOL: 0
;PCODE: $00000CDF VOL: 0
;PCODE: $00000CE0 VOL: 0
;PCODE: $00000CE1 VOL: 0
;					t.date=1;
;PCODE: $00000CE2 VOL: 0
;PCODE: $00000CE3 VOL: 0
;PCODE: $00000CE4 VOL: 0
;PCODE: $00000CE5 VOL: 0
;PCODE: $00000CE6 VOL: 0
;PCODE: $00000CE7 VOL: 0
;				}
;				else if (t.date==31)
;PCODE: $00000CE8 VOL: 0
;PCODE: $00000CE9 VOL: 0
;PCODE: $00000CEA VOL: 0
;PCODE: $00000CEB VOL: 0
;PCODE: $00000CEC VOL: 0
;PCODE: $00000CED VOL: 0
;PCODE: $00000CEE VOL: 0
;				{
;					if ((t.month==4) || (t.month==6) || (t.month==9) || (t.month==11))
;PCODE: $00000CEF VOL: 0
;PCODE: $00000CF0 VOL: 0
;PCODE: $00000CF1 VOL: 0
;PCODE: $00000CF2 VOL: 0
;PCODE: $00000CF3 VOL: 0
;PCODE: $00000CF4 VOL: 0
;PCODE: $00000CF5 VOL: 0
;PCODE: $00000CF6 VOL: 0
;PCODE: $00000CF7 VOL: 0
;PCODE: $00000CF8 VOL: 0
;PCODE: $00000CF9 VOL: 0
;PCODE: $00000CFA VOL: 0
;					{
;						t.month++;
;PCODE: $00000CFB VOL: 0
;PCODE: $00000CFC VOL: 0
;PCODE: $00000CFD VOL: 0
;PCODE: $00000CFE VOL: 0
;PCODE: $00000CFF VOL: 0
;						t.date=1;
;PCODE: $00000D00 VOL: 0
;PCODE: $00000D01 VOL: 0
;PCODE: $00000D02 VOL: 0
;PCODE: $00000D03 VOL: 0
;PCODE: $00000D04 VOL: 0
;PCODE: $00000D05 VOL: 0
;					}
;				}
;PCODE: $00000D06 VOL: 0
;				else if (t.date==30)
;PCODE: $00000D07 VOL: 0
;PCODE: $00000D08 VOL: 0
;PCODE: $00000D09 VOL: 0
;PCODE: $00000D0A VOL: 0
;PCODE: $00000D0B VOL: 0
;PCODE: $00000D0C VOL: 0
;PCODE: $00000D0D VOL: 0
;				{
;					if(t.month==2)
;PCODE: $00000D0E VOL: 0
;PCODE: $00000D0F VOL: 0
;PCODE: $00000D10 VOL: 0
;PCODE: $00000D11 VOL: 0
;					{
;						t.month++;
;PCODE: $00000D12 VOL: 0
;PCODE: $00000D13 VOL: 0
;PCODE: $00000D14 VOL: 0
;PCODE: $00000D15 VOL: 0
;PCODE: $00000D16 VOL: 0
;						t.date=1;
;PCODE: $00000D17 VOL: 0
;PCODE: $00000D18 VOL: 0
;PCODE: $00000D19 VOL: 0
;PCODE: $00000D1A VOL: 0
;PCODE: $00000D1B VOL: 0
;PCODE: $00000D1C VOL: 0
;					}
;				}
;PCODE: $00000D1D VOL: 0
;				else if (t.date==29)
;PCODE: $00000D1E VOL: 0
;PCODE: $00000D1F VOL: 0
;PCODE: $00000D20 VOL: 0
;PCODE: $00000D21 VOL: 0
;PCODE: $00000D22 VOL: 0
;PCODE: $00000D23 VOL: 0
;PCODE: $00000D24 VOL: 0
;				{
;					if((t.month==2) && (not_leap()))
;PCODE: $00000D25 VOL: 0
;PCODE: $00000D26 VOL: 0
;PCODE: $00000D27 VOL: 0
;PCODE: $00000D28 VOL: 0
;PCODE: $00000D29 VOL: 0
;PCODE: $00000D2A VOL: 0
;PCODE: $00000D2B VOL: 0
;PCODE: $00000D2C VOL: 0
;PCODE: $00000D2D VOL: 0
;PCODE: $00000D2E VOL: 0
;PCODE: $00000D2F VOL: 0
;					{
;						t.month++;
;PCODE: $00000D30 VOL: 0
;PCODE: $00000D31 VOL: 0
;PCODE: $00000D32 VOL: 0
;PCODE: $00000D33 VOL: 0
;PCODE: $00000D34 VOL: 0
;						t.date=1;
;PCODE: $00000D35 VOL: 0
;PCODE: $00000D36 VOL: 0
;PCODE: $00000D37 VOL: 0
;PCODE: $00000D38 VOL: 0
;PCODE: $00000D39 VOL: 0
;PCODE: $00000D3A VOL: 0
;					}
;				}
;PCODE: $00000D3B VOL: 0
;				if (t.month==13)
;PCODE: $00000D3C VOL: 0
;PCODE: $00000D3D VOL: 0
;PCODE: $00000D3E VOL: 0
;PCODE: $00000D3F VOL: 0
;PCODE: $00000D40 VOL: 0
;PCODE: $00000D41 VOL: 0
;PCODE: $00000D42 VOL: 0
;PCODE: $00000D43 VOL: 0
;				{
;					t.month=1;
;PCODE: $00000D44 VOL: 0
;PCODE: $00000D45 VOL: 0
;PCODE: $00000D46 VOL: 0
;PCODE: $00000D47 VOL: 0
;PCODE: $00000D48 VOL: 0
;PCODE: $00000D49 VOL: 0
;					t.year++;
;PCODE: $00000D4A VOL: 0
;PCODE: $00000D4B VOL: 0
;PCODE: $00000D4C VOL: 0
;PCODE: $00000D4D VOL: 0
;PCODE: $00000D4E VOL: 0
;				}
;			}
;PCODE: $00000D4F VOL: 0
;		}
;PCODE: $00000D50 VOL: 0
;	}
;PCODE: $00000D51 VOL: 0
;	//PORTB=~(((t.second&0x01)|t.minute<<1)|t.hour<<7);
;}
;PCODE: $00000D52 VOL: 0
;PCODE: $00000D53 VOL: 0
;PCODE: $00000D54 VOL: 0
;PCODE: $00000D55 VOL: 0
;
;static char not_leap(void)      //check for leap year
;{
;PCODE: $00000D56 VOL: 0
;PCODE: $00000D57 VOL: 0
;	if (!(t.year%100))
;PCODE: $00000D58 VOL: 0
;PCODE: $00000D59 VOL: 0
;PCODE: $00000D5A VOL: 0
;PCODE: $00000D5B VOL: 0
;PCODE: $00000D5C VOL: 0
;PCODE: $00000D5D VOL: 0
;PCODE: $00000D5E VOL: 0
;PCODE: $00000D5F VOL: 0
;	{
;		return (char)(t.year%400);
;PCODE: $00000D60 VOL: 0
;PCODE: $00000D61 VOL: 0
;PCODE: $00000D62 VOL: 0
;PCODE: $00000D63 VOL: 0
;PCODE: $00000D64 VOL: 0
;PCODE: $00000D65 VOL: 0
;PCODE: $00000D66 VOL: 0
;	}
;	else
;PCODE: $00000D67 VOL: 0
;	{
;		return (char)(t.year%4);
;PCODE: $00000D68 VOL: 0
;PCODE: $00000D69 VOL: 0
;PCODE: $00000D6A VOL: 0
;PCODE: $00000D6B VOL: 0
;	}
;PCODE: $00000D6C VOL: 0
;}
;PCODE: $00000D6D VOL: 0
;PCODE: $00000D6E VOL: 0
;#include "D_IIC_ultimate/IIC_ultimate.h"
;
;
;void DoNothing(void);
;
;uint8_t i2c_Do;								// Переменная состояния передатчика IIC
;uint8_t i2c_InBuff[i2c_MasterBytesRX];		// Буфер прием при работе как Slave
;uint8_t i2c_OutBuff[i2c_MasterBytesTX];		// Буфер передачи при работе как Slave
;uint8_t i2c_SlaveIndex;						// Индекс буфера Slave
;
;
;uint8_t i2c_Buffer[i2c_MaxBuffer];			// Буфер для данных работы в режиме Master
;uint8_t i2c_index;							// Индекс этого буфера
;uint8_t i2c_ByteCount;						// Число байт передаваемых
;
;uint8_t i2c_SlaveAddress;						// Адрес подчиненного
;
;uint8_t i2c_PageAddress[i2c_MaxPageAddrLgth];	// Буфер адреса страниц (для режима с sawsarp)
;uint8_t i2c_PageAddrIndex;						// Индекс буфера адреса страниц
;uint8_t i2c_PageAddrCount;						// Число байт в адресе страницы для текущего Slave
;
;											// Указатели выхода из автомата:
;IIC_F MasterOutFunc = &DoNothing;			//  в Master режиме

	.DSEG
;IIC_F SlaveOutFunc 	= &DoNothing;			//  в режиме Slave
;IIC_F ErrorOutFunc 	= &DoNothing;			//  в результате ошибки в режиме Master
;
;/*
;uint8_t 	WorkLog[100];						// Лог пишем сюда
;uint8_t		WorkIndex=0;						// Индекс лога
;*/
;
;// Two Wire bus interrupt service routine
;interrupt [TWI] void twi_isr(void)								// Прерывание TWI Тут наше все.
;{

	.CSEG
;PCODE: $00000D6F VOL: 0
;PCODE: $00000D70 VOL: 0
;/*
;PORTB ^= 0x01;								// Дрыгаем ногой порта, для синхронизации логического анализатора и отметок вызова TWI
;
;
;// Отладочный кусок. Вывод лога работы конечного автомата в буфер памяти, а потом. По окончании работы через UART на волю
;if (WorkIndex <99)							// Если лог не переполнен
;{
;	if (TWSR)								// Статус нулевой?
;		{
;		WorkLog[WorkIndex]= TWSR;			// Пишем статус в лог
;		WorkIndex++;
;		}
;	else
;		{
;		WorkLog[WorkIndex]= 0xFF;			// Если статус нулевой то вписываем FF
;		WorkIndex++;
;		}
;}
;*/
;switch(TWSR & 0xF8)						// Отсекаем биты прескалера
;PCODE: $00000D71 VOL: 0
;PCODE: $00000D72 VOL: 0
;	{
;	case 0x00:	// Bus Fail (автобус сломался)
;PCODE: $00000D73 VOL: 0
;PCODE: $00000D74 VOL: 0
;			{
;			i2c_Do |= i2c_ERR_BF;
;PCODE: $00000D75 VOL: 0
;PCODE: $00000D76 VOL: 0
;PCODE: $00000D77 VOL: 0
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  	// Go!
;PCODE: $00000D78 VOL: 0
;PCODE: $00000D79 VOL: 0
;			MACRO_i2c_WhatDo_ErrorOut
;PCODE: $00000D7A VOL: 0
;PCODE: $00000D7B VOL: 0
;			break;
;PCODE: $00000D7C VOL: 0
;			}
;
;	case 0x08:	// Старт был, а затем мы:
;PCODE: $00000D7D VOL: 0
;PCODE: $00000D7E VOL: 0
;PCODE: $00000D7F VOL: 0
;			{
;			if( (i2c_Do & i2c_type_msk)== i2c_sarp)							// В зависимости от режима
;PCODE: $00000D80 VOL: 0
;PCODE: $00000D81 VOL: 0
;PCODE: $00000D82 VOL: 0
;				{
;				i2c_SlaveAddress |= 0x01;									// Шлем Addr+R
;PCODE: $00000D83 VOL: 0
;PCODE: $00000D84 VOL: 0
;PCODE: $00000D85 VOL: 0
;				}
;			else															// Или
;PCODE: $00000D86 VOL: 0
;PCODE: $00000D87 VOL: 0
;				{
;				i2c_SlaveAddress &= 0xFE;									// Шлем Addr+W
;PCODE: $00000D88 VOL: 0
;PCODE: $00000D89 VOL: 0
;PCODE: $00000D8A VOL: 0
;				}
;PCODE: $00000D8B VOL: 0
;
;			TWDR = i2c_SlaveAddress;													// Адрес слейва
;PCODE: $00000D8C VOL: 0
;PCODE: $00000D8D VOL: 0
;			TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  	// Go!
;PCODE: $00000D8E VOL: 0
;PCODE: $00000D8F VOL: 0
;			break;
;PCODE: $00000D90 VOL: 0
;			}
;
;	case 0x10:	// Повторный старт был, а затем мы
;PCODE: $00000D91 VOL: 0
;PCODE: $00000D92 VOL: 0
;PCODE: $00000D93 VOL: 0
;			{
;			if( (i2c_Do & i2c_type_msk) == i2c_sawsarp)						// В зависимости от режима
;PCODE: $00000D94 VOL: 0
;PCODE: $00000D95 VOL: 0
;PCODE: $00000D96 VOL: 0
;PCODE: $00000D97 VOL: 0
;				{
;				i2c_SlaveAddress |= 0x01;									// Шлем Addr+R
;PCODE: $00000D98 VOL: 0
;PCODE: $00000D99 VOL: 0
;PCODE: $00000D9A VOL: 0
;				}
;			else
;PCODE: $00000D9B VOL: 0
;PCODE: $00000D9C VOL: 0
;				{
;				i2c_SlaveAddress &= 0xFE;									// Шлем Addr+W
;PCODE: $00000D9D VOL: 0
;PCODE: $00000D9E VOL: 0
;PCODE: $00000D9F VOL: 0
;				}
;PCODE: $00000DA0 VOL: 0
;
;			// To Do: Добавить сюда обработку ошибок
;
;			TWDR = i2c_SlaveAddress;													// Адрес слейва
;PCODE: $00000DA1 VOL: 0
;PCODE: $00000DA2 VOL: 0
;			TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  	// Go!
;PCODE: $00000DA3 VOL: 0
;PCODE: $00000DA4 VOL: 0
;			break;
;PCODE: $00000DA5 VOL: 0
;			}
;
;	case 0x18:	// Был послан SLA+W получили ACK, а затем:
;PCODE: $00000DA6 VOL: 0
;PCODE: $00000DA7 VOL: 0
;PCODE: $00000DA8 VOL: 0
;			{
;			if( (i2c_Do & i2c_type_msk) == i2c_sawp)						// В зависимости от режима
;PCODE: $00000DA9 VOL: 0
;PCODE: $00000DAA VOL: 0
;PCODE: $00000DAB VOL: 0
;PCODE: $00000DAC VOL: 0
;				{
;				TWDR = i2c_Buffer[i2c_index];								// Шлем байт данных
;PCODE: $00000DAD VOL: 0
;PCODE: $00000DAE VOL: 0
;PCODE: $00000DAF VOL: 0
;PCODE: $00000DB0 VOL: 0
;PCODE: $00000DB1 VOL: 0
;				i2c_index++;												// Увеличиваем указатель буфера
;PCODE: $00000DB2 VOL: 0
;PCODE: $00000DB3 VOL: 0
;PCODE: $00000DB4 VOL: 0
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  // Go!
;PCODE: $00000DB5 VOL: 0
;PCODE: $00000DB6 VOL: 0
;
;				}
;
;			if( (i2c_Do & i2c_type_msk) == i2c_sawsarp)
;PCODE: $00000DB7 VOL: 0
;PCODE: $00000DB8 VOL: 0
;PCODE: $00000DB9 VOL: 0
;PCODE: $00000DBA VOL: 0
;PCODE: $00000DBB VOL: 0
;				{
;				TWDR = i2c_PageAddress[i2c_PageAddrIndex];					// Или шлем адрес странцы (по сути тоже байт данных)
;PCODE: $00000DBC VOL: 0
;PCODE: $00000DBD VOL: 0
;PCODE: $00000DBE VOL: 0
;PCODE: $00000DBF VOL: 0
;PCODE: $00000DC0 VOL: 0
;				i2c_PageAddrIndex++;										// Увеличиваем указатель буфера страницы
;PCODE: $00000DC1 VOL: 0
;PCODE: $00000DC2 VOL: 0
;PCODE: $00000DC3 VOL: 0
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;	// Go!
;PCODE: $00000DC4 VOL: 0
;PCODE: $00000DC5 VOL: 0
;				}
;			}
;PCODE: $00000DC6 VOL: 0
;			break;
;PCODE: $00000DC7 VOL: 0
;
;	case 0x20:	// Был послан SLA+W получили NACK - слейв либо занят, либо его нет дома.
;PCODE: $00000DC8 VOL: 0
;PCODE: $00000DC9 VOL: 0
;PCODE: $00000DCA VOL: 0
;			{
;			i2c_Do |= i2c_ERR_NA;															// Код ошибки
;PCODE: $00000DCB VOL: 0
;PCODE: $00000DCC VOL: 0
;PCODE: $00000DCD VOL: 0
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;			// Шлем шине Stop
;PCODE: $00000DCE VOL: 0
;PCODE: $00000DCF VOL: 0
;
;			MACRO_i2c_WhatDo_ErrorOut 														// Обрабатываем событие ошибки;
;PCODE: $00000DD0 VOL: 0
;PCODE: $00000DD1 VOL: 0
;			break;
;PCODE: $00000DD2 VOL: 0
;			}
;
;	case 0x28: 	// Байт данных послали, получили ACK!  (если sawp - это был байт данных. если sawsarp - байт адреса страницы)
;PCODE: $00000DD3 VOL: 0
;PCODE: $00000DD4 VOL: 0
;PCODE: $00000DD5 VOL: 0
;			{	// А дальше:
;			if( (i2c_Do & i2c_type_msk) == i2c_sawp)							// В зависимости от режима
;PCODE: $00000DD6 VOL: 0
;PCODE: $00000DD7 VOL: 0
;PCODE: $00000DD8 VOL: 0
;PCODE: $00000DD9 VOL: 0
;				{
;				if (i2c_index == i2c_ByteCount)												// Если был байт данных последний
;PCODE: $00000DDA VOL: 0
;PCODE: $00000DDB VOL: 0
;PCODE: $00000DDC VOL: 0
;PCODE: $00000DDD VOL: 0
;					{
;					TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;	// Шлем Stop
;PCODE: $00000DDE VOL: 0
;PCODE: $00000DDF VOL: 0
;
;					MACRO_i2c_WhatDo_MasterOut												// И выходим в обработку стопа
;PCODE: $00000DE0 VOL: 0
;PCODE: $00000DE1 VOL: 0
;
;					}
;				else
;PCODE: $00000DE2 VOL: 0
;PCODE: $00000DE3 VOL: 0
;					{
;					TWDR = i2c_Buffer[i2c_index];												// Либо шлем еще один байт
;PCODE: $00000DE4 VOL: 0
;PCODE: $00000DE5 VOL: 0
;PCODE: $00000DE6 VOL: 0
;PCODE: $00000DE7 VOL: 0
;PCODE: $00000DE8 VOL: 0
;					i2c_index++;
;PCODE: $00000DE9 VOL: 0
;PCODE: $00000DEA VOL: 0
;PCODE: $00000DEB VOL: 0
;					TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  	// Go!
;PCODE: $00000DEC VOL: 0
;PCODE: $00000DED VOL: 0
;					}
;PCODE: $00000DEE VOL: 0
;				}
;
;			if( (i2c_Do & i2c_type_msk) == i2c_sawsarp)						// В другом режиме мы
;PCODE: $00000DEF VOL: 0
;PCODE: $00000DF0 VOL: 0
;PCODE: $00000DF1 VOL: 0
;PCODE: $00000DF2 VOL: 0
;PCODE: $00000DF3 VOL: 0
;				{
;				if(i2c_PageAddrIndex == i2c_PageAddrCount)					// Если последний байт адреса страницы
;PCODE: $00000DF4 VOL: 0
;PCODE: $00000DF5 VOL: 0
;PCODE: $00000DF6 VOL: 0
;PCODE: $00000DF7 VOL: 0
;					{
;					TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;		// Запускаем Повторный старт!
;PCODE: $00000DF8 VOL: 0
;PCODE: $00000DF9 VOL: 0
;					}
;				else
;PCODE: $00000DFA VOL: 0
;PCODE: $00000DFB VOL: 0
;					{														// Иначе
;					TWDR = i2c_PageAddress[i2c_PageAddrIndex];				// шлем еще один адрес страницы
;PCODE: $00000DFC VOL: 0
;PCODE: $00000DFD VOL: 0
;PCODE: $00000DFE VOL: 0
;PCODE: $00000DFF VOL: 0
;PCODE: $00000E00 VOL: 0
;					i2c_PageAddrIndex++;									// Увеличиваем индекс счетчика адреса страниц
;PCODE: $00000E01 VOL: 0
;PCODE: $00000E02 VOL: 0
;PCODE: $00000E03 VOL: 0
;					TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;		// Go!
;PCODE: $00000E04 VOL: 0
;PCODE: $00000E05 VOL: 0
;					}
;PCODE: $00000E06 VOL: 0
;				}
;			}
;PCODE: $00000E07 VOL: 0
;			break;
;PCODE: $00000E08 VOL: 0
;
;	case 0x30:	//Байт ушел, но получили NACK причин две. 1я передача оборвана слейвом и так надо. 2я слейв сглючил.
;PCODE: $00000E09 VOL: 0
;PCODE: $00000E0A VOL: 0
;PCODE: $00000E0B VOL: 0
;			{
;			i2c_Do |= i2c_ERR_NK;				// Запишем статус ошибки. Хотя это не факт, что ошибка.
;PCODE: $00000E0C VOL: 0
;PCODE: $00000E0D VOL: 0
;PCODE: $00000E0E VOL: 0
;
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;		// Шлем Stop
;PCODE: $00000E0F VOL: 0
;PCODE: $00000E10 VOL: 0
;
;			MACRO_i2c_WhatDo_MasterOut													// Отрабатываем событие выхода
;PCODE: $00000E11 VOL: 0
;PCODE: $00000E12 VOL: 0
;
;			break;
;PCODE: $00000E13 VOL: 0
;			}
;
;	case 0x38:	//  Коллизия на шине. Нашелся кто то поглавней
;PCODE: $00000E14 VOL: 0
;PCODE: $00000E15 VOL: 0
;PCODE: $00000E16 VOL: 0
;			{
;			i2c_Do |= i2c_ERR_LP;			// Ставим ошибку потери приоритета
;PCODE: $00000E17 VOL: 0
;PCODE: $00000E18 VOL: 0
;PCODE: $00000E19 VOL: 0
;
;			// Настраиваем индексы заново.
;			i2c_index = 0;
;PCODE: $00000E1A VOL: 0
;PCODE: $00000E1B VOL: 0
;			i2c_PageAddrIndex = 0;
;PCODE: $00000E1C VOL: 0
;PCODE: $00000E1D VOL: 0
;
;			TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;		// Как только шина будет свободна
;PCODE: $00000E1E VOL: 0
;PCODE: $00000E1F VOL: 0
;			break;																		// попробуем передать снова.
;PCODE: $00000E20 VOL: 0
;			}
;
;	case 0x40: // Послали SLA+R получили АСК. А теперь будем получать байты
;PCODE: $00000E21 VOL: 0
;PCODE: $00000E22 VOL: 0
;PCODE: $00000E23 VOL: 0
;			{
;			if(i2c_index+1 == i2c_ByteCount)								// Если буфер кончится на этом байте, то
;PCODE: $00000E24 VOL: 0
;PCODE: $00000E25 VOL: 0
;PCODE: $00000E26 VOL: 0
;PCODE: $00000E27 VOL: 0
;PCODE: $00000E28 VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;	// Требуем байт, а в ответ потом пошлем NACK(Disconnect)
;PCODE: $00000E29 VOL: 0
;PCODE: $00000E2A VOL: 0
;				}															// Что даст понять слейву, что мол хватит гнать. И он отпустит шину
;			else
;PCODE: $00000E2B VOL: 0
;PCODE: $00000E2C VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;	// Или просто примем байт и скажем потом ACK
;PCODE: $00000E2D VOL: 0
;PCODE: $00000E2E VOL: 0
;				}
;PCODE: $00000E2F VOL: 0
;
;			break;
;PCODE: $00000E30 VOL: 0
;			}
;
;	case 0x48: // Послали SLA+R, но получили NACK. Видать slave занят или его нет дома.
;PCODE: $00000E31 VOL: 0
;PCODE: $00000E32 VOL: 0
;PCODE: $00000E33 VOL: 0
;			{
;			i2c_Do |= i2c_ERR_NA;															// Код ошибки No Answer
;PCODE: $00000E34 VOL: 0
;PCODE: $00000E35 VOL: 0
;PCODE: $00000E36 VOL: 0
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;			// Шлем Stop
;PCODE: $00000E37 VOL: 0
;PCODE: $00000E38 VOL: 0
;
;			MACRO_i2c_WhatDo_ErrorOut														// Отрабатываем выходную ситуацию ошибки
;PCODE: $00000E39 VOL: 0
;PCODE: $00000E3A VOL: 0
;			break;
;PCODE: $00000E3B VOL: 0
;			}
;
;	case 0x50: // Приняли байт.
;PCODE: $00000E3C VOL: 0
;PCODE: $00000E3D VOL: 0
;PCODE: $00000E3E VOL: 0
;			{
;			i2c_Buffer[i2c_index] = TWDR;			// Забрали его из буфера
;PCODE: $00000E3F VOL: 0
;PCODE: $00000E40 VOL: 0
;PCODE: $00000E41 VOL: 0
;PCODE: $00000E42 VOL: 0
;PCODE: $00000E43 VOL: 0
;			i2c_index++;
;PCODE: $00000E44 VOL: 0
;PCODE: $00000E45 VOL: 0
;PCODE: $00000E46 VOL: 0
;
;			// To Do: Добавить проверку переполнения буфера. А то мало ли что юзер затребует
;
;			if (i2c_index+1 == i2c_ByteCount)		// Если остался еще один байт из тех, что мы хотели считать
;PCODE: $00000E47 VOL: 0
;PCODE: $00000E48 VOL: 0
;PCODE: $00000E49 VOL: 0
;PCODE: $00000E4A VOL: 0
;PCODE: $00000E4B VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;		// Затребываем его и потом пошлем NACK (Disconnect)
;PCODE: $00000E4C VOL: 0
;PCODE: $00000E4D VOL: 0
;				}
;			else
;PCODE: $00000E4E VOL: 0
;PCODE: $00000E4F VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;		// Если нет, то затребываем следующий байт, а в ответ скажем АСК
;PCODE: $00000E50 VOL: 0
;PCODE: $00000E51 VOL: 0
;				}
;PCODE: $00000E52 VOL: 0
;			break;
;PCODE: $00000E53 VOL: 0
;			}
;
;	case 0x58:	// Вот мы взяли последний байт, сказали NACK слейв обиделся и отпал.
;PCODE: $00000E54 VOL: 0
;PCODE: $00000E55 VOL: 0
;PCODE: $00000E56 VOL: 0
;			{
;			i2c_Buffer[i2c_index] = TWDR;													// Взяли байт в буфер
;PCODE: $00000E57 VOL: 0
;PCODE: $00000E58 VOL: 0
;PCODE: $00000E59 VOL: 0
;PCODE: $00000E5A VOL: 0
;PCODE: $00000E5B VOL: 0
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;			// Передали Stop
;PCODE: $00000E5C VOL: 0
;PCODE: $00000E5D VOL: 0
;
;			MACRO_i2c_WhatDo_MasterOut														// Отработали точку выхода
;PCODE: $00000E5E VOL: 0
;PCODE: $00000E5F VOL: 0
;
;			break;
;PCODE: $00000E60 VOL: 0
;			}
;
;// IIC  Slave ============================================================================
;
;	case 0x68:	// RCV SLA+W Low Priority							// Словили свой адрес во время передачи мастером
;PCODE: $00000E61 VOL: 0
;PCODE: $00000E62 VOL: 0
;PCODE: $00000E63 VOL: 0
;	case 0x78:	// RCV SLA+W Low Priority (Broadcast)				// Или это был широковещательный пакет. Не важно
;PCODE: $00000E64 VOL: 0
;PCODE: $00000E65 VOL: 0
;PCODE: $00000E66 VOL: 0
;PCODE: $00000E67 VOL: 0
;PCODE: $00000E68 VOL: 0
;			{
;			i2c_Do |= i2c_ERR_LP | i2c_Interrupted;					// Ставим флаг ошибки Low Priority, а также флаг того, что мастера прервали
;PCODE: $00000E69 VOL: 0
;PCODE: $00000E6A VOL: 0
;PCODE: $00000E6B VOL: 0
;
;			// Restore Trans after.
;			i2c_index = 0;											// Подготовили прерваную передачу заново
;PCODE: $00000E6C VOL: 0
;PCODE: $00000E6D VOL: 0
;			i2c_PageAddrIndex = 0;
;PCODE: $00000E6E VOL: 0
;PCODE: $00000E6F VOL: 0
;			}														// И пошли дальше. Внимание!!! break тут нет, а значит идем в "case 60"
;
;	case 0x60: // RCV SLA+W  Incoming?								// Или просто получили свой адрес
;PCODE: $00000E70 VOL: 0
;PCODE: $00000E71 VOL: 0
;PCODE: $00000E72 VOL: 0
;PCODE: $00000E73 VOL: 0
;PCODE: $00000E74 VOL: 0
;	case 0x70: // RCV SLA+W  Incoming? (Broascast)					// Или широковещательный пакет
;PCODE: $00000E75 VOL: 0
;PCODE: $00000E76 VOL: 0
;PCODE: $00000E77 VOL: 0
;PCODE: $00000E78 VOL: 0
;PCODE: $00000E79 VOL: 0
;			{
;
;			i2c_Do |= i2c_Busy;										// Занимаем шину. Чтобы другие не совались
;PCODE: $00000E7A VOL: 0
;PCODE: $00000E7B VOL: 0
;PCODE: $00000E7C VOL: 0
;			i2c_SlaveIndex = 0;										// Указатель на начало буфера слейва, Неважно какой буфер. Не ошибемся
;PCODE: $00000E7D VOL: 0
;PCODE: $00000E7E VOL: 0
;
;			if (i2c_MasterBytesRX == 1)								// Если нам суждено принять всего один байт, то готовимся принять  его
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;			// Принять и сказать пошли все н... NACK!
;PCODE: $00000E7F VOL: 0
;PCODE: $00000E80 VOL: 0
;				}
;			else
;PCODE: $00000E81 VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// А если душа шире чем один байт, то сожрем и потребуем еще ACK!
;PCODE: $00000E82 VOL: 0
;PCODE: $00000E83 VOL: 0
;				}
;PCODE: $00000E84 VOL: 0
;			break;
;PCODE: $00000E85 VOL: 0
;			}
;
;	case 0x80:	// RCV Data Byte									// И вот мы приняли этот байт. Наш или широковещательный. Не важно
;PCODE: $00000E86 VOL: 0
;PCODE: $00000E87 VOL: 0
;PCODE: $00000E88 VOL: 0
;	case 0x90:	// RCV Data Byte (Broadcast)
;PCODE: $00000E89 VOL: 0
;PCODE: $00000E8A VOL: 0
;PCODE: $00000E8B VOL: 0
;PCODE: $00000E8C VOL: 0
;PCODE: $00000E8D VOL: 0
;			{
;			i2c_InBuff[i2c_SlaveIndex] = TWDR;						// Сжираем его в буфер.
;PCODE: $00000E8E VOL: 0
;PCODE: $00000E8F VOL: 0
;PCODE: $00000E90 VOL: 0
;PCODE: $00000E91 VOL: 0
;PCODE: $00000E92 VOL: 0
;
;			i2c_SlaveIndex++;										// Сдвигаем указатель
;PCODE: $00000E93 VOL: 0
;PCODE: $00000E94 VOL: 0
;PCODE: $00000E95 VOL: 0
;
;			if (i2c_SlaveIndex == i2c_MasterBytesRX-1) 				// Свободно место всего под один байт?
;PCODE: $00000E96 VOL: 0
;PCODE: $00000E97 VOL: 0
;PCODE: $00000E98 VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;			// Приянть его и сказать NACK!
;PCODE: $00000E99 VOL: 0
;PCODE: $00000E9A VOL: 0
;				}
;			else
;PCODE: $00000E9B VOL: 0
;PCODE: $00000E9C VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Места еще дофига? Принять и ACK!
;PCODE: $00000E9D VOL: 0
;PCODE: $00000E9E VOL: 0
;				}
;PCODE: $00000E9F VOL: 0
;			break;
;PCODE: $00000EA0 VOL: 0
;			}
;
;	case 0x88: // RCV Last Byte										// Приянли последний байт
;PCODE: $00000EA1 VOL: 0
;PCODE: $00000EA2 VOL: 0
;PCODE: $00000EA3 VOL: 0
;	case 0x98: // RCV Last Byte (Broadcast)
;PCODE: $00000EA4 VOL: 0
;PCODE: $00000EA5 VOL: 0
;PCODE: $00000EA6 VOL: 0
;PCODE: $00000EA7 VOL: 0
;PCODE: $00000EA8 VOL: 0
;			{
;			i2c_InBuff[i2c_SlaveIndex] = TWDR;						// Сожрали его в буфер
;PCODE: $00000EA9 VOL: 0
;PCODE: $00000EAA VOL: 0
;PCODE: $00000EAB VOL: 0
;PCODE: $00000EAC VOL: 0
;PCODE: $00000EAD VOL: 0
;
;			if (i2c_Do & i2c_Interrupted)							// Если у нас был прерываный сеанс от имени мастера
;PCODE: $00000EAE VOL: 0
;PCODE: $00000EAF VOL: 0
;PCODE: $00000EB0 VOL: 0
;				{
;				TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Влепим в шину свой Start поскорей и сделаем еще одну попытку
;PCODE: $00000EB1 VOL: 0
;PCODE: $00000EB2 VOL: 0
;				}
;			else
;PCODE: $00000EB3 VOL: 0
;PCODE: $00000EB4 VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Если не было такого факта, то просто отвалимся и будем ждать
;PCODE: $00000EB5 VOL: 0
;PCODE: $00000EB6 VOL: 0
;				}
;PCODE: $00000EB7 VOL: 0
;
;			MACRO_i2c_WhatDo_SlaveOut												// И лениво отработаем наш выходной экшн для слейва
;PCODE: $00000EB8 VOL: 0
;PCODE: $00000EB9 VOL: 0
;			break;
;PCODE: $00000EBA VOL: 0
;			}
;
;
;	case 0xA0: // Ой, мы получили Повторный старт. Но чо нам с ним делать?
;PCODE: $00000EBB VOL: 0
;PCODE: $00000EBC VOL: 0
;PCODE: $00000EBD VOL: 0
;			{
;			// Можно, конечно, сделать вспомогательный автомат, чтобы обрабатывать еще и адреса внутренних страниц, подобно еепромке.
;			// Но я не стал заморачиваться. В этом случае делается это тут.
;
;			TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// просто разадресуемся, проигнорировав этот посыл
;PCODE: $00000EBE VOL: 0
;PCODE: $00000EBF VOL: 0
;			break;
;PCODE: $00000EC0 VOL: 0
;			}
;
;
;
;	case 0xB0:  // Поймали свой адрес на чтение во время передачи Мастером
;PCODE: $00000EC1 VOL: 0
;PCODE: $00000EC2 VOL: 0
;PCODE: $00000EC3 VOL: 0
;			{
;			i2c_Do |= i2c_ERR_LP | i2c_Interrupted;			// Ну чо, коды ошибки и флаг прерваной передачи.
;PCODE: $00000EC4 VOL: 0
;PCODE: $00000EC5 VOL: 0
;PCODE: $00000EC6 VOL: 0
;
;			// Восстанавливаем индексы
;			i2c_index = 0;
;PCODE: $00000EC7 VOL: 0
;PCODE: $00000EC8 VOL: 0
;			i2c_PageAddrIndex = 0;
;PCODE: $00000EC9 VOL: 0
;PCODE: $00000ECA VOL: 0
;			}												// Break нет! Идем дальше
;
;	case 0xA8:	// // Либо просто словили свой адрес на чтение
;PCODE: $00000ECB VOL: 0
;PCODE: $00000ECC VOL: 0
;PCODE: $00000ECD VOL: 0
;PCODE: $00000ECE VOL: 0
;PCODE: $00000ECF VOL: 0
;			{
;			i2c_SlaveIndex = 0;								// Индексы слейвовых массивов на 0
;PCODE: $00000ED0 VOL: 0
;PCODE: $00000ED1 VOL: 0
;
;			TWDR = i2c_OutBuff[i2c_SlaveIndex];				// Чтож, отдадим байт из тех что есть.
;PCODE: $00000ED2 VOL: 0
;PCODE: $00000ED3 VOL: 0
;PCODE: $00000ED4 VOL: 0
;PCODE: $00000ED5 VOL: 0
;PCODE: $00000ED6 VOL: 0
;
;			if(i2c_MasterBytesTX == 1)
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;	// Если он последний, мы еще на NACK в ответ надеемся
;PCODE: $00000ED7 VOL: 0
;PCODE: $00000ED8 VOL: 0
;				}
;			else
;PCODE: $00000ED9 VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;	// А если нет, то  ACK ждем
;PCODE: $00000EDA VOL: 0
;PCODE: $00000EDB VOL: 0
;				}
;PCODE: $00000EDC VOL: 0
;
;			break;
;PCODE: $00000EDD VOL: 0
;			}
;
;
;	case 0xB8: // Послали байт, получили ACK
;PCODE: $00000EDE VOL: 0
;PCODE: $00000EDF VOL: 0
;PCODE: $00000EE0 VOL: 0
;			{
;
;			i2c_SlaveIndex++;								// Значит продолжаем дискотеку. Берем следующий байт
;PCODE: $00000EE1 VOL: 0
;PCODE: $00000EE2 VOL: 0
;PCODE: $00000EE3 VOL: 0
;			TWDR = i2c_OutBuff[i2c_SlaveIndex];				// Даем его мастеру
;PCODE: $00000EE4 VOL: 0
;PCODE: $00000EE5 VOL: 0
;PCODE: $00000EE6 VOL: 0
;PCODE: $00000EE7 VOL: 0
;PCODE: $00000EE8 VOL: 0
;
;			if (i2c_SlaveIndex == i2c_MasterBytesTX-1)		// Если он последний был, то
;PCODE: $00000EE9 VOL: 0
;PCODE: $00000EEA VOL: 0
;PCODE: $00000EEB VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;	// Шлем его и ждем NACK
;PCODE: $00000EEC VOL: 0
;PCODE: $00000EED VOL: 0
;				}
;			else
;PCODE: $00000EEE VOL: 0
;PCODE: $00000EEF VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|0<<TWEN|1<<TWIE;	// Если нет, то шлем и ждем ACK
;PCODE: $00000EF0 VOL: 0
;PCODE: $00000EF1 VOL: 0
;				}
;PCODE: $00000EF2 VOL: 0
;
;			break;
;PCODE: $00000EF3 VOL: 0
;			}
;
;	case 0xC0: // Мы выслали последний байт, больше у нас нет, получили NACK
;PCODE: $00000EF4 VOL: 0
;PCODE: $00000EF5 VOL: 0
;PCODE: $00000EF6 VOL: 0
;	case 0xC8: // или ACK. В данном случае нам пох. Т.к. больше байтов у нас нет.
;PCODE: $00000EF7 VOL: 0
;PCODE: $00000EF8 VOL: 0
;PCODE: $00000EF9 VOL: 0
;PCODE: $00000EFA VOL: 0
;PCODE: $00000EFB VOL: 0
;			{
;			if (i2c_Do & i2c_Interrupted)											// Если там была прерваная передача мастера
;PCODE: $00000EFC VOL: 0
;PCODE: $00000EFD VOL: 0
;PCODE: $00000EFE VOL: 0
;				{																	// То мы ему ее вернем
;				i2c_Do &= i2c_NoInterrupted;										// Снимем флаг прерваности
;PCODE: $00000EFF VOL: 0
;PCODE: $00000F00 VOL: 0
;PCODE: $00000F01 VOL: 0
;				TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Сгенерим старт сразу же как получим шину.
;PCODE: $00000F02 VOL: 0
;PCODE: $00000F03 VOL: 0
;				}
;			else
;PCODE: $00000F04 VOL: 0
;PCODE: $00000F05 VOL: 0
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Если мы там одни, то просто отдадим шину
;PCODE: $00000F06 VOL: 0
;PCODE: $00000F07 VOL: 0
;				}
;PCODE: $00000F08 VOL: 0
;
;			MACRO_i2c_WhatDo_SlaveOut												// И отработаем выход слейва. Впрочем, он тут
;PCODE: $00000F09 VOL: 0
;PCODE: $00000F0A VOL: 0
;																					// Не особо то нужен. Разве что как сигнал, что мастер
;			break;																	// Нас почтил своим визитом.
;PCODE: $00000F0B VOL: 0
;			}
;
;	default:	break;
;PCODE: $00000F0C VOL: 0
;PCODE: $00000F0D VOL: 0
;	}
;PCODE: $00000F0E VOL: 0
;}
;PCODE: $00000F0F VOL: 0
;PCODE: $00000F10 VOL: 0
;PCODE: $00000F11 VOL: 0
;
;void DoNothing(void)																// Функция пустышка, затыкать несуществующие ссылки
;{
;PCODE: $00000F12 VOL: 0
;PCODE: $00000F13 VOL: 0
;}
;PCODE: $00000F14 VOL: 0
;PCODE: $00000F15 VOL: 0
;
;void Init_i2c(void)							// Настройка режима мастера
;{
;PCODE: $00000F16 VOL: 0
;PCODE: $00000F17 VOL: 0
;i2c_PORT |= 1<<i2c_SCL|1<<i2c_SDA;			// Включим подтяжку на ноги, вдруг юзер на резисторы пожмотился
;PCODE: $00000F18 VOL: 0
;PCODE: $00000F19 VOL: 0
;PCODE: $00000F1A VOL: 0
;i2c_DDR &=~(1<<i2c_SCL|1<<i2c_SDA);
;PCODE: $00000F1B VOL: 0
;PCODE: $00000F1C VOL: 0
;PCODE: $00000F1D VOL: 0
;
;TWBR = 0xFF;         						// Настроим битрейт
;PCODE: $00000F1E VOL: 0
;PCODE: $00000F1F VOL: 0
;TWSR = 0x03;
;PCODE: $00000F20 VOL: 0
;PCODE: $00000F21 VOL: 0
;/*
;// Bit Rate: 400,000 kHz
;TWBR=0x02;
;// Two Wire Bus Slave Address: 0x0
;// General Call Recognition: Off
;TWAR=0x00;
;// Generate Acknowledge Pulse: Off
;// TWI Interrupt: On
;TWCR = (1<<TWIE)|(1<<TWEN) ;
;TWSR=0x00;*/
;}
;PCODE: $00000F22 VOL: 0
;PCODE: $00000F23 VOL: 0
;
;void Init_Slave_i2c(IIC_F Addr)				// Настройка режима слейва (если нужно)
;{
;PCODE: $00000F24 VOL: 0
;PCODE: $00000F25 VOL: 0
;TWAR = i2c_MasterAddress;					// Внесем в регистр свой адрес, на который будем отзываться.
;	*Addr -> Y+0
;PCODE: $00000F26 VOL: 0
;PCODE: $00000F27 VOL: 0
;											// 1 в нулевом бите означает, что мы отзываемся на широковещательные пакеты
;SlaveOutFunc = Addr;						// Присвоим указателю выхода по слейву функцию выхода
;PCODE: $00000F28 VOL: 0
;PCODE: $00000F29 VOL: 0
;
;TWCR = 0<<TWSTA|0<<TWSTO|0<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;		// Включаем агрегат и начинаем слушать шину.
;PCODE: $00000F2A VOL: 0
;PCODE: $00000F2B VOL: 0
;}
;PCODE: $00000F2C VOL: 0
;PCODE: $00000F2D VOL: 0
;PCODE: $00000F2E VOL: 0
;#include "D_i2c_AT24C_EEP/i2c_AT24C_EEP.h"
;
;
;#define HI(X) (X>>8)
;#define LO(X) (X & 0xFF)
;
;uint8_t i2c_eep_WriteByte(uint8_t SAddr,uint16_t Addr, uint8_t Byte, IIC_F WhatDo)
;{
;PCODE: $00000F2F VOL: 0
;PCODE: $00000F30 VOL: 0
;
;if (i2c_Do & i2c_Busy) return 0;
;	SAddr -> Y+5
;	Addr -> Y+3
;	Byte -> Y+2
;	*WhatDo -> Y+0
;PCODE: $00000F31 VOL: 0
;PCODE: $00000F32 VOL: 0
;PCODE: $00000F33 VOL: 0
;PCODE: $00000F34 VOL: 0
;PCODE: $00000F35 VOL: 0
;PCODE: $00000F36 VOL: 0
;
;i2c_index = 0;
;PCODE: $00000F37 VOL: 0
;PCODE: $00000F38 VOL: 0
;PCODE: $00000F39 VOL: 0
;i2c_ByteCount = 3;
;PCODE: $00000F3A VOL: 0
;PCODE: $00000F3B VOL: 0
;
;i2c_SlaveAddress = SAddr;
;PCODE: $00000F3C VOL: 0
;PCODE: $00000F3D VOL: 0
;
;
;i2c_Buffer[0] = HI(Addr);
;PCODE: $00000F3E VOL: 0
;PCODE: $00000F3F VOL: 0
;i2c_Buffer[1] = LO(Addr);
;PCODE: $00000F40 VOL: 0
;PCODE: $00000F41 VOL: 0
;PCODE: $00000F42 VOL: 0
;PCODE: $00000F43 VOL: 0
;i2c_Buffer[2] = Byte;
;PCODE: $00000F44 VOL: 0
;PCODE: $00000F45 VOL: 0
;PCODE: $00000F46 VOL: 0
;
;i2c_Do = i2c_sawp;
;PCODE: $00000F47 VOL: 0
;PCODE: $00000F48 VOL: 0
;
;MasterOutFunc = WhatDo;
;PCODE: $00000F49 VOL: 0
;PCODE: $00000F4A VOL: 0
;ErrorOutFunc = WhatDo;
;PCODE: $00000F4B VOL: 0
;PCODE: $00000F4C VOL: 0
;
;TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;
;PCODE: $00000F4D VOL: 0
;PCODE: $00000F4E VOL: 0
;
;i2c_Do |= i2c_Busy;
;PCODE: $00000F4F VOL: 0
;PCODE: $00000F50 VOL: 0
;PCODE: $00000F51 VOL: 0
;
;return 1;
;PCODE: $00000F52 VOL: 0
;PCODE: $00000F53 VOL: 0
;PCODE: $00000F54 VOL: 0
;}
;PCODE: $00000F55 VOL: 0
;
;
;uint8_t i2c_eep_ReadByte(uint8_t SAddr, uint16_t Addr, uint8_t ByteNumber, IIC_F WhatDo)
;{
;PCODE: $00000F56 VOL: 0
;PCODE: $00000F57 VOL: 0
;if (i2c_Do & i2c_Busy) return 0;
;	SAddr -> Y+5
;	Addr -> Y+3
;	ByteNumber -> Y+2
;	*WhatDo -> Y+0
;PCODE: $00000F58 VOL: 0
;PCODE: $00000F59 VOL: 0
;PCODE: $00000F5A VOL: 0
;PCODE: $00000F5B VOL: 0
;PCODE: $00000F5C VOL: 0
;PCODE: $00000F5D VOL: 0
;
;i2c_index = 0;
;PCODE: $00000F5E VOL: 0
;PCODE: $00000F5F VOL: 0
;PCODE: $00000F60 VOL: 0
;i2c_ByteCount = ByteNumber;
;PCODE: $00000F61 VOL: 0
;PCODE: $00000F62 VOL: 0
;
;i2c_SlaveAddress = SAddr;
;PCODE: $00000F63 VOL: 0
;PCODE: $00000F64 VOL: 0
;
;i2c_PageAddress[0] = HI(Addr);
;PCODE: $00000F65 VOL: 0
;PCODE: $00000F66 VOL: 0
;i2c_PageAddress[1] = LO(Addr);
;PCODE: $00000F67 VOL: 0
;PCODE: $00000F68 VOL: 0
;PCODE: $00000F69 VOL: 0
;PCODE: $00000F6A VOL: 0
;
;i2c_PageAddrIndex = 0;
;PCODE: $00000F6B VOL: 0
;PCODE: $00000F6C VOL: 0
;i2c_PageAddrCount = 2;
;PCODE: $00000F6D VOL: 0
;PCODE: $00000F6E VOL: 0
;
;i2c_Do = i2c_sawsarp;
;PCODE: $00000F6F VOL: 0
;PCODE: $00000F70 VOL: 0
;
;MasterOutFunc = WhatDo;
;PCODE: $00000F71 VOL: 0
;PCODE: $00000F72 VOL: 0
;ErrorOutFunc = WhatDo;
;PCODE: $00000F73 VOL: 0
;PCODE: $00000F74 VOL: 0
;
;TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;
;PCODE: $00000F75 VOL: 0
;PCODE: $00000F76 VOL: 0
;
;i2c_Do |= i2c_Busy;
;PCODE: $00000F77 VOL: 0
;PCODE: $00000F78 VOL: 0
;PCODE: $00000F79 VOL: 0
;
;return 1;
;PCODE: $00000F7A VOL: 0
;PCODE: $00000F7B VOL: 0
;PCODE: $00000F7C VOL: 0
;}
;PCODE: $00000F7D VOL: 0
;#include <adapter.h>
;
;//initialize watchdog
;void WDT_Init(void)
;{
;PCODE: $00000F7E VOL: 0
;PCODE: $00000F7F VOL: 0
;#asm("cli")//disable interrupts
;PCODE: $00000F80 VOL: 0
	cli
;PCODE: $00000F81 VOL: 0
;#asm("wdr")//reset watchdog
;PCODE: $00000F82 VOL: 0
	wdr
;PCODE: $00000F83 VOL: 0
;//set up WDT interrupt
;WDTCR = (1<<WDCE)|(1<<WDE);
;PCODE: $00000F84 VOL: 0
;PCODE: $00000F85 VOL: 0
;//Start watchdog timer with 2s prescaller
;WDTCR = (1<<WDP2)|(1<<WDP1)|(1<<WDP0);
;PCODE: $00000F86 VOL: 0
;PCODE: $00000F87 VOL: 0
;#asm("sei")//Enable global interrupts
;PCODE: $00000F88 VOL: 0
	sei
;PCODE: $00000F89 VOL: 0
;}
;PCODE: $00000F8A VOL: 0
;PCODE: $00000F8B VOL: 0
;/*
;//Watchdog timeout ISR
;ISR(WDT_vect)
;{
;    //Burst of fice 0.1Hz pulses
;    for (uint8_t i=0;i<4;i++)
;    {
;        //LED ON
;        PORTD|=(1<<PD2);
;        //~0.1s delay
;        _delay_ms(20);
;        //LED OFF
;        PORTD&=~(1<<PD2);
;        _delay_ms(80);
;    }
; */
;#include <adapter.h>
;
;#include "D_usart/usart.h"
;//#include "D_usart/usart.c"
;
;#include "global_variables.h"
;
;interrupt [ADC_INT] void adc_isr(void)// ADC interrupt service routine
;{
;PCODE: $00000F8C VOL: 0
;PCODE: $00000F8D VOL: 0
; adc_result=ADCW*3-ADCW/7; //умножаем чтобы получить мВ и немного учитываем погрешности
;PCODE: $00000F8E VOL: 0
;PCODE: $00000F8F VOL: 0
;PCODE: $00000F90 VOL: 0
;PCODE: $00000F91 VOL: 0
;PCODE: $00000F92 VOL: 0
;PCODE: $00000F93 VOL: 0
;PCODE: $00000F94 VOL: 0
;PCODE: $00000F95 VOL: 0
;PCODE: $00000F96 VOL: 0
;PCODE: $00000F97 VOL: 0
;PCODE: $00000F98 VOL: 1
;  ADCSRA=0;  //выкл
;PCODE: $00000F99 VOL: 0
;PCODE: $00000F9A VOL: 0
;}
;PCODE: $00000F9B VOL: 0
;PCODE: $00000F9C VOL: 0
;PCODE: $00000F9D VOL: 0
;
;
;
;
;
;
;/*   //теперь исспользуется прерывание ртос!
;// Timer2 output compare interrupt service routine
;interrupt [TIM2_COMP] void timer2_comp_isr(void)
;{
;SYS_TICK++;
;   //  if (USART_Get_rxCount(USART_0) > 0) //если в приёмном буфере что-то есть
;   //    {
;   //     symbol = USART_GetChar(USART_0);
;   //     --Parser_req_state_cnt; //  Декримент счётчика вызова парсера
;
;            #warning not_optimized
;   //      if(Parser_req_state_cnt % 5 != 0) //Обычно просто ставится флаг..
;   //      {
;   //        _set(fl.Parser_Req);  //- опросить парсер в главном цикле,..
;   //      }
;   //      else //..но 1 раз в 5 прерываний он обрабатывается прямо сдесь..
;   //      {
;   //         PARS_Parser(symbol);//..если вдруг главный цикл завис
;   //      }
;   //    }
;}
;     */
;#include <adapter.h>
;
;#include "RTOS/EERTOS.h"
;#include "RTOS/EERTOSHAL.h"
; #include "D_Tasks/task_list.h"
;/*
;Обработчик результата парсера.(команд)
;Эта функция вызывается парсером после обработки
;последовательности, но при условии приема хотя бы
;одного слова.Вызывать эту функцию самому не нужно
;*/
;
;
;
;/*
;void red_blink(void){
;char t=4;
;    do{
;    LED_RED_ON;
;    delay_ms(100);
;    LED_RED_OFF;
;    delay_ms(200);
;    }while(--t);
;}  */
;
;
;uint8_t check_after_pow_on(void)     /*need optimisation*/
;{
;PCODE: $00000F9E VOL: 0
;PCODE: $00000F9F VOL: 0
;//uint8_t state = 0;
;
;/*#1 check periferie*/
;//if (PINA!=0){printf("P_A=%d\r",PINA);}
;//if (PINB!=0){printf("P_B=%d\r",PINB);}
;//if (PINC!=0){printf("P_C=%d\r",PINC);}
;//if (PIND!=0){printf("P_D=%d\r\n",PIND);}
;
;
;/*#2 check reset source*/
;/*The MCU Control and Status Register provides
;information on which reset source caused an MCU Reset*/
;if (MCUCSR & (1<<PORF))// Power-on Reset
;PCODE: $00000FA0 VOL: 0
;PCODE: $00000FA1 VOL: 0
;PCODE: $00000FA2 VOL: 0
;PCODE: $00000FA3 VOL: 0
;   {
;    printf("porf\r\n");
;PCODE: $00000FA4 VOL: 0
;PCODE: $00000FA5 VOL: 0
;PCODE: $00000FA6 VOL: 0
;PCODE: $00000FA7 VOL: 0
;PCODE: $00000FA8 VOL: 0
;PCODE: $00000FA9 VOL: 0
;PCODE: $00000FAA VOL: 0
;   }
;else if (MCUCSR & (1<<EXTRF))// External Reset
;PCODE: $00000FAB VOL: 0
;PCODE: $00000FAC VOL: 0
;PCODE: $00000FAD VOL: 0
;PCODE: $00000FAE VOL: 0
;PCODE: $00000FAF VOL: 0
;PCODE: $00000FB0 VOL: 0
;   {
;    printf("extrf\r\n");
;PCODE: $00000FB1 VOL: 0
;PCODE: $00000FB2 VOL: 0
;PCODE: $00000FB3 VOL: 0
;PCODE: $00000FB4 VOL: 0
;PCODE: $00000FB5 VOL: 0
;PCODE: $00000FB6 VOL: 0
;PCODE: $00000FB7 VOL: 0
;   }
;else if (MCUCSR & (1<<BORF))// Brown-Out Reset
;PCODE: $00000FB8 VOL: 0
;PCODE: $00000FB9 VOL: 0
;PCODE: $00000FBA VOL: 0
;PCODE: $00000FBB VOL: 0
;PCODE: $00000FBC VOL: 0
;PCODE: $00000FBD VOL: 0
;   {
;    printf("borf\r\n");
;PCODE: $00000FBE VOL: 0
;PCODE: $00000FBF VOL: 0
;PCODE: $00000FC0 VOL: 0
;PCODE: $00000FC1 VOL: 0
;PCODE: $00000FC2 VOL: 0
;PCODE: $00000FC3 VOL: 0
;PCODE: $00000FC4 VOL: 0
;   }
;else if (MCUCSR & (1<<WDRF))// Watchdog Reset
;PCODE: $00000FC5 VOL: 0
;PCODE: $00000FC6 VOL: 0
;PCODE: $00000FC7 VOL: 0
;PCODE: $00000FC8 VOL: 0
;PCODE: $00000FC9 VOL: 0
;PCODE: $00000FCA VOL: 0
;   {
;    printf("wdrf\r\n");
;PCODE: $00000FCB VOL: 0
;PCODE: $00000FCC VOL: 0
;PCODE: $00000FCD VOL: 0
;PCODE: $00000FCE VOL: 0
;PCODE: $00000FCF VOL: 0
;PCODE: $00000FD0 VOL: 0
;PCODE: $00000FD1 VOL: 0
;   }
;else if (MCUCSR & (1<<JTRF))// JTAG Reset
;PCODE: $00000FD2 VOL: 0
;PCODE: $00000FD3 VOL: 0
;PCODE: $00000FD4 VOL: 0
;PCODE: $00000FD5 VOL: 0
;PCODE: $00000FD6 VOL: 0
;PCODE: $00000FD7 VOL: 0
;   {
;    printf("JTRF\r\n");
;PCODE: $00000FD8 VOL: 0
;PCODE: $00000FD9 VOL: 0
;PCODE: $00000FDA VOL: 0
;PCODE: $00000FDB VOL: 0
;PCODE: $00000FDC VOL: 0
;PCODE: $00000FDD VOL: 0
;PCODE: $00000FDE VOL: 0
;   }
;
;MCUCSR&=~((1<<JTRF) | (1<<WDRF) | (1<<BORF) | (1<<EXTRF) | (1<<PORF));//clear register
;PCODE: $00000FDF VOL: 0
;PCODE: $00000FE0 VOL: 0
;PCODE: $00000FE1 VOL: 0
;PCODE: $00000FE2 VOL: 0
;PCODE: $00000FE3 VOL: 0
;PCODE: $00000FE4 VOL: 0
;PCODE: $00000FE5 VOL: 0
;PCODE: $00000FE6 VOL: 0
;return 0;
;PCODE: $00000FE7 VOL: 0
;PCODE: $00000FE8 VOL: 0
;}
;PCODE: $00000FE9 VOL: 0
;
;
;void TIM2_ON(void){
;PCODE: $00000FEA VOL: 0
;PCODE: $00000FEB VOL: 0
;//TCCR2 |= (1<<CS21)|(1<<CS20);
;TCCR2 |= (1<<CS22)|(1<<CS21)|(1<<CS20);
;PCODE: $00000FEC VOL: 0
;PCODE: $00000FED VOL: 0
;PCODE: $00000FEE VOL: 0
;
;}
;PCODE: $00000FEF VOL: 0
;PCODE: $00000FF0 VOL: 0
;
;void TIM2_OFF(void){
;PCODE: $00000FF1 VOL: 0
;PCODE: $00000FF2 VOL: 0
;//TCCR2 &= ~((1<<CS21)|(1<<CS20));
;TCCR2 &= ~((1<<CS22)|(1<<CS21)|(1<<CS20));
;PCODE: $00000FF3 VOL: 0
;PCODE: $00000FF4 VOL: 0
;PCODE: $00000FF5 VOL: 0
;}
;PCODE: $00000FF6 VOL: 0
;PCODE: $00000FF7 VOL: 0
;
;void Sys_timer_init(void){ //USED BY RTOS (DONT TOUCH!)
;PCODE: $00000FF8 VOL: 0
;PCODE: $00000FF9 VOL: 0
;//Settings for Timer2
;OCR2 = 125; //125000 /125 = 1000 compare interruptes per second
;PCODE: $00000FFA VOL: 0
;PCODE: $00000FFB VOL: 0
;TCCR2 |= (1<<CS21)|(1<<CS20);//START timer (8Mhz div 64 = 125000)   //Upd-5 теперь 16МГц
;PCODE: $00000FFC VOL: 0
;PCODE: $00000FFD VOL: 0
;PCODE: $00000FFE VOL: 0
;TIMSK |= (1<<OCIE2); //compare interrupt EN
;PCODE: $00000FFF VOL: 0
;PCODE: $00001000 VOL: 0
;PCODE: $00001001 VOL: 0
;}
;PCODE: $00001002 VOL: 0
;PCODE: $00001003 VOL: 0
;
;
;void print_help(void){
;PCODE: $00001004 VOL: 0
;PCODE: $00001005 VOL: 0
;StopRTOS();
;PCODE: $00001006 VOL: 0
;USART_SendStrFl(SYSTEM_USART, help_mess_0);
;PCODE: $00001007 VOL: 0
;PCODE: $00001008 VOL: 0
;PCODE: $00001009 VOL: 0
;PCODE: $0000100A VOL: 0
;PCODE: $0000100B VOL: 0
;USART_SendStrFl(SYSTEM_USART, help_mess_1);
;PCODE: $0000100C VOL: 0
;PCODE: $0000100D VOL: 0
;PCODE: $0000100E VOL: 0
;PCODE: $0000100F VOL: 0
;PCODE: $00001010 VOL: 0
;USART_SendStrFl(SYSTEM_USART, help_mess_2);
;PCODE: $00001011 VOL: 0
;PCODE: $00001012 VOL: 0
;PCODE: $00001013 VOL: 0
;PCODE: $00001014 VOL: 0
;PCODE: $00001015 VOL: 0
;USART_SendStrFl(SYSTEM_USART, help_mess_3);
;PCODE: $00001016 VOL: 0
;PCODE: $00001017 VOL: 0
;PCODE: $00001018 VOL: 0
;PCODE: $00001019 VOL: 0
;PCODE: $0000101A VOL: 0
;USART_SendStrFl(SYSTEM_USART, help_mess_4);
;PCODE: $0000101B VOL: 0
;PCODE: $0000101C VOL: 0
;PCODE: $0000101D VOL: 0
;PCODE: $0000101E VOL: 0
;PCODE: $0000101F VOL: 0
;
;USART_SendStrFl(SYSTEM_USART,help_Uart_0);
;PCODE: $00001020 VOL: 0
;PCODE: $00001021 VOL: 0
;PCODE: $00001022 VOL: 0
;PCODE: $00001023 VOL: 0
;PCODE: $00001024 VOL: 0
;USART_SendStrFl(SYSTEM_USART,help_Uart_1);
;PCODE: $00001025 VOL: 0
;PCODE: $00001026 VOL: 0
;PCODE: $00001027 VOL: 0
;PCODE: $00001028 VOL: 0
;PCODE: $00001029 VOL: 0
;USART_SendStrFl(SYSTEM_USART,help_Spi_0);
;PCODE: $0000102A VOL: 0
;PCODE: $0000102B VOL: 0
;PCODE: $0000102C VOL: 0
;PCODE: $0000102D VOL: 0
;PCODE: $0000102E VOL: 0
;USART_SendStrFl(SYSTEM_USART,help_Spi_1);
;PCODE: $0000102F VOL: 0
;PCODE: $00001030 VOL: 0
;PCODE: $00001031 VOL: 0
;PCODE: $00001032 VOL: 0
;PCODE: $00001033 VOL: 0
;RunRTOS();
;PCODE: $00001034 VOL: 0
;}
;PCODE: $00001035 VOL: 0
;PCODE: $00001036 VOL: 0
;
;void print_settings_ram(void){
;PCODE: $00001037 VOL: 0
;PCODE: $00001038 VOL: 0
;uint8_t i = 0;
;char str[10];
;
;USART_SendStr(USART_0,"\r<RAM>");
;PCODE: $00001039 VOL: 0
;PCODE: $0000103A VOL: 0
;	i -> R17
;	str -> Y+1
;PCODE: $0000103B VOL: 0
;PCODE: $0000103C VOL: 0
;PCODE: $0000103D VOL: 0
;PCODE: $0000103E VOL: 0
;PCODE: $0000103F VOL: 0
;PCODE: $00001040 VOL: 0
;PCODE: $00001041 VOL: 0
;PCODE: $00001042 VOL: 0
;USART_SendStr(USART_0,"\rUART_SETTINGS\r");
;PCODE: $00001043 VOL: 0
;PCODE: $00001044 VOL: 0
;PCODE: $00001045 VOL: 0
;PCODE: $00001046 VOL: 0
;PCODE: $00001047 VOL: 0
;PCODE: $00001048 VOL: 0
;  for(i=0;i<COUNT_OF_UARTS;i++)
;PCODE: $00001049 VOL: 0
;PCODE: $0000104A VOL: 0
;PCODE: $0000104B VOL: 0
;PCODE: $0000104C VOL: 0
;PCODE: $0000104D VOL: 0
;PCODE: $0000104E VOL: 0
;PCODE: $0000104F VOL: 0
;PCODE: $00001050 VOL: 0
;PCODE: $00001051 VOL: 0
;    {
;    USART_SendStr(USART_0,"UART ");
;PCODE: $00001052 VOL: 0
;PCODE: $00001053 VOL: 0
;PCODE: $00001054 VOL: 0
;PCODE: $00001055 VOL: 0
;PCODE: $00001056 VOL: 0
;PCODE: $00001057 VOL: 0
;    ltoa(i,str);
;PCODE: $00001058 VOL: 0
;PCODE: $00001059 VOL: 0
;PCODE: $0000105A VOL: 0
;PCODE: $0000105B VOL: 0
;PCODE: $0000105C VOL: 0
;PCODE: $0000105D VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $0000105E VOL: 0
;PCODE: $0000105F VOL: 0
;PCODE: $00001060 VOL: 0
;PCODE: $00001061 VOL: 0
;PCODE: $00001062 VOL: 0
;
;    USART_SendStr(USART_0,"\r Mode ");
;PCODE: $00001063 VOL: 0
;PCODE: $00001064 VOL: 0
;PCODE: $00001065 VOL: 0
;PCODE: $00001066 VOL: 0
;PCODE: $00001067 VOL: 0
;PCODE: $00001068 VOL: 0
;    ltoa(RAM_settings.MODE_of_Uart[i],str);
;PCODE: $00001069 VOL: 0
;PCODE: $0000106A VOL: 0
;PCODE: $0000106B VOL: 0
;PCODE: $0000106C VOL: 0
;PCODE: $0000106D VOL: 0
;PCODE: $0000106E VOL: 0
;PCODE: $0000106F VOL: 0
;PCODE: $00001070 VOL: 0
;PCODE: $00001071 VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $00001072 VOL: 0
;PCODE: $00001073 VOL: 0
;PCODE: $00001074 VOL: 0
;PCODE: $00001075 VOL: 0
;PCODE: $00001076 VOL: 0
;
;    USART_SendStr(USART_0,"\r Speed ");
;PCODE: $00001077 VOL: 0
;PCODE: $00001078 VOL: 0
;PCODE: $00001079 VOL: 0
;PCODE: $0000107A VOL: 0
;PCODE: $0000107B VOL: 0
;PCODE: $0000107C VOL: 0
;    ltoa(RAM_settings.baud_of_Uart[i],str);
;PCODE: $0000107D VOL: 0
;PCODE: $0000107E VOL: 0
;PCODE: $0000107F VOL: 0
;PCODE: $00001080 VOL: 0
;PCODE: $00001081 VOL: 0
;PCODE: $00001082 VOL: 0
;PCODE: $00001083 VOL: 0
;PCODE: $00001084 VOL: 0
;PCODE: $00001085 VOL: 0
;PCODE: $00001086 VOL: 0
;PCODE: $00001087 VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $00001088 VOL: 0
;PCODE: $00001089 VOL: 0
;PCODE: $0000108A VOL: 0
;PCODE: $0000108B VOL: 0
;PCODE: $0000108C VOL: 0
;
;    USART_SendStr(USART_0,"\r--------\r");
;PCODE: $0000108D VOL: 0
;PCODE: $0000108E VOL: 0
;PCODE: $0000108F VOL: 0
;PCODE: $00001090 VOL: 0
;PCODE: $00001091 VOL: 0
;PCODE: $00001092 VOL: 0
;    }
;PCODE: $00001093 VOL: 0
;PCODE: $00001094 VOL: 0
;PCODE: $00001095 VOL: 0
;PCODE: $00001096 VOL: 0
;PCODE: $00001097 VOL: 0
;
;USART_SendStr(USART_0,"\rSPI_SETTINGS\r");
;PCODE: $00001098 VOL: 0
;PCODE: $00001099 VOL: 0
;PCODE: $0000109A VOL: 0
;PCODE: $0000109B VOL: 0
;PCODE: $0000109C VOL: 0
;PCODE: $0000109D VOL: 0
;  for(i=0;i<COUNT_OF_SPI;i++)
;PCODE: $0000109E VOL: 0
;PCODE: $0000109F VOL: 0
;PCODE: $000010A0 VOL: 0
;PCODE: $000010A1 VOL: 0
;PCODE: $000010A2 VOL: 0
;PCODE: $000010A3 VOL: 0
;PCODE: $000010A4 VOL: 0
;PCODE: $000010A5 VOL: 0
;PCODE: $000010A6 VOL: 0
;    {
;    USART_SendStr(USART_0,"SPI ");
;PCODE: $000010A7 VOL: 0
;PCODE: $000010A8 VOL: 0
;PCODE: $000010A9 VOL: 0
;PCODE: $000010AA VOL: 0
;PCODE: $000010AB VOL: 0
;PCODE: $000010AC VOL: 0
;    ltoa(i,str);
;PCODE: $000010AD VOL: 0
;PCODE: $000010AE VOL: 0
;PCODE: $000010AF VOL: 0
;PCODE: $000010B0 VOL: 0
;PCODE: $000010B1 VOL: 0
;PCODE: $000010B2 VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $000010B3 VOL: 0
;PCODE: $000010B4 VOL: 0
;PCODE: $000010B5 VOL: 0
;PCODE: $000010B6 VOL: 0
;PCODE: $000010B7 VOL: 0
;
;    USART_SendStr(USART_0,"\r Mode ");
;PCODE: $000010B8 VOL: 0
;PCODE: $000010B9 VOL: 0
;PCODE: $000010BA VOL: 0
;PCODE: $000010BB VOL: 0
;PCODE: $000010BC VOL: 0
;PCODE: $000010BD VOL: 0
;    ltoa(RAM_settings.MODE_of_Spi[i],str);
;PCODE: $000010BE VOL: 0
;PCODE: $000010BF VOL: 0
;PCODE: $000010C0 VOL: 0
;PCODE: $000010C1 VOL: 0
;PCODE: $000010C2 VOL: 0
;PCODE: $000010C3 VOL: 0
;PCODE: $000010C4 VOL: 0
;PCODE: $000010C5 VOL: 0
;PCODE: $000010C6 VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $000010C7 VOL: 0
;PCODE: $000010C8 VOL: 0
;PCODE: $000010C9 VOL: 0
;PCODE: $000010CA VOL: 0
;PCODE: $000010CB VOL: 0
;
;    USART_SendStr(USART_0,"\r Prescaller ");
;PCODE: $000010CC VOL: 0
;PCODE: $000010CD VOL: 0
;PCODE: $000010CE VOL: 0
;PCODE: $000010CF VOL: 0
;PCODE: $000010D0 VOL: 0
;PCODE: $000010D1 VOL: 0
;    ltoa(RAM_settings.prescaller_of_Spi[i],str);
;PCODE: $000010D2 VOL: 0
;PCODE: $000010D3 VOL: 0
;PCODE: $000010D4 VOL: 0
;PCODE: $000010D5 VOL: 0
;PCODE: $000010D6 VOL: 0
;PCODE: $000010D7 VOL: 0
;PCODE: $000010D8 VOL: 0
;PCODE: $000010D9 VOL: 0
;PCODE: $000010DA VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $000010DB VOL: 0
;PCODE: $000010DC VOL: 0
;PCODE: $000010DD VOL: 0
;PCODE: $000010DE VOL: 0
;PCODE: $000010DF VOL: 0
;
;    USART_SendStr(USART_0,"\r--------\r");
;PCODE: $000010E0 VOL: 0
;PCODE: $000010E1 VOL: 0
;PCODE: $000010E2 VOL: 0
;PCODE: $000010E3 VOL: 0
;PCODE: $000010E4 VOL: 0
;PCODE: $000010E5 VOL: 0
;    }
;PCODE: $000010E6 VOL: 0
;PCODE: $000010E7 VOL: 0
;PCODE: $000010E8 VOL: 0
;PCODE: $000010E9 VOL: 0
;PCODE: $000010EA VOL: 0
;//USART_FlushTxBuf(USART_0);
;}
;PCODE: $000010EB VOL: 0
;PCODE: $000010EC VOL: 0
;PCODE: $000010ED VOL: 0
;PCODE: $000010EE VOL: 0
;PCODE: $000010EF VOL: 0

	.DSEG
_0x1B7:
	.BYTE 0x6E
;
;void print_settings_eeprom(void){

	.CSEG
;PCODE: $000010F0 VOL: 0
;PCODE: $000010F1 VOL: 0
;uint8_t i = 0;
;char str[10];
;
;USART_SendStr(USART_0,"\r<EEPROM>");
;PCODE: $000010F2 VOL: 0
;PCODE: $000010F3 VOL: 0
;	i -> R17
;	str -> Y+1
;PCODE: $000010F4 VOL: 0
;PCODE: $000010F5 VOL: 0
;PCODE: $000010F6 VOL: 0
;PCODE: $000010F7 VOL: 0
;PCODE: $000010F8 VOL: 0
;PCODE: $000010F9 VOL: 0
;PCODE: $000010FA VOL: 0
;PCODE: $000010FB VOL: 0
;USART_SendStr(USART_0,"\rUART_SETTINGS\r");
;PCODE: $000010FC VOL: 0
;PCODE: $000010FD VOL: 0
;PCODE: $000010FE VOL: 0
;PCODE: $000010FF VOL: 0
;PCODE: $00001100 VOL: 0
;PCODE: $00001101 VOL: 0
;  for(i=0;i<COUNT_OF_UARTS;i++)
;PCODE: $00001102 VOL: 0
;PCODE: $00001103 VOL: 0
;PCODE: $00001104 VOL: 0
;PCODE: $00001105 VOL: 0
;PCODE: $00001106 VOL: 0
;PCODE: $00001107 VOL: 0
;PCODE: $00001108 VOL: 0
;PCODE: $00001109 VOL: 0
;PCODE: $0000110A VOL: 0
;    {
;    USART_SendStr(USART_0,"UART ");
;PCODE: $0000110B VOL: 0
;PCODE: $0000110C VOL: 0
;PCODE: $0000110D VOL: 0
;PCODE: $0000110E VOL: 0
;PCODE: $0000110F VOL: 0
;PCODE: $00001110 VOL: 0
;    ltoa(i,str);
;PCODE: $00001111 VOL: 0
;PCODE: $00001112 VOL: 0
;PCODE: $00001113 VOL: 0
;PCODE: $00001114 VOL: 0
;PCODE: $00001115 VOL: 0
;PCODE: $00001116 VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $00001117 VOL: 0
;PCODE: $00001118 VOL: 0
;PCODE: $00001119 VOL: 0
;PCODE: $0000111A VOL: 0
;PCODE: $0000111B VOL: 0
;
;    USART_SendStr(USART_0,"\r Mode ");
;PCODE: $0000111C VOL: 0
;PCODE: $0000111D VOL: 0
;PCODE: $0000111E VOL: 0
;PCODE: $0000111F VOL: 0
;PCODE: $00001120 VOL: 0
;PCODE: $00001121 VOL: 0
;    ltoa(EE_settings.MODE_of_Uart[i],str);
;PCODE: $00001122 VOL: 0
;PCODE: $00001123 VOL: 0
;PCODE: $00001124 VOL: 0
;PCODE: $00001125 VOL: 0
;PCODE: $00001126 VOL: 0
;PCODE: $00001127 VOL: 0
;PCODE: $00001128 VOL: 0
;PCODE: $00001129 VOL: 0
;PCODE: $0000112A VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $0000112B VOL: 0
;PCODE: $0000112C VOL: 0
;PCODE: $0000112D VOL: 0
;PCODE: $0000112E VOL: 0
;PCODE: $0000112F VOL: 0
;
;    USART_SendStr(USART_0,"\r Speed ");
;PCODE: $00001130 VOL: 0
;PCODE: $00001131 VOL: 0
;PCODE: $00001132 VOL: 0
;PCODE: $00001133 VOL: 0
;PCODE: $00001134 VOL: 0
;PCODE: $00001135 VOL: 0
;    ltoa(EE_settings.baud_of_Uart[i],str);
;PCODE: $00001136 VOL: 0
;PCODE: $00001137 VOL: 0
;PCODE: $00001138 VOL: 0
;PCODE: $00001139 VOL: 0
;PCODE: $0000113A VOL: 0
;PCODE: $0000113B VOL: 0
;PCODE: $0000113C VOL: 0
;PCODE: $0000113D VOL: 0
;PCODE: $0000113E VOL: 0
;PCODE: $0000113F VOL: 0
;PCODE: $00001140 VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $00001141 VOL: 0
;PCODE: $00001142 VOL: 0
;PCODE: $00001143 VOL: 0
;PCODE: $00001144 VOL: 0
;PCODE: $00001145 VOL: 0
;
;    USART_SendStr(USART_0,"\r--------\r");
;PCODE: $00001146 VOL: 0
;PCODE: $00001147 VOL: 0
;PCODE: $00001148 VOL: 0
;PCODE: $00001149 VOL: 0
;PCODE: $0000114A VOL: 0
;PCODE: $0000114B VOL: 0
;    }
;PCODE: $0000114C VOL: 0
;PCODE: $0000114D VOL: 0
;PCODE: $0000114E VOL: 0
;PCODE: $0000114F VOL: 0
;PCODE: $00001150 VOL: 0
;
;USART_SendStr(USART_0,"\rSPI_SETTINGS\r");
;PCODE: $00001151 VOL: 0
;PCODE: $00001152 VOL: 0
;PCODE: $00001153 VOL: 0
;PCODE: $00001154 VOL: 0
;PCODE: $00001155 VOL: 0
;PCODE: $00001156 VOL: 0
;  for(i=0;i<COUNT_OF_SPI;i++)
;PCODE: $00001157 VOL: 0
;PCODE: $00001158 VOL: 0
;PCODE: $00001159 VOL: 0
;PCODE: $0000115A VOL: 0
;PCODE: $0000115B VOL: 0
;PCODE: $0000115C VOL: 0
;PCODE: $0000115D VOL: 0
;PCODE: $0000115E VOL: 0
;PCODE: $0000115F VOL: 0
;    {
;    USART_SendStr(USART_0,"SPI ");
;PCODE: $00001160 VOL: 0
;PCODE: $00001161 VOL: 0
;PCODE: $00001162 VOL: 0
;PCODE: $00001163 VOL: 0
;PCODE: $00001164 VOL: 0
;PCODE: $00001165 VOL: 0
;    ltoa(i,str);
;PCODE: $00001166 VOL: 0
;PCODE: $00001167 VOL: 0
;PCODE: $00001168 VOL: 0
;PCODE: $00001169 VOL: 0
;PCODE: $0000116A VOL: 0
;PCODE: $0000116B VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $0000116C VOL: 0
;PCODE: $0000116D VOL: 0
;PCODE: $0000116E VOL: 0
;PCODE: $0000116F VOL: 0
;PCODE: $00001170 VOL: 0
;
;    USART_SendStr(USART_0,"\r Mode ");
;PCODE: $00001171 VOL: 0
;PCODE: $00001172 VOL: 0
;PCODE: $00001173 VOL: 0
;PCODE: $00001174 VOL: 0
;PCODE: $00001175 VOL: 0
;PCODE: $00001176 VOL: 0
;    ltoa(EE_settings.MODE_of_Spi[i],str);
;PCODE: $00001177 VOL: 0
;PCODE: $00001178 VOL: 0
;PCODE: $00001179 VOL: 0
;PCODE: $0000117A VOL: 0
;PCODE: $0000117B VOL: 0
;PCODE: $0000117C VOL: 0
;PCODE: $0000117D VOL: 0
;PCODE: $0000117E VOL: 0
;PCODE: $0000117F VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $00001180 VOL: 0
;PCODE: $00001181 VOL: 0
;PCODE: $00001182 VOL: 0
;PCODE: $00001183 VOL: 0
;PCODE: $00001184 VOL: 0
;
;    USART_SendStr(USART_0,"\r Prescaller ");
;PCODE: $00001185 VOL: 0
;PCODE: $00001186 VOL: 0
;PCODE: $00001187 VOL: 0
;PCODE: $00001188 VOL: 0
;PCODE: $00001189 VOL: 0
;PCODE: $0000118A VOL: 0
;    ltoa(EE_settings.prescaller_of_Spi[i],str);
;PCODE: $0000118B VOL: 0
;PCODE: $0000118C VOL: 0
;PCODE: $0000118D VOL: 0
;PCODE: $0000118E VOL: 0
;PCODE: $0000118F VOL: 0
;PCODE: $00001190 VOL: 0
;PCODE: $00001191 VOL: 0
;PCODE: $00001192 VOL: 0
;PCODE: $00001193 VOL: 0
;    USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $00001194 VOL: 0
;PCODE: $00001195 VOL: 0
;PCODE: $00001196 VOL: 0
;PCODE: $00001197 VOL: 0
;PCODE: $00001198 VOL: 0
;
;    USART_SendStr(USART_0,"\r--------\r");
;PCODE: $00001199 VOL: 0
;PCODE: $0000119A VOL: 0
;PCODE: $0000119B VOL: 0
;PCODE: $0000119C VOL: 0
;PCODE: $0000119D VOL: 0
;PCODE: $0000119E VOL: 0
;    }
;PCODE: $0000119F VOL: 0
;PCODE: $000011A0 VOL: 0
;PCODE: $000011A1 VOL: 0
;PCODE: $000011A2 VOL: 0
;PCODE: $000011A3 VOL: 0
;//USART_FlushTxBuf(USART_0);
;}
;PCODE: $000011A4 VOL: 0
;PCODE: $000011A5 VOL: 0
;PCODE: $000011A6 VOL: 0
;PCODE: $000011A7 VOL: 0
;PCODE: $000011A8 VOL: 0

	.DSEG
_0x1BE:
	.BYTE 0x71
;
;
;void print_sys(void)
;{

	.CSEG
;PCODE: $000011A9 VOL: 0
;PCODE: $000011AA VOL: 0
;char str[5];
;USART_SendStr(USART_0,"\rButes_RX ");
;PCODE: $000011AB VOL: 0
;	str -> Y+0
;PCODE: $000011AC VOL: 0
;PCODE: $000011AD VOL: 0
;PCODE: $000011AE VOL: 0
;PCODE: $000011AF VOL: 0
;PCODE: $000011B0 VOL: 0
;PCODE: $000011B1 VOL: 0
;ltoa(RX_CNT,str);
;PCODE: $000011B2 VOL: 1
;PCODE: $000011B3 VOL: 0
;PCODE: $000011B4 VOL: 0
;PCODE: $000011B5 VOL: 0
;PCODE: $000011B6 VOL: 0
;USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $000011B7 VOL: 0
;PCODE: $000011B8 VOL: 0
;PCODE: $000011B9 VOL: 0
;PCODE: $000011BA VOL: 0
;PCODE: $000011BB VOL: 0
;
;USART_SendStr(USART_0,"\rButes_TX ");
;PCODE: $000011BC VOL: 0
;PCODE: $000011BD VOL: 0
;PCODE: $000011BE VOL: 0
;PCODE: $000011BF VOL: 0
;PCODE: $000011C0 VOL: 0
;PCODE: $000011C1 VOL: 0
;ltoa(TX_CNT,str);
;PCODE: $000011C2 VOL: 1
;PCODE: $000011C3 VOL: 0
;PCODE: $000011C4 VOL: 0
;PCODE: $000011C5 VOL: 0
;PCODE: $000011C6 VOL: 0
;USART_SendStr(USART_0,str); //convert dec to str
;PCODE: $000011C7 VOL: 0
;PCODE: $000011C8 VOL: 0
;PCODE: $000011C9 VOL: 0
;PCODE: $000011CA VOL: 0
;PCODE: $000011CB VOL: 0
;}
;PCODE: $000011CC VOL: 0
;PCODE: $000011CD VOL: 0
;PCODE: $000011CE VOL: 0

	.DSEG
_0x1C5:
	.BYTE 0x16
;
;
;
;#warning TODO
;uint8_t get_curr_cpu_freq (void){ //возвращает значение текущей частоты работы мк

	.CSEG
;PCODE: $000011CF VOL: 0
;PCODE: $000011D0 VOL: 0
;uint8_t freq = 0;
;
;return freq;
;PCODE: $000011D1 VOL: 0
;	freq -> R17
;PCODE: $000011D2 VOL: 0
;PCODE: $000011D3 VOL: 0
;PCODE: $000011D4 VOL: 0
;PCODE: $000011D5 VOL: 0
;PCODE: $000011D6 VOL: 0
;}
;PCODE: $000011D7 VOL: 0
;
;#warning отладить!
;void cust_delay_ms(uint16_t delay){ //умная задержка
;PCODE: $000011D8 VOL: 0
;PCODE: $000011D9 VOL: 0
;uint32_t timecnt = SYS_TICK + delay;
;while (SYS_TICK < timecnt){}
;PCODE: $000011DA VOL: 0
;	delay -> Y+4
;	timecnt -> Y+0
;PCODE: $000011DB VOL: 0
;PCODE: $000011DC VOL: 1
;PCODE: $000011DD VOL: 0
;PCODE: $000011DE VOL: 0
;PCODE: $000011DF VOL: 0
;PCODE: $000011E0 VOL: 0
;PCODE: $000011E1 VOL: 0
;PCODE: $000011E2 VOL: 1
;PCODE: $000011E3 VOL: 0
;PCODE: $000011E4 VOL: 0
;PCODE: $000011E5 VOL: 0
;PCODE: $000011E6 VOL: 0
;}
;PCODE: $000011E7 VOL: 0
;PCODE: $000011E8 VOL: 0
;PCODE: $000011E9 VOL: 0
;
;
;void LogOut(void)				// Выброс логов
;{
;PCODE: $000011EA VOL: 0
;PCODE: $000011EB VOL: 0
;StopRTOS();
;PCODE: $000011EC VOL: 0
;WorkLog[LogIndex]= 0xFF;
;PCODE: $000011ED VOL: 1
;PCODE: $000011EE VOL: 1
;PCODE: $000011EF VOL: 0
;PCODE: $000011F0 VOL: 0
;LogIndex++;
;PCODE: $000011F1 VOL: 1
;PCODE: $000011F2 VOL: 0
;PCODE: $000011F3 VOL: 0
;PCODE: $000011F4 VOL: 0
;USART_SendStr(USART_0, WorkLog);
;PCODE: $000011F5 VOL: 0
;PCODE: $000011F6 VOL: 0
;PCODE: $000011F7 VOL: 1
;PCODE: $000011F8 VOL: 0
;PCODE: $000011F9 VOL: 0
;RunRTOS();
;PCODE: $000011FA VOL: 0
;
;SetTimerTask(Task_Flush_WorkLog,10);//очистка лог буффера
;PCODE: $000011FB VOL: 0
;PCODE: $000011FC VOL: 0
;PCODE: $000011FD VOL: 0
;PCODE: $000011FE VOL: 0
;PCODE: $000011FF VOL: 0
;LogIndex = 0;
;PCODE: $00001200 VOL: 0
;PCODE: $00001201 VOL: 1
;}
;PCODE: $00001202 VOL: 0
;PCODE: $00001203 VOL: 0
;
;/**
;void cust_ltoa(long int n, char *str;)
;{
;unsigned long i;
;unsigned char j,p;
;i=1000000000L;
;p=0;
;if (n<0)
;   {
;   n=-n;
;   *str++='-';
;   };
;do
;  {
;  j=(unsigned char) (n/i);
;  if (j || p || (i==1))
;     {
;     *str++=j+'0';
;     p=1;
;     }
;  n%=i;
;  i/=10L;
;  } while (i!=0);
;   *str = 0;
;}
;*/
;//Определение всех задач для RTOS
;
;#include "task_list.h"
;//============================================================================
;//Область задач
;//============================================================================
;
;void Task_Start (void)
;{
;PCODE: $00001204 VOL: 0
;PCODE: $00001205 VOL: 0
;LED_PORT  |=1<<LED1;
;PCODE: $00001206 VOL: 0
;PCODE: $00001207 VOL: 0
;SetTimerTask(Task_LedOff,50); //запуск мигалки-антизависалки
;PCODE: $00001208 VOL: 0
;PCODE: $00001209 VOL: 0
;PCODE: $0000120A VOL: 0
;PCODE: $0000120B VOL: 0
;PCODE: $0000120C VOL: 0
;}
;PCODE: $0000120D VOL: 0
;PCODE: $0000120E VOL: 0
;
;void Task_LedOff (void)
;{
;PCODE: $0000120F VOL: 0
;PCODE: $00001210 VOL: 0
;SetTimerTask(Task_LedOn,500);
;PCODE: $00001211 VOL: 0
;PCODE: $00001212 VOL: 0
;PCODE: $00001213 VOL: 0
;PCODE: $00001214 VOL: 0
;PCODE: $00001215 VOL: 0
;LED_PORT  &= ~(1<<LED1);
;PCODE: $00001216 VOL: 0
;PCODE: $00001217 VOL: 0
;}
;PCODE: $00001218 VOL: 0
;PCODE: $00001219 VOL: 0
;
;void Task_LedOn (void)
;{
;PCODE: $0000121A VOL: 0
;PCODE: $0000121B VOL: 0
;SetTimerTask(Task_LedOff,50);
;PCODE: $0000121C VOL: 0
;PCODE: $0000121D VOL: 0
;PCODE: $0000121E VOL: 0
;PCODE: $0000121F VOL: 0
;PCODE: $00001220 VOL: 0
;LED_PORT  |= (1<<LED1);
;PCODE: $00001221 VOL: 0
;PCODE: $00001222 VOL: 0
;}
;PCODE: $00001223 VOL: 0
;PCODE: $00001224 VOL: 0
;
;void Task_ADC_test (void) //Upd-6     //для проверки освещённоси помещения
; {
;PCODE: $00001225 VOL: 0
;PCODE: $00001226 VOL: 0
;
; SetTimerTask(Task_ADC_test,5000);
;PCODE: $00001227 VOL: 0
;PCODE: $00001228 VOL: 0
;PCODE: $00001229 VOL: 0
;PCODE: $0000122A VOL: 0
;PCODE: $0000122B VOL: 0
; }
;PCODE: $0000122C VOL: 0
;PCODE: $0000122D VOL: 0
;void Task_LcdGreetImage (void) //Greeting image on start    //Upd-4
;{
;PCODE: $0000122E VOL: 0
;PCODE: $0000122F VOL: 0
;SetTask(LcdClear);
;PCODE: $00001230 VOL: 0
;PCODE: $00001231 VOL: 0
;PCODE: $00001232 VOL: 0
; LcdImage(rad1Image);
;PCODE: $00001233 VOL: 0
;PCODE: $00001234 VOL: 0
;PCODE: $00001235 VOL: 0
;SetTask(LcdUpdate);
;PCODE: $00001236 VOL: 0
;PCODE: $00001237 VOL: 0
;PCODE: $00001238 VOL: 0
;SetTimerTask(LcdClear,2000);
;PCODE: $00001239 VOL: 0
;PCODE: $0000123A VOL: 0
;PCODE: $0000123B VOL: 0
;PCODE: $0000123C VOL: 0
;PCODE: $0000123D VOL: 0
;SetTimerTask(Task_LcdLines,3000);
;PCODE: $0000123E VOL: 0
;PCODE: $0000123F VOL: 0
;PCODE: $00001240 VOL: 0
;PCODE: $00001241 VOL: 0
;PCODE: $00001242 VOL: 0
;}
;PCODE: $00001243 VOL: 0
;PCODE: $00001244 VOL: 0
;
;void Task_LcdLines (void)      //Upd-4       //сильно грузит!
;{
;PCODE: $00001245 VOL: 0
;PCODE: $00001246 VOL: 0
;    	for (i=0; i<84; i++){
;PCODE: $00001247 VOL: 0
;PCODE: $00001248 VOL: 0
;PCODE: $00001249 VOL: 0
;PCODE: $0000124A VOL: 0
;PCODE: $0000124B VOL: 0
;PCODE: $0000124C VOL: 0
;PCODE: $0000124D VOL: 0
;		LcdLine ( 0, 47, i, 0, 1);
;PCODE: $0000124E VOL: 0
;PCODE: $0000124F VOL: 0
;PCODE: $00001250 VOL: 0
;PCODE: $00001251 VOL: 0
;PCODE: $00001252 VOL: 0
;PCODE: $00001253 VOL: 0
;PCODE: $00001254 VOL: 0
;PCODE: $00001255 VOL: 0
;PCODE: $00001256 VOL: 0
;PCODE: $00001257 VOL: 0
;PCODE: $00001258 VOL: 0
;PCODE: $00001259 VOL: 0
;        LcdLine ( 84, 47, 84-i, 0, 1);
;PCODE: $0000125A VOL: 0
;PCODE: $0000125B VOL: 0
;PCODE: $0000125C VOL: 0
;PCODE: $0000125D VOL: 0
;PCODE: $0000125E VOL: 0
;PCODE: $0000125F VOL: 0
;PCODE: $00001260 VOL: 0
;PCODE: $00001261 VOL: 0
;PCODE: $00001262 VOL: 0
;PCODE: $00001263 VOL: 0
;PCODE: $00001264 VOL: 0
;PCODE: $00001265 VOL: 0
;PCODE: $00001266 VOL: 0
;		LcdUpdate();
;PCODE: $00001267 VOL: 0
;		}
;PCODE: $00001268 VOL: 0
;PCODE: $00001269 VOL: 0
;PCODE: $0000126A VOL: 0
;PCODE: $0000126B VOL: 0
;SetTimerTask(LcdClear,2000);
;PCODE: $0000126C VOL: 0
;PCODE: $0000126D VOL: 0
;PCODE: $0000126E VOL: 0
;PCODE: $0000126F VOL: 0
;PCODE: $00001270 VOL: 0
;}
;PCODE: $00001271 VOL: 0
;PCODE: $00001272 VOL: 0
;
;void Task_AdcOnLcd (void)
;{
;PCODE: $00001273 VOL: 0
;PCODE: $00001274 VOL: 0
; sprintf (lcd_buf, "vref=%d ",vref);      // вывод на экран результата
;PCODE: $00001275 VOL: 0
;PCODE: $00001276 VOL: 0
;PCODE: $00001277 VOL: 0
;PCODE: $00001278 VOL: 0
;PCODE: $00001279 VOL: 0
;PCODE: $0000127A VOL: 0
;PCODE: $0000127B VOL: 0
;PCODE: $0000127C VOL: 0
;PCODE: $0000127D VOL: 0
;PCODE: $0000127E VOL: 0
;PCODE: $0000127F VOL: 0
;PCODE: $00001280 VOL: 0
; LcdString(1,1);
;PCODE: $00001281 VOL: 0
;PCODE: $00001282 VOL: 0
;PCODE: $00001283 VOL: 0
;PCODE: $00001284 VOL: 0
;PCODE: $00001285 VOL: 0
;  sprintf (lcd_buf, "d=%d ",d);      // вывод на экран результата
;PCODE: $00001286 VOL: 0
;PCODE: $00001287 VOL: 0
;PCODE: $00001288 VOL: 0
;PCODE: $00001289 VOL: 0
;PCODE: $0000128A VOL: 0
;PCODE: $0000128B VOL: 0
;PCODE: $0000128C VOL: 0
;PCODE: $0000128D VOL: 0
;PCODE: $0000128E VOL: 0
;PCODE: $0000128F VOL: 0
;PCODE: $00001290 VOL: 0
;PCODE: $00001291 VOL: 0
; LcdString(1,2);
;PCODE: $00001292 VOL: 0
;PCODE: $00001293 VOL: 0
;PCODE: $00001294 VOL: 0
;PCODE: $00001295 VOL: 0
;PCODE: $00001296 VOL: 0
;  sprintf (lcd_buf, "delta=%d ",delta);      // вывод на экран результата
;PCODE: $00001297 VOL: 0
;PCODE: $00001298 VOL: 0
;PCODE: $00001299 VOL: 0
;PCODE: $0000129A VOL: 0
;PCODE: $0000129B VOL: 0
;PCODE: $0000129C VOL: 0
;PCODE: $0000129D VOL: 0
;PCODE: $0000129E VOL: 0
;PCODE: $0000129F VOL: 0
;PCODE: $000012A0 VOL: 0
;PCODE: $000012A1 VOL: 0
;PCODE: $000012A2 VOL: 0
; LcdString(1,3);
;PCODE: $000012A3 VOL: 0
;PCODE: $000012A4 VOL: 0
;PCODE: $000012A5 VOL: 0
;PCODE: $000012A6 VOL: 0
;PCODE: $000012A7 VOL: 0
;  sprintf (lcd_buf, "volt=%d ",volt);      // вывод на экран результата
;PCODE: $000012A8 VOL: 0
;PCODE: $000012A9 VOL: 0
;PCODE: $000012AA VOL: 0
;PCODE: $000012AB VOL: 0
;PCODE: $000012AC VOL: 0
;PCODE: $000012AD VOL: 0
;PCODE: $000012AE VOL: 0
;PCODE: $000012AF VOL: 0
;PCODE: $000012B0 VOL: 0
;PCODE: $000012B1 VOL: 0
;PCODE: $000012B2 VOL: 0
;PCODE: $000012B3 VOL: 0
; LcdString(1,4);
;PCODE: $000012B4 VOL: 0
;PCODE: $000012B5 VOL: 0
;PCODE: $000012B6 VOL: 0
;PCODE: $000012B7 VOL: 0
;PCODE: $000012B8 VOL: 0
; LcdUpdate();
;PCODE: $000012B9 VOL: 0
;}
;PCODE: $000012BA VOL: 0
;PCODE: $000012BB VOL: 0
;
;void Task_pars_cmd (void)
;{
;PCODE: $000012BC VOL: 0
;PCODE: $000012BD VOL: 0
;  if (USART_Get_rxCount(SYSTEM_USART) > 0) //если в приёмном буфере что-то есть
;PCODE: $000012BE VOL: 0
;PCODE: $000012BF VOL: 0
;PCODE: $000012C0 VOL: 0
;PCODE: $000012C1 VOL: 0
;PCODE: $000012C2 VOL: 0
;       {
;        symbol = USART_GetChar(SYSTEM_USART);
;PCODE: $000012C3 VOL: 0
;PCODE: $000012C4 VOL: 0
;PCODE: $000012C5 VOL: 0
;PCODE: $000012C6 VOL: 1
;        PARS_Parser(symbol);
;PCODE: $000012C7 VOL: 1
;PCODE: $000012C8 VOL: 0
;PCODE: $000012C9 VOL: 0
;       }
;SetTimerTask(Task_pars_cmd, 25);
;PCODE: $000012CA VOL: 0
;PCODE: $000012CB VOL: 0
;PCODE: $000012CC VOL: 0
;PCODE: $000012CD VOL: 0
;PCODE: $000012CE VOL: 0
;PCODE: $000012CF VOL: 0
;}
;PCODE: $000012D0 VOL: 0
;PCODE: $000012D1 VOL: 0
;
;
;void Task_LogOut (void)
;{
;PCODE: $000012D2 VOL: 0
;PCODE: $000012D3 VOL: 0
;SetTimerTask(Task_LogOut,50);
;PCODE: $000012D4 VOL: 0
;PCODE: $000012D5 VOL: 0
;PCODE: $000012D6 VOL: 0
;PCODE: $000012D7 VOL: 0
;PCODE: $000012D8 VOL: 0
;if(LogIndex){LogOut();} //если что-то есть в лог буфере - вывести
;PCODE: $000012D9 VOL: 1
;PCODE: $000012DA VOL: 0
;PCODE: $000012DB VOL: 0
;PCODE: $000012DC VOL: 0
;}
;PCODE: $000012DD VOL: 0
;PCODE: $000012DE VOL: 0
;PCODE: $000012DF VOL: 0
;
;
;void Task_Flush_WorkLog(void){ //очистка лог буффера
;PCODE: $000012E0 VOL: 0
;PCODE: $000012E1 VOL: 0
;uint16_t i = 0;
;while(i<512){WorkLog[i] = 0; i++;}
;PCODE: $000012E2 VOL: 0
;PCODE: $000012E3 VOL: 0
;	i -> R16,R17
;PCODE: $000012E4 VOL: 0
;PCODE: $000012E5 VOL: 0
;PCODE: $000012E6 VOL: 0
;PCODE: $000012E7 VOL: 0
;PCODE: $000012E8 VOL: 0
;PCODE: $000012E9 VOL: 0
;PCODE: $000012EA VOL: 1
;PCODE: $000012EB VOL: 0
;PCODE: $000012EC VOL: 0
;PCODE: $000012ED VOL: 0
;PCODE: $000012EE VOL: 0
;PCODE: $000012EF VOL: 0
;PCODE: $000012F0 VOL: 0
;PCODE: $000012F1 VOL: 0
;PORTD.7^=1;
;PCODE: $000012F2 VOL: 0
;PCODE: $000012F3 VOL: 0
;PCODE: $000012F4 VOL: 0
;PCODE: $000012F5 VOL: 0
;PCODE: $000012F6 VOL: 0
;PCODE: $000012F7 VOL: 0
;PCODE: $000012F8 VOL: 0
;PCODE: $000012F9 VOL: 0
;PCODE: $000012FA VOL: 0
;PCODE: $000012FB VOL: 0
;PCODE: $000012FC VOL: 0
;PCODE: $000012FD VOL: 0
;}
;PCODE: $000012FE VOL: 0
;PCODE: $000012FF VOL: 0
;PCODE: $00001300 VOL: 0
;
;/*
;void Task_Uart_ByfSend(void){ //очистка лог буффера
;
;}*/
;
;void Task_SPI_ClrBuf (void){ //очистка rx/tx буфферов SPI
;PCODE: $00001301 VOL: 0
;PCODE: $00001302 VOL: 0
;uint8_t i;
;for(i=0;i<64;i++)
;PCODE: $00001303 VOL: 0
;	i -> R17
;PCODE: $00001304 VOL: 0
;PCODE: $00001305 VOL: 0
;PCODE: $00001306 VOL: 0
;PCODE: $00001307 VOL: 0
;PCODE: $00001308 VOL: 0
;PCODE: $00001309 VOL: 0
;PCODE: $0000130A VOL: 0
;PCODE: $0000130B VOL: 0
;PCODE: $0000130C VOL: 0
; {
;Spi0_RX_buf[i] = 0;
;PCODE: $0000130D VOL: 0
;PCODE: $0000130E VOL: 0
;PCODE: $0000130F VOL: 1
;PCODE: $00001310 VOL: 0
;PCODE: $00001311 VOL: 0
;Spi0_TX_buf[i] = 0;
;PCODE: $00001312 VOL: 0
;PCODE: $00001313 VOL: 0
;PCODE: $00001314 VOL: 1
;PCODE: $00001315 VOL: 0
;PCODE: $00001316 VOL: 0
;  //if(i<=SIZE_SPI_BUF_TX){Spi0_TX_buf[i] = 0;}
; }
;PCODE: $00001317 VOL: 0
;PCODE: $00001318 VOL: 0
;PCODE: $00001319 VOL: 0
;PCODE: $0000131A VOL: 0
;PCODE: $0000131B VOL: 0
;}
;PCODE: $0000131C VOL: 0
;PCODE: $0000131D VOL: 0
;PCODE: $0000131E VOL: 0
;
;//=================================================
;//////////////////////////I2C//////////////////////
;
;//============================================================================
;//Область задач
;//============================================================================
;
;// Записываем в ЕЕПРОМ байт.
;void StartWrite2EPP(void)
;{
;PCODE: $0000131F VOL: 0
;PCODE: $00001320 VOL: 0
;if (!i2c_eep_WriteByte(0xA0,0x00FF,/*(char)Usart0_RX_buf[15]*/ 9,&Writed2EEP))    // Если байт незаписался
;PCODE: $00001321 VOL: 0
;PCODE: $00001322 VOL: 0
;PCODE: $00001323 VOL: 0
;PCODE: $00001324 VOL: 0
;PCODE: $00001325 VOL: 0
;PCODE: $00001326 VOL: 0
;PCODE: $00001327 VOL: 0
;PCODE: $00001328 VOL: 0
;PCODE: $00001329 VOL: 0
;PCODE: $0000132A VOL: 0
;PCODE: $0000132B VOL: 0
;    {
;    SetTimerTask(StartWrite2EPP,50);                        // Повторить попытку через 50мс
;PCODE: $0000132C VOL: 0
;PCODE: $0000132D VOL: 0
;PCODE: $0000132E VOL: 0
;PCODE: $0000132F VOL: 0
;PCODE: $00001330 VOL: 0
;    }
;}
;PCODE: $00001331 VOL: 0
;PCODE: $00001332 VOL: 0
;PCODE: $00001333 VOL: 0
;
;// Точка выхода из автомата по записи в ЕЕПРОМ
;void Writed2EEP(void)
;{
;PCODE: $00001334 VOL: 0
;PCODE: $00001335 VOL: 0
;i2c_Do &= i2c_Free;                                            // Освобождаем шину
;PCODE: $00001336 VOL: 0
;PCODE: $00001337 VOL: 0
;PCODE: $00001338 VOL: 0
;
;if(i2c_Do & (i2c_ERR_NA|i2c_ERR_BF))                        // Если запись не удалась
;PCODE: $00001339 VOL: 0
;PCODE: $0000133A VOL: 0
;PCODE: $0000133B VOL: 0
;    {
;    SetTimerTask(StartWrite2EPP,20);                        // повторяем попытку
;PCODE: $0000133C VOL: 0
;PCODE: $0000133D VOL: 0
;PCODE: $0000133E VOL: 0
;PCODE: $0000133F VOL: 0
;PCODE: $00001340 VOL: 0
;    }
;else
;PCODE: $00001341 VOL: 0
;PCODE: $00001342 VOL: 0
;    {
;    SetTask(SendAddrToSlave);        						// Если все ок, то идем на следующий
;PCODE: $00001343 VOL: 0
;PCODE: $00001344 VOL: 0
;PCODE: $00001345 VOL: 0
;	}														// Пункт задания - передача данных слейву 2
;PCODE: $00001346 VOL: 0
;}
;PCODE: $00001347 VOL: 0
;PCODE: $00001348 VOL: 0
;
;// Обращение к SLAVE контроллеру
;void SendAddrToSlave(void)
;{
;PCODE: $00001349 VOL: 0
;PCODE: $0000134A VOL: 0
;if (i2c_Do & i2c_Busy)						// Если передатчик занят
;PCODE: $0000134B VOL: 0
;PCODE: $0000134C VOL: 0
;PCODE: $0000134D VOL: 0
;		{
;		SetTimerTask(SendAddrToSlave,100);	// То повторить через 100мс
;PCODE: $0000134E VOL: 0
;PCODE: $0000134F VOL: 0
;PCODE: $00001350 VOL: 0
;PCODE: $00001351 VOL: 0
;PCODE: $00001352 VOL: 0
;		}
;
;i2c_index = 0;								// Сброс индекса
;PCODE: $00001353 VOL: 0
;PCODE: $00001354 VOL: 0
;PCODE: $00001355 VOL: 0
;i2c_ByteCount = 2;							// Шлем два байта
;PCODE: $00001356 VOL: 0
;PCODE: $00001357 VOL: 0
;
;i2c_SlaveAddress = 0xB0;					// Адрес контроллера 0xB0
;PCODE: $00001358 VOL: 0
;PCODE: $00001359 VOL: 0
;
;i2c_Buffer[0] = 0x00;						// Те самые два байта, что мы шлем подчиненному
;PCODE: $0000135A VOL: 0
;PCODE: $0000135B VOL: 0
;i2c_Buffer[1] = 0xFF;
;PCODE: $0000135C VOL: 0
;PCODE: $0000135D VOL: 0
;PCODE: $0000135E VOL: 0
;
;i2c_Do = i2c_sawp;							// Режим = простая запись, адрес+два байта данных
;PCODE: $0000135F VOL: 0
;PCODE: $00001360 VOL: 0
;
;MasterOutFunc = &SendedAddrToSlave;			// Точка выхода из автомата если все хорошо
;PCODE: $00001361 VOL: 0
;PCODE: $00001362 VOL: 0
;ErrorOutFunc = &SendedAddrToSlave;			// И если все плохо.
;PCODE: $00001363 VOL: 0
;PCODE: $00001364 VOL: 0
;
;TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;		// Поехали!
;PCODE: $00001365 VOL: 0
;PCODE: $00001366 VOL: 0
;i2c_Do |= i2c_Busy;												// Шина занята!
;PCODE: $00001367 VOL: 0
;PCODE: $00001368 VOL: 0
;PCODE: $00001369 VOL: 0
;}
;PCODE: $0000136A VOL: 0
;PCODE: $0000136B VOL: 0
;
;
;// Выход из автомата IIC
;void SendedAddrToSlave(void)
;{
;PCODE: $0000136C VOL: 0
;PCODE: $0000136D VOL: 0
;i2c_Do &= i2c_Free;							// Освобождаем шину
;PCODE: $0000136E VOL: 0
;PCODE: $0000136F VOL: 0
;PCODE: $00001370 VOL: 0
;
;if(i2c_Do & (i2c_ERR_NA|i2c_ERR_BF))		// Если адресат нас не услышал или был сбой на линии
;PCODE: $00001371 VOL: 0
;PCODE: $00001372 VOL: 0
;PCODE: $00001373 VOL: 0
;	{
;	SetTimerTask(SendAddrToSlave,20);		// Повторить попытку
;PCODE: $00001374 VOL: 0
;PCODE: $00001375 VOL: 0
;PCODE: $00001376 VOL: 0
;PCODE: $00001377 VOL: 0
;PCODE: $00001378 VOL: 0
;	}
;}
;PCODE: $00001379 VOL: 0
;PCODE: $0000137A VOL: 0
;PCODE: $0000137B VOL: 0
;
;
;// Если словили свой адрес и приняли данные
;void SlaveControl(void)
;{
;PCODE: $0000137C VOL: 0
;PCODE: $0000137D VOL: 0
;i2c_Do &= i2c_Free;				// Освобождаем шину
;PCODE: $0000137E VOL: 0
;PCODE: $0000137F VOL: 0
;PCODE: $00001380 VOL: 0
;UDR0 = i2c_InBuff[0];			// Выгружаем принятый байт
;PCODE: $00001381 VOL: 0
;PCODE: $00001382 VOL: 0
;}
;PCODE: $00001383 VOL: 0
;PCODE: $00001384 VOL: 0
;
;//==============================================================================
;#include "init.c"
;#include <adapter.h>
;
;inline void GPIO_init(void){
; 0000 0010 inline void GPIO_init(void){
;PCODE: $00001385 VOL: 0
;PCODE: $00001386 VOL: 0
;PORTA=0x00; DDRA=0x00;
;PCODE: $00001387 VOL: 0
;PCODE: $00001388 VOL: 0
;PCODE: $00001389 VOL: 0
;PCODE: $0000138A VOL: 0
;PORTB=0x00; DDRB=0x07;
;PCODE: $0000138B VOL: 0
;PCODE: $0000138C VOL: 0
;PCODE: $0000138D VOL: 0
;PCODE: $0000138E VOL: 0
;PORTC=0x00; DDRC=0x00;
;PCODE: $0000138F VOL: 0
;PCODE: $00001390 VOL: 0
;PCODE: $00001391 VOL: 0
;PCODE: $00001392 VOL: 0
;PORTD=0x00; DDRD=0x00;
;PCODE: $00001393 VOL: 0
;PCODE: $00001394 VOL: 0
;PCODE: $00001395 VOL: 0
;PCODE: $00001396 VOL: 0
;PORTE=0x00; DDRE=0x00;
;PCODE: $00001397 VOL: 0
;PCODE: $00001398 VOL: 0
;PCODE: $00001399 VOL: 0
;PCODE: $0000139A VOL: 0
;PORTF=0x00; DDRF=0x00;
;PCODE: $0000139B VOL: 0
;PCODE: $0000139C VOL: 0
;PCODE: $0000139D VOL: 0
;PCODE: $0000139E VOL: 0
;PORTG=0x00; DDRG=0x00;
;PCODE: $0000139F VOL: 0
;PCODE: $000013A0 VOL: 0
;PCODE: $000013A1 VOL: 0
;PCODE: $000013A2 VOL: 0
;}
;PCODE: $000013A3 VOL: 0
;PCODE: $000013A4 VOL: 0
;
;
;inline void TIM_0_init(void){// Timer/Counter 0 initialization
;PCODE: $000013A5 VOL: 0
;PCODE: $000013A6 VOL: 0
;// Clock source: System Clock
;// Clock value: Timer 0 Stopped
;// Mode: Normal top=0xFF
;// OC0 output: Disconnected
;ASSR=0x00;
;PCODE: $000013A7 VOL: 0
;PCODE: $000013A8 VOL: 0
;TCCR0=0x00;
;PCODE: $000013A9 VOL: 0
;PCODE: $000013AA VOL: 0
;TCNT0=0x00;
;PCODE: $000013AB VOL: 0
;PCODE: $000013AC VOL: 0
;OCR0=0x00;
;PCODE: $000013AD VOL: 0
;PCODE: $000013AE VOL: 0
;}
;PCODE: $000013AF VOL: 0
;PCODE: $000013B0 VOL: 0
;
;inline void TIM_1_init(void){// Timer/Counter 1 initialization
;PCODE: $000013B1 VOL: 0
;PCODE: $000013B2 VOL: 0
;TCCR1A=0x00;    TCCR1B=0x00;
;PCODE: $000013B3 VOL: 0
;PCODE: $000013B4 VOL: 0
;PCODE: $000013B5 VOL: 0
;PCODE: $000013B6 VOL: 0
;TCNT1H=0x00;    TCNT1L=0x00;
;PCODE: $000013B7 VOL: 0
;PCODE: $000013B8 VOL: 0
;PCODE: $000013B9 VOL: 0
;PCODE: $000013BA VOL: 0
;ICR1H=0x00;     ICR1L=0x00;
;PCODE: $000013BB VOL: 0
;PCODE: $000013BC VOL: 0
;PCODE: $000013BD VOL: 0
;PCODE: $000013BE VOL: 0
;OCR1AH=0x00;    OCR1AL=0x00;
;PCODE: $000013BF VOL: 0
;PCODE: $000013C0 VOL: 0
;PCODE: $000013C1 VOL: 0
;PCODE: $000013C2 VOL: 0
;OCR1BH=0x00;    OCR1BL=0x00;
;PCODE: $000013C3 VOL: 0
;PCODE: $000013C4 VOL: 0
;PCODE: $000013C5 VOL: 0
;PCODE: $000013C6 VOL: 0
;OCR1CH=0x00;    OCR1CL=0x00;
;PCODE: $000013C7 VOL: 0
;PCODE: $000013C8 VOL: 0
;PCODE: $000013C9 VOL: 0
;PCODE: $000013CA VOL: 0
;}
;PCODE: $000013CB VOL: 0
;PCODE: $000013CC VOL: 0
;
;inline void TIM_2_init(void){// Timer/Counter 2 initialization
;PCODE: $000013CD VOL: 0
;PCODE: $000013CE VOL: 0
;TCCR2=0x00;
;PCODE: $000013CF VOL: 0
;PCODE: $000013D0 VOL: 0
;TCNT2=0x00;
;PCODE: $000013D1 VOL: 0
;PCODE: $000013D2 VOL: 0
;OCR2=0x00;
;PCODE: $000013D3 VOL: 0
;PCODE: $000013D4 VOL: 0
;}
;PCODE: $000013D5 VOL: 0
;PCODE: $000013D6 VOL: 0
;
;inline void TIM_3_init(void){ // Timer/Counter 3 initialization
;PCODE: $000013D7 VOL: 0
;PCODE: $000013D8 VOL: 0
;TCCR3A=0x00;    TCCR3B=0x00;
;PCODE: $000013D9 VOL: 0
;PCODE: $000013DA VOL: 0
;PCODE: $000013DB VOL: 0
;PCODE: $000013DC VOL: 0
;TCNT3H=0x00;    TCNT3L=0x00;
;PCODE: $000013DD VOL: 0
;PCODE: $000013DE VOL: 0
;PCODE: $000013DF VOL: 0
;PCODE: $000013E0 VOL: 0
;ICR3H=0x00;     ICR3L=0x00;
;PCODE: $000013E1 VOL: 0
;PCODE: $000013E2 VOL: 0
;PCODE: $000013E3 VOL: 0
;PCODE: $000013E4 VOL: 0
;OCR3AH=0x00;    OCR3AL=0x00;
;PCODE: $000013E5 VOL: 0
;PCODE: $000013E6 VOL: 0
;PCODE: $000013E7 VOL: 0
;PCODE: $000013E8 VOL: 0
;OCR3BH=0x00;    OCR3BL=0x00;
;PCODE: $000013E9 VOL: 0
;PCODE: $000013EA VOL: 0
;PCODE: $000013EB VOL: 0
;PCODE: $000013EC VOL: 0
;OCR3CH=0x00;    OCR3CL=0x00;
;PCODE: $000013ED VOL: 0
;PCODE: $000013EE VOL: 0
;PCODE: $000013EF VOL: 0
;PCODE: $000013F0 VOL: 0
;}
;PCODE: $000013F1 VOL: 0
;PCODE: $000013F2 VOL: 0
;
;inline void INT_init(void){// External Interrupt(s) initialization
;PCODE: $000013F3 VOL: 0
;PCODE: $000013F4 VOL: 0
;// INTx: Off
;EICRA=0x00;
;PCODE: $000013F5 VOL: 0
;PCODE: $000013F6 VOL: 0
;EICRB=0x00;
;PCODE: $000013F7 VOL: 0
;PCODE: $000013F8 VOL: 0
;EIMSK=0x00;
;PCODE: $000013F9 VOL: 0
;PCODE: $000013FA VOL: 0
;
;// Timer(s)/Counter(s) Interrupt(s) initialization
;TIMSK=0x00;
;PCODE: $000013FB VOL: 0
;PCODE: $000013FC VOL: 0
;ETIMSK=0x00;
;PCODE: $000013FD VOL: 0
;PCODE: $000013FE VOL: 0
;}
;PCODE: $000013FF VOL: 0
;PCODE: $00001400 VOL: 0
;
;
;inline void USART_0_init(void){// USART0 initialization
;PCODE: $00001401 VOL: 0
;PCODE: $00001402 VOL: 0
;// Communication Parameters: 8 Data, 1 Stop, No Parity
;// USART0 Receiver: On
;// USART0 Transmitter: On
;// USART0 Mode: Asynchronous
;// USART0 Baud Rate: 9600
;UCSR0A=0x00;
;PCODE: $00001403 VOL: 0
;PCODE: $00001404 VOL: 0
;UCSR0B=0xD8;
;PCODE: $00001405 VOL: 0
;PCODE: $00001406 VOL: 0
;UCSR0C=0x06;
;PCODE: $00001407 VOL: 0
;PCODE: $00001408 VOL: 0
;UBRR0H=0x00;
;PCODE: $00001409 VOL: 0
;PCODE: $0000140A VOL: 0
;UBRR0L=0x33;
;PCODE: $0000140B VOL: 0
;PCODE: $0000140C VOL: 0
;}
;PCODE: $0000140D VOL: 0
;PCODE: $0000140E VOL: 0
;
;inline void USART_1_init(void){// USART1 initialization
;PCODE: $0000140F VOL: 0
;PCODE: $00001410 VOL: 0
;// Communication Parameters: 8 Data, 1 Stop, No Parity
;// USART1 Receiver: On
;// USART1 Transmitter: On
;// USART1 Mode: Asynchronous
;// USART1 Baud Rate: 115200 (Double Speed Mode)
;UCSR1A=0x02;
;PCODE: $00001411 VOL: 0
;PCODE: $00001412 VOL: 0
;UCSR1B=0xD8;
;PCODE: $00001413 VOL: 0
;PCODE: $00001414 VOL: 0
;UCSR1C=0x06;
;PCODE: $00001415 VOL: 0
;PCODE: $00001416 VOL: 0
;UBRR1H=0x00;
;PCODE: $00001417 VOL: 0
;PCODE: $00001418 VOL: 0
;UBRR1L=0x08;
;PCODE: $00001419 VOL: 0
;PCODE: $0000141A VOL: 0
;}
;PCODE: $0000141B VOL: 0
;PCODE: $0000141C VOL: 0
;
;/*
;void SPI_init(void){// SPI initialization
;// SPI Type: Master
;// SPI Clock Rate: 2000,000 kHz
;// SPI Clock Phase: Cycle Start
;// SPI Clock Polarity: Low
;// SPI Data Order: MSB First
;SPCR=0xD0;
;SPSR=0x00;
;// Clear the SPI interrupt flag
;#asm
;    in   r30,spsr
;    in   r30,spdr
;#endasm
;}*/
;
;inline void TWI_init(void){// TWI initialization
;PCODE: $0000141D VOL: 0
;PCODE: $0000141E VOL: 0
;// Bit Rate: 400,000 kHz
;TWBR=0x02;
;PCODE: $0000141F VOL: 0
;PCODE: $00001420 VOL: 0
;// Two Wire Bus Slave Address: 0x0
;// General Call Recognition: Off
;TWAR=0x00;
;PCODE: $00001421 VOL: 0
;PCODE: $00001422 VOL: 0
;// Generate Acknowledge Pulse: Off
;// TWI Interrupt: On
;TWCR=0x05;
;PCODE: $00001423 VOL: 0
;PCODE: $00001424 VOL: 0
;TWSR=0x00;
;PCODE: $00001425 VOL: 0
;PCODE: $00001426 VOL: 0
;}
;PCODE: $00001427 VOL: 0
;PCODE: $00001428 VOL: 0
;
;void settings_EE_cpy_R(void){ // settings transfer from eeprom to ram
;PCODE: $00001429 VOL: 0
;PCODE: $0000142A VOL: 0
;uint8_t i = 0;
;  for(i=0;i<COUNT_OF_UARTS;i++)
;PCODE: $0000142B VOL: 0
;	i -> R17
;PCODE: $0000142C VOL: 0
;PCODE: $0000142D VOL: 0
;PCODE: $0000142E VOL: 0
;PCODE: $0000142F VOL: 0
;PCODE: $00001430 VOL: 0
;PCODE: $00001431 VOL: 0
;PCODE: $00001432 VOL: 0
;PCODE: $00001433 VOL: 0
;PCODE: $00001434 VOL: 0
;PCODE: $00001435 VOL: 0
;PCODE: $00001436 VOL: 0
;    {
;        RAM_settings.MODE_of_Uart[i] = EE_settings.MODE_of_Uart[i];
;PCODE: $00001437 VOL: 0
;PCODE: $00001438 VOL: 0
;PCODE: $00001439 VOL: 0
;PCODE: $0000143A VOL: 0
;PCODE: $0000143B VOL: 0
;PCODE: $0000143C VOL: 0
;PCODE: $0000143D VOL: 0
;PCODE: $0000143E VOL: 0
;PCODE: $0000143F VOL: 0
;PCODE: $00001440 VOL: 0
;PCODE: $00001441 VOL: 0
;PCODE: $00001442 VOL: 0
;        RAM_settings.baud_of_Uart[i] = EE_settings.baud_of_Uart[i];
;PCODE: $00001443 VOL: 0
;PCODE: $00001444 VOL: 0
;PCODE: $00001445 VOL: 0
;PCODE: $00001446 VOL: 0
;PCODE: $00001447 VOL: 0
;PCODE: $00001448 VOL: 0
;PCODE: $00001449 VOL: 0
;PCODE: $0000144A VOL: 0
;PCODE: $0000144B VOL: 0
;PCODE: $0000144C VOL: 0
;PCODE: $0000144D VOL: 0
;PCODE: $0000144E VOL: 0
;PCODE: $0000144F VOL: 0
;PCODE: $00001450 VOL: 0
;    }
;PCODE: $00001451 VOL: 0
;PCODE: $00001452 VOL: 0
;PCODE: $00001453 VOL: 0
;PCODE: $00001454 VOL: 0
;PCODE: $00001455 VOL: 0
;  for(i=0;i<COUNT_OF_SPI;i++)
;PCODE: $00001456 VOL: 0
;PCODE: $00001457 VOL: 0
;PCODE: $00001458 VOL: 0
;PCODE: $00001459 VOL: 0
;PCODE: $0000145A VOL: 0
;PCODE: $0000145B VOL: 0
;PCODE: $0000145C VOL: 0
;PCODE: $0000145D VOL: 0
;PCODE: $0000145E VOL: 0
;    {
;        RAM_settings.MODE_of_Spi[i] = EE_settings.MODE_of_Spi[i];
;PCODE: $0000145F VOL: 0
;PCODE: $00001460 VOL: 0
;PCODE: $00001461 VOL: 0
;PCODE: $00001462 VOL: 0
;PCODE: $00001463 VOL: 0
;PCODE: $00001464 VOL: 0
;PCODE: $00001465 VOL: 0
;PCODE: $00001466 VOL: 0
;PCODE: $00001467 VOL: 0
;PCODE: $00001468 VOL: 0
;PCODE: $00001469 VOL: 0
;PCODE: $0000146A VOL: 0
;        RAM_settings.prescaller_of_Spi[i] =  EE_settings.prescaller_of_Spi[i];
;PCODE: $0000146B VOL: 0
;PCODE: $0000146C VOL: 0
;PCODE: $0000146D VOL: 0
;PCODE: $0000146E VOL: 0
;PCODE: $0000146F VOL: 0
;PCODE: $00001470 VOL: 0
;PCODE: $00001471 VOL: 0
;PCODE: $00001472 VOL: 0
;PCODE: $00001473 VOL: 0
;PCODE: $00001474 VOL: 0
;PCODE: $00001475 VOL: 0
;PCODE: $00001476 VOL: 0
;    }
;PCODE: $00001477 VOL: 0
;PCODE: $00001478 VOL: 0
;PCODE: $00001479 VOL: 0
;PCODE: $0000147A VOL: 0
;PCODE: $0000147B VOL: 0
;}
;PCODE: $0000147C VOL: 0
;PCODE: $0000147D VOL: 0
;PCODE: $0000147E VOL: 0
;
;inline void First_EE_init(void){ // settings transfer from eeprom to ram
;PCODE: $0000147F VOL: 0
;PCODE: $00001480 VOL: 0
;uint8_t i = 0;
;  for(i=0;i<COUNT_OF_UARTS;i++)
;PCODE: $00001481 VOL: 0
;	i -> R17
;PCODE: $00001482 VOL: 0
;PCODE: $00001483 VOL: 0
;PCODE: $00001484 VOL: 0
;PCODE: $00001485 VOL: 0
;PCODE: $00001486 VOL: 0
;PCODE: $00001487 VOL: 0
;PCODE: $00001488 VOL: 0
;PCODE: $00001489 VOL: 0
;PCODE: $0000148A VOL: 0
;PCODE: $0000148B VOL: 0
;PCODE: $0000148C VOL: 0
;    {
;EE_settings.baud_of_Uart[i] = 576; //57600baud
;PCODE: $0000148D VOL: 0
;PCODE: $0000148E VOL: 0
;PCODE: $0000148F VOL: 0
;PCODE: $00001490 VOL: 0
;PCODE: $00001491 VOL: 0
;PCODE: $00001492 VOL: 0
;PCODE: $00001493 VOL: 0
;EE_settings.MODE_of_Uart[i] = USART_NORMAL;
;PCODE: $00001494 VOL: 0
;PCODE: $00001495 VOL: 0
;PCODE: $00001496 VOL: 0
;PCODE: $00001497 VOL: 0
;    }
;PCODE: $00001498 VOL: 0
;PCODE: $00001499 VOL: 0
;PCODE: $0000149A VOL: 0
;PCODE: $0000149B VOL: 0
;PCODE: $0000149C VOL: 0
;  for(i=0;i<COUNT_OF_SPI;i++)
;PCODE: $0000149D VOL: 0
;PCODE: $0000149E VOL: 0
;PCODE: $0000149F VOL: 0
;PCODE: $000014A0 VOL: 0
;PCODE: $000014A1 VOL: 0
;PCODE: $000014A2 VOL: 0
;PCODE: $000014A3 VOL: 0
;PCODE: $000014A4 VOL: 0
;PCODE: $000014A5 VOL: 0
;    {
;EE_settings.MODE_of_Spi[i] = 0;
;PCODE: $000014A6 VOL: 0
;PCODE: $000014A7 VOL: 0
;PCODE: $000014A8 VOL: 0
;PCODE: $000014A9 VOL: 0
;EE_settings.prescaller_of_Spi[i] = 16;
;PCODE: $000014AA VOL: 0
;PCODE: $000014AB VOL: 0
;PCODE: $000014AC VOL: 0
;PCODE: $000014AD VOL: 0
;PCODE: $000014AE VOL: 0
;    }
;PCODE: $000014AF VOL: 0
;PCODE: $000014B0 VOL: 0
;PCODE: $000014B1 VOL: 0
;PCODE: $000014B2 VOL: 0
;PCODE: $000014B3 VOL: 0
;}
;PCODE: $000014B4 VOL: 0
;PCODE: $000014B5 VOL: 0
;PCODE: $000014B6 VOL: 0
;
;
;void HARDWARE_init(void)
;{
;PCODE: $000014B7 VOL: 0
;PCODE: $000014B8 VOL: 0
; GPIO_init();
;PCODE: $000014B9 VOL: 0
; ADC_init(); //Upd-6
;PCODE: $000014BA VOL: 0
; adc_calibrate(); //Upd-7
;PCODE: $000014BB VOL: 0
; TIM_0_init();
;PCODE: $000014BC VOL: 0
; TIM_1_init();
;PCODE: $000014BD VOL: 0
; TIM_2_init();
;PCODE: $000014BE VOL: 0
; TIM_3_init();
;PCODE: $000014BF VOL: 0
; INT_init();
;PCODE: $000014C0 VOL: 0
; USART_0_init();
;PCODE: $000014C1 VOL: 0
; USART_1_init();
;PCODE: $000014C2 VOL: 0
; Hard_SPI_Master_Init_default();
;PCODE: $000014C3 VOL: 0
;//TWI_init();
; rtc_init();
;PCODE: $000014C4 VOL: 0
;
;//i2c_init(); // I2C Bus initialization
;//w1_init(); // 1 Wire Bus initialization
;// 1 Wire Data port: PORTA
;// 1 Wire Data bit: 2
;// Note: 1 Wire port settings must be specified in the
;// Project|Configure|C Compiler|Libraries|1 Wire IDE menu.
;}
;PCODE: $000014C5 VOL: 0
;PCODE: $000014C6 VOL: 0
;
;void SOFTWARE_init (void){
;PCODE: $000014C7 VOL: 0
;PCODE: $000014C8 VOL: 0
;#ifdef EEPROM_REINIT  //Upd-5
;First_EE_init();  //начальная инициализация еепром (выполняется 1 раз при компиляции)
;#endif
;settings_EE_cpy_R(); //загрузка настроек из еепром
;PCODE: $000014C9 VOL: 0
;
;// check_after_pow_on();
;// flags_init();
;
;//WDT_Init();//Watchdog
;
;USART_Init(USART_0, RAM_settings.MODE_of_Uart[USART_0], RAM_settings.baud_of_Uart[USART_0]);
;PCODE: $000014CA VOL: 0
;PCODE: $000014CB VOL: 0
;PCODE: $000014CC VOL: 0
;PCODE: $000014CD VOL: 0
;PCODE: $000014CE VOL: 0
;PCODE: $000014CF VOL: 0
;PCODE: $000014D0 VOL: 0
;PCODE: $000014D1 VOL: 0
;USART_Init(USART_1, RAM_settings.MODE_of_Uart[USART_1], RAM_settings.baud_of_Uart[USART_1]);
;PCODE: $000014D2 VOL: 0
;PCODE: $000014D3 VOL: 0
;PCODE: $000014D4 VOL: 0
;PCODE: $000014D5 VOL: 0
;PCODE: $000014D6 VOL: 0
;PCODE: $000014D7 VOL: 0
;PCODE: $000014D8 VOL: 0
;PCODE: $000014D9 VOL: 0
;PCODE: $000014DA VOL: 0
;
;//Soft_SPI_Master_Init();
;//Hard_SPI_Master_Init_default();
;#warning грузить из еепром!
;SPI_init(SPI_0, SPI_MASTER, 1, 0, 16);
;PCODE: $000014DB VOL: 0
;PCODE: $000014DC VOL: 0
;PCODE: $000014DD VOL: 0
;PCODE: $000014DE VOL: 0
;PCODE: $000014DF VOL: 0
;PCODE: $000014E0 VOL: 0
;PCODE: $000014E1 VOL: 0
;PCODE: $000014E2 VOL: 0
;PCODE: $000014E3 VOL: 0
;PCODE: $000014E4 VOL: 0
;PCODE: $000014E5 VOL: 0
;LcdInit();//Upd-3 //soft spi on portA
;PCODE: $000014E6 VOL: 0
;
;//cust_I2C_init(I2C_0);
;
;PARSER_Init();
;PCODE: $000014E7 VOL: 0
;InitRTOS();			// Инициализируем ядро
;PCODE: $000014E8 VOL: 0
;
;//======
;Init_i2c();						// Запускаем и конфигурируем i2c
;PCODE: $000014E9 VOL: 0
;Init_Slave_i2c(&SlaveControl);	// Настраиваем событие выхода при сработке как Slave
;PCODE: $000014EA VOL: 0
;PCODE: $000014EB VOL: 0
;PCODE: $000014EC VOL: 0
;//======
;
;// Clear the SPI interrupt flag   //Upd-4
;#asm
;PCODE: $000014ED VOL: 0
    in   r30,spsr
;PCODE: $000014EE VOL: 0
    in   r30,spdr
;PCODE: $000014EF VOL: 0
;PCODE: $000014F0 VOL: 0
;
;#ifdef DEBUG
;LogIndex=0;					// Лог с начала
;PCODE: $000014F1 VOL: 0
;PCODE: $000014F2 VOL: 1
;WorkLog[LogIndex]=1;		// Записываем метку старта
;PCODE: $000014F3 VOL: 1
;PCODE: $000014F4 VOL: 1
;PCODE: $000014F5 VOL: 0
;PCODE: $000014F6 VOL: 0
;LogIndex++;
;PCODE: $000014F7 VOL: 1
;PCODE: $000014F8 VOL: 0
;PCODE: $000014F9 VOL: 0
;PCODE: $000014FA VOL: 0
;#endif
;}
;PCODE: $000014FB VOL: 0
;PCODE: $000014FC VOL: 0
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;#include "D_Globals/global_variables.h"
;#include "D_Globals/global_defines.h"
;#include "PARSER/pars_hndl.c"           //Upd-8 in folder
;//собственно парсер команд
;
;#include <adapter.h>
;
;//#include "RTOS/HAL.h"
;//#include "RTOS/EERTOS.c"
;#include "RTOS/EERTOSHAL.h"
;
;void PARS_Handler(uint8_t argc, char *argv[])
; 0000 0013 {
;PCODE: $000014FD VOL: 0
;PCODE: $000014FE VOL: 0
;char __flash *response = error;
; // uint8_t value = 0;
; // uint8_t mode = 0;
;  uint8_t i = 0;
;
; uint8_t Interface_Num = 0;
; uint32_t tmp = 0;
; bool Tmp_param_1 = 0;
; bool Tmp_param_2 = 0;
;
;char str [6];
;
;#ifdef DEBUG
;//StopRTOS();
;#endif
;/////////////////////SET_COMAND////////////////////////////////
;/////////////////////////////////////////////////////////////////
;if (!strcmpf(argv[0], Set))
;PCODE: $000014FF VOL: 0
;PCODE: $00001500 VOL: 0
;PCODE: $00001501 VOL: 0
;PCODE: $00001502 VOL: 0
;PCODE: $00001503 VOL: 0
;PCODE: $00001504 VOL: 0
;PCODE: $00001505 VOL: 0
;PCODE: $00001506 VOL: 0
;PCODE: $00001507 VOL: 0
;PCODE: $00001508 VOL: 0
;	argc -> Y+18
;	argv -> Y+16
;	*response -> R16,R17
;	i -> R19
;	Interface_Num -> R18
;	tmp -> Y+12
;	Tmp_param_1 -> R21
;	Tmp_param_2 -> R20
;	str -> Y+6
;PCODE: $00001509 VOL: 0
;PCODE: $0000150A VOL: 0
;PCODE: $0000150B VOL: 0
;PCODE: $0000150C VOL: 0
;PCODE: $0000150D VOL: 0
;PCODE: $0000150E VOL: 0
;PCODE: $0000150F VOL: 0
;PCODE: $00001510 VOL: 0
;PCODE: $00001511 VOL: 0
;PCODE: $00001512 VOL: 0
;PCODE: $00001513 VOL: 0
;PCODE: $00001514 VOL: 0
;PCODE: $00001515 VOL: 0
;PCODE: $00001516 VOL: 0
;PCODE: $00001517 VOL: 0
;PCODE: $00001518 VOL: 0
;PCODE: $00001519 VOL: 0
;PCODE: $0000151A VOL: 0
;PCODE: $0000151B VOL: 0
; {
;#ifdef DEBUG
; Put_In_Log("\r Set");
;PCODE: $0000151C VOL: 0
;PCODE: $0000151D VOL: 0
;PCODE: $0000151E VOL: 0
;PCODE: $0000151F VOL: 0
;#endif
;   if (argc > 1)
;PCODE: $00001520 VOL: 0
;PCODE: $00001521 VOL: 0
;PCODE: $00001522 VOL: 0
;  {
;//////////////////////////////////////////////////////////////////
;/////////////////////UART_SET_START///////////////////////////////
;      if (!strcmpf(argv[1], Uart))
;PCODE: $00001523 VOL: 0
;PCODE: $00001524 VOL: 0
;PCODE: $00001525 VOL: 0
;PCODE: $00001526 VOL: 0
;PCODE: $00001527 VOL: 0
;PCODE: $00001528 VOL: 0
;PCODE: $00001529 VOL: 0
;PCODE: $0000152A VOL: 0
;     {
;#ifdef DEBUG
;   Put_In_Log("\r Uart");
;PCODE: $0000152B VOL: 0
;PCODE: $0000152C VOL: 0
;PCODE: $0000152D VOL: 0
;PCODE: $0000152E VOL: 0
;#endif
;
;       if (argc > 2)
;PCODE: $0000152F VOL: 0
;PCODE: $00001530 VOL: 0
;PCODE: $00001531 VOL: 0
;        {
;          tmp = PARS_StrToUint(argv[2]);//Get number of interface
;PCODE: $00001532 VOL: 0
;PCODE: $00001533 VOL: 0
;PCODE: $00001534 VOL: 0
;PCODE: $00001535 VOL: 0
;PCODE: $00001536 VOL: 0
;PCODE: $00001537 VOL: 0
;          if (tmp <= COUNT_OF_UARTS){Interface_Num = tmp; response = ok;
;PCODE: $00001538 VOL: 0
;PCODE: $00001539 VOL: 0
;PCODE: $0000153A VOL: 0
;PCODE: $0000153B VOL: 0
;PCODE: $0000153C VOL: 0
;PCODE: $0000153D VOL: 0
;PCODE: $0000153E VOL: 0
;#ifdef DEBUG
;  Put_In_Log("\r Num");
;PCODE: $0000153F VOL: 0
;PCODE: $00001540 VOL: 0
;PCODE: $00001541 VOL: 0
;PCODE: $00001542 VOL: 0
;#endif
;          }
;          else{response = largeValue; goto exit;}
;PCODE: $00001543 VOL: 0
;PCODE: $00001544 VOL: 0
;PCODE: $00001545 VOL: 0
;PCODE: $00001546 VOL: 0
;PCODE: $00001547 VOL: 0
;PCODE: $00001548 VOL: 0
;
;         if (argc > 3)    //Mode
;PCODE: $00001549 VOL: 0
;PCODE: $0000154A VOL: 0
;PCODE: $0000154B VOL: 0
;        {
;             if (!strcmpf(argv[3], Mode))
;PCODE: $0000154C VOL: 0
;PCODE: $0000154D VOL: 0
;PCODE: $0000154E VOL: 0
;PCODE: $0000154F VOL: 0
;PCODE: $00001550 VOL: 0
;PCODE: $00001551 VOL: 0
;PCODE: $00001552 VOL: 0
;PCODE: $00001553 VOL: 0
;             {
;               tmp = PARS_StrToUchar(argv[4]); //Get uart mode
;PCODE: $00001554 VOL: 0
;PCODE: $00001555 VOL: 0
;PCODE: $00001556 VOL: 0
;PCODE: $00001557 VOL: 0
;PCODE: $00001558 VOL: 0
;PCODE: $00001559 VOL: 0
;              if (tmp==1 || tmp==0){RAM_settings.MODE_of_Uart[Interface_Num] = tmp; response = ok;
;PCODE: $0000155A VOL: 0
;PCODE: $0000155B VOL: 0
;PCODE: $0000155C VOL: 0
;PCODE: $0000155D VOL: 0
;PCODE: $0000155E VOL: 0
;PCODE: $0000155F VOL: 0
;PCODE: $00001560 VOL: 0
;PCODE: $00001561 VOL: 0
;PCODE: $00001562 VOL: 0
;PCODE: $00001563 VOL: 0
;PCODE: $00001564 VOL: 0
;PCODE: $00001565 VOL: 0
;PCODE: $00001566 VOL: 0
;PCODE: $00001567 VOL: 0
;PCODE: $00001568 VOL: 0
;PCODE: $00001569 VOL: 0
;PCODE: $0000156A VOL: 0
;#ifdef DEBUG
;  Put_In_Log("\r Mode");
;PCODE: $0000156B VOL: 0
;PCODE: $0000156C VOL: 0
;PCODE: $0000156D VOL: 0
;PCODE: $0000156E VOL: 0
;#endif
;               i = 2; //go to next param "speed"
;PCODE: $0000156F VOL: 0
;PCODE: $00001570 VOL: 0
;               }
;              else{response = largeValue;
;PCODE: $00001571 VOL: 0
;PCODE: $00001572 VOL: 0
;PCODE: $00001573 VOL: 0
;PCODE: $00001574 VOL: 0
;#ifdef DEBUG
; //USART_SendStr(SYSTEM_USART,"\rM EXIT");
; Put_In_Log("\rM EXIT");
;PCODE: $00001575 VOL: 0
;PCODE: $00001576 VOL: 0
;PCODE: $00001577 VOL: 0
;PCODE: $00001578 VOL: 0
;#endif
;            goto exit;}
;PCODE: $00001579 VOL: 0
;PCODE: $0000157A VOL: 0
;             }
;
;             if (!strcmpf(argv[3+i], Speed)) //may be 3 or 5th param
;PCODE: $0000157B VOL: 0
;PCODE: $0000157C VOL: 0
;PCODE: $0000157D VOL: 0
;PCODE: $0000157E VOL: 0
;PCODE: $0000157F VOL: 0
;PCODE: $00001580 VOL: 0
;PCODE: $00001581 VOL: 0
;PCODE: $00001582 VOL: 0
;PCODE: $00001583 VOL: 0
;PCODE: $00001584 VOL: 0
;PCODE: $00001585 VOL: 0
;PCODE: $00001586 VOL: 0
;PCODE: $00001587 VOL: 0
;PCODE: $00001588 VOL: 0
;             {
;              tmp = PARS_StrToUint(argv[4+i]); //get Baud Rate
;PCODE: $00001589 VOL: 0
;PCODE: $0000158A VOL: 0
;PCODE: $0000158B VOL: 0
;PCODE: $0000158C VOL: 0
;PCODE: $0000158D VOL: 0
;PCODE: $0000158E VOL: 0
;PCODE: $0000158F VOL: 0
;PCODE: $00001590 VOL: 0
;PCODE: $00001591 VOL: 0
;PCODE: $00001592 VOL: 0
;PCODE: $00001593 VOL: 0
;              if (tmp <= MAX_BAUD_RATE)
;PCODE: $00001594 VOL: 0
;PCODE: $00001595 VOL: 0
;PCODE: $00001596 VOL: 0
;              {
;              RAM_settings.baud_of_Uart[Interface_Num] = tmp;
;PCODE: $00001597 VOL: 0
;PCODE: $00001598 VOL: 0
;PCODE: $00001599 VOL: 0
;PCODE: $0000159A VOL: 0
;PCODE: $0000159B VOL: 0
;PCODE: $0000159C VOL: 0
;PCODE: $0000159D VOL: 0
;              response = ok; i = 0;
;PCODE: $0000159E VOL: 0
;PCODE: $0000159F VOL: 0
;PCODE: $000015A0 VOL: 0
;PCODE: $000015A1 VOL: 0
;#ifdef DEBUG
;  Put_In_Log("\r ");
;PCODE: $000015A2 VOL: 0
;PCODE: $000015A3 VOL: 0
;PCODE: $000015A4 VOL: 0
;PCODE: $000015A5 VOL: 0
;  Put_In_LogFl(Speed);
;PCODE: $000015A6 VOL: 0
;PCODE: $000015A7 VOL: 0
;PCODE: $000015A8 VOL: 0
;#endif
;              }
;              else{response = largeValue;
;PCODE: $000015A9 VOL: 0
;PCODE: $000015AA VOL: 0
;PCODE: $000015AB VOL: 0
;PCODE: $000015AC VOL: 0
;#ifdef DEBUG
; Put_In_Log("\rM EXIT");
;PCODE: $000015AD VOL: 0
;PCODE: $000015AE VOL: 0
;PCODE: $000015AF VOL: 0
;PCODE: $000015B0 VOL: 0
;#endif
;             goto exit;}
;PCODE: $000015B1 VOL: 0
;PCODE: $000015B2 VOL: 0
;        }
;
;     USART_Init(Interface_Num, RAM_settings.MODE_of_Uart[Interface_Num], RAM_settings.baud_of_Uart[Interface_Num]);
;PCODE: $000015B3 VOL: 0
;PCODE: $000015B4 VOL: 0
;PCODE: $000015B5 VOL: 0
;PCODE: $000015B6 VOL: 0
;PCODE: $000015B7 VOL: 0
;PCODE: $000015B8 VOL: 0
;PCODE: $000015B9 VOL: 0
;PCODE: $000015BA VOL: 0
;PCODE: $000015BB VOL: 0
;PCODE: $000015BC VOL: 0
;PCODE: $000015BD VOL: 0
;PCODE: $000015BE VOL: 0
;PCODE: $000015BF VOL: 0
;PCODE: $000015C0 VOL: 0
;PCODE: $000015C1 VOL: 0
;     Interface_Num = 0;
;PCODE: $000015C2 VOL: 0
;PCODE: $000015C3 VOL: 0
;
;     EE_settings.MODE_of_Uart[Interface_Num] = RAM_settings.MODE_of_Uart[Interface_Num];  //save to eeprom
;PCODE: $000015C4 VOL: 0
;PCODE: $000015C5 VOL: 0
;PCODE: $000015C6 VOL: 0
;PCODE: $000015C7 VOL: 0
;PCODE: $000015C8 VOL: 0
;PCODE: $000015C9 VOL: 0
;PCODE: $000015CA VOL: 0
;PCODE: $000015CB VOL: 0
;PCODE: $000015CC VOL: 0
;PCODE: $000015CD VOL: 0
;PCODE: $000015CE VOL: 0
;PCODE: $000015CF VOL: 0
;     EE_settings.baud_of_Uart[Interface_Num] = RAM_settings.baud_of_Uart[Interface_Num];
;PCODE: $000015D0 VOL: 0
;PCODE: $000015D1 VOL: 0
;PCODE: $000015D2 VOL: 0
;PCODE: $000015D3 VOL: 0
;PCODE: $000015D4 VOL: 0
;PCODE: $000015D5 VOL: 0
;PCODE: $000015D6 VOL: 0
;PCODE: $000015D7 VOL: 0
;PCODE: $000015D8 VOL: 0
;PCODE: $000015D9 VOL: 0
;PCODE: $000015DA VOL: 0
;PCODE: $000015DB VOL: 0
;PCODE: $000015DC VOL: 0
;PCODE: $000015DD VOL: 0
;#ifdef DEBUG          //не переносятся настройки!!!
; Put_In_Log("\r Usart_init");
;PCODE: $000015DE VOL: 0
;PCODE: $000015DF VOL: 0
;PCODE: $000015E0 VOL: 0
;PCODE: $000015E1 VOL: 0
; //print_settings_ram();
;#endif
;      }
;     }
;PCODE: $000015E2 VOL: 0
;#ifdef DEBUG
;       USART_FlushTxBuf(USART_0);
;PCODE: $000015E3 VOL: 0
;PCODE: $000015E4 VOL: 0
;PCODE: $000015E5 VOL: 0
;PCODE: $000015E6 VOL: 0
;#endif
;    }
;/////////////////////UART_SET_END////////////////////////////////
;/////////////////////////////////////////////////////////////////
;
;//////////////////////////////////////////////////////////////////
;/////////////////////SPI_SET_START////////////////////////////////
;     if (!strcmpf(argv[1], Spi))
;PCODE: $000015E7 VOL: 0
;PCODE: $000015E8 VOL: 0
;PCODE: $000015E9 VOL: 0
;PCODE: $000015EA VOL: 0
;PCODE: $000015EB VOL: 0
;PCODE: $000015EC VOL: 0
;PCODE: $000015ED VOL: 0
;PCODE: $000015EE VOL: 0
;PCODE: $000015EF VOL: 0
;     {
;#ifdef DEBUG
;    Put_In_Log("\r Spi");
;PCODE: $000015F0 VOL: 0
;PCODE: $000015F1 VOL: 0
;PCODE: $000015F2 VOL: 0
;PCODE: $000015F3 VOL: 0
;#endif
;       if (argc > 2)
;PCODE: $000015F4 VOL: 0
;PCODE: $000015F5 VOL: 0
;PCODE: $000015F6 VOL: 0
;        {
;#ifdef DEBUG
;  Put_In_Log("\rS Num");
;PCODE: $000015F7 VOL: 0
;PCODE: $000015F8 VOL: 0
;PCODE: $000015F9 VOL: 0
;PCODE: $000015FA VOL: 0
;#endif
;          tmp = PARS_StrToUchar(argv[2]);//Get number of interface
;PCODE: $000015FB VOL: 0
;PCODE: $000015FC VOL: 0
;PCODE: $000015FD VOL: 0
;PCODE: $000015FE VOL: 0
;PCODE: $000015FF VOL: 0
;PCODE: $00001600 VOL: 0
;          if (tmp <= COUNT_OF_SPI){Interface_Num = tmp; response = ok;}
;PCODE: $00001601 VOL: 0
;PCODE: $00001602 VOL: 0
;PCODE: $00001603 VOL: 0
;PCODE: $00001604 VOL: 0
;PCODE: $00001605 VOL: 0
;PCODE: $00001606 VOL: 0
;PCODE: $00001607 VOL: 0
;          else{response = largeValue; goto exit;}
;PCODE: $00001608 VOL: 0
;PCODE: $00001609 VOL: 0
;PCODE: $0000160A VOL: 0
;PCODE: $0000160B VOL: 0
;PCODE: $0000160C VOL: 0
;PCODE: $0000160D VOL: 0
;
;      if (argc > 3)    //Mode
;PCODE: $0000160E VOL: 0
;PCODE: $0000160F VOL: 0
;PCODE: $00001610 VOL: 0
;      {
;         if (!strcmpf(argv[3], Mode))
;PCODE: $00001611 VOL: 0
;PCODE: $00001612 VOL: 0
;PCODE: $00001613 VOL: 0
;PCODE: $00001614 VOL: 0
;PCODE: $00001615 VOL: 0
;PCODE: $00001616 VOL: 0
;PCODE: $00001617 VOL: 0
;PCODE: $00001618 VOL: 0
;         {
;            tmp = PARS_StrToUchar(argv[4]); //Get spi mode
;PCODE: $00001619 VOL: 0
;PCODE: $0000161A VOL: 0
;PCODE: $0000161B VOL: 0
;PCODE: $0000161C VOL: 0
;PCODE: $0000161D VOL: 0
;PCODE: $0000161E VOL: 0
;            if (tmp==1 || tmp==0){RAM_settings.MODE_of_Spi[Interface_Num] = tmp;
;PCODE: $0000161F VOL: 0
;PCODE: $00001620 VOL: 0
;PCODE: $00001621 VOL: 0
;PCODE: $00001622 VOL: 0
;PCODE: $00001623 VOL: 0
;PCODE: $00001624 VOL: 0
;PCODE: $00001625 VOL: 0
;PCODE: $00001626 VOL: 0
;PCODE: $00001627 VOL: 0
;PCODE: $00001628 VOL: 0
;PCODE: $00001629 VOL: 0
;PCODE: $0000162A VOL: 0
;PCODE: $0000162B VOL: 0
;PCODE: $0000162C VOL: 0
;PCODE: $0000162D VOL: 0
;            i = 2; //go to next param "speed"
;PCODE: $0000162E VOL: 0
;PCODE: $0000162F VOL: 0
;            response = ok;
;PCODE: $00001630 VOL: 0
;PCODE: $00001631 VOL: 0
; #ifdef DEBUG
;Put_In_Log("\rS Mode-");
;PCODE: $00001632 VOL: 0
;PCODE: $00001633 VOL: 0
;PCODE: $00001634 VOL: 0
;PCODE: $00001635 VOL: 0
;#endif
;            }
;            else{response = largeValue; goto exit;}
;PCODE: $00001636 VOL: 0
;PCODE: $00001637 VOL: 0
;PCODE: $00001638 VOL: 0
;PCODE: $00001639 VOL: 0
;PCODE: $0000163A VOL: 0
;PCODE: $0000163B VOL: 0
;        }
;
;          if (!strcmpf(argv[3+i], Prescaller)) //Prescaller, may be 3 or 5th param
;PCODE: $0000163C VOL: 0
;PCODE: $0000163D VOL: 0
;PCODE: $0000163E VOL: 0
;PCODE: $0000163F VOL: 0
;PCODE: $00001640 VOL: 0
;PCODE: $00001641 VOL: 0
;PCODE: $00001642 VOL: 0
;PCODE: $00001643 VOL: 0
;PCODE: $00001644 VOL: 0
;PCODE: $00001645 VOL: 0
;PCODE: $00001646 VOL: 0
;PCODE: $00001647 VOL: 0
;PCODE: $00001648 VOL: 0
;PCODE: $00001649 VOL: 0
;         {
;            tmp = PARS_StrToUchar(argv[4+i]); //get SPI prescaller Rate
;PCODE: $0000164A VOL: 0
;PCODE: $0000164B VOL: 0
;PCODE: $0000164C VOL: 0
;PCODE: $0000164D VOL: 0
;PCODE: $0000164E VOL: 0
;PCODE: $0000164F VOL: 0
;PCODE: $00001650 VOL: 0
;PCODE: $00001651 VOL: 0
;PCODE: $00001652 VOL: 0
;PCODE: $00001653 VOL: 0
;PCODE: $00001654 VOL: 0
;            if (tmp <= MAX_SPI_PRESCALLER){RAM_settings.prescaller_of_Spi[Interface_Num] = tmp;
;PCODE: $00001655 VOL: 0
;PCODE: $00001656 VOL: 0
;PCODE: $00001657 VOL: 0
;PCODE: $00001658 VOL: 0
;PCODE: $00001659 VOL: 0
;PCODE: $0000165A VOL: 0
;PCODE: $0000165B VOL: 0
;PCODE: $0000165C VOL: 0
;PCODE: $0000165D VOL: 0
;PCODE: $0000165E VOL: 0
;            i += 2;
;PCODE: $0000165F VOL: 0
;PCODE: $00001660 VOL: 0
;            response = ok;
;PCODE: $00001661 VOL: 0
;PCODE: $00001662 VOL: 0
;#ifdef DEBUG
;Put_In_Log("\rS Presc-");
;PCODE: $00001663 VOL: 0
;PCODE: $00001664 VOL: 0
;PCODE: $00001665 VOL: 0
;PCODE: $00001666 VOL: 0
;#endif
;            }
;            else{response = largeValue; goto exit;}
;PCODE: $00001667 VOL: 0
;PCODE: $00001668 VOL: 0
;PCODE: $00001669 VOL: 0
;PCODE: $0000166A VOL: 0
;PCODE: $0000166B VOL: 0
;PCODE: $0000166C VOL: 0
;        }
;
;          if (!strcmpf(argv[3+i], PhaPol)) //may be 3 or 5 or 7th  param
;PCODE: $0000166D VOL: 0
;PCODE: $0000166E VOL: 0
;PCODE: $0000166F VOL: 0
;PCODE: $00001670 VOL: 0
;PCODE: $00001671 VOL: 0
;PCODE: $00001672 VOL: 0
;PCODE: $00001673 VOL: 0
;PCODE: $00001674 VOL: 0
;PCODE: $00001675 VOL: 0
;PCODE: $00001676 VOL: 0
;PCODE: $00001677 VOL: 0
;PCODE: $00001678 VOL: 0
;PCODE: $00001679 VOL: 0
;PCODE: $0000167A VOL: 0
;         {
;            tmp = PARS_StrToUchar(argv[4+i]);//get phase/polarity mode (0-3)
;PCODE: $0000167B VOL: 0
;PCODE: $0000167C VOL: 0
;PCODE: $0000167D VOL: 0
;PCODE: $0000167E VOL: 0
;PCODE: $0000167F VOL: 0
;PCODE: $00001680 VOL: 0
;PCODE: $00001681 VOL: 0
;PCODE: $00001682 VOL: 0
;PCODE: $00001683 VOL: 0
;PCODE: $00001684 VOL: 0
;PCODE: $00001685 VOL: 0
;           if (tmp>=0 && tmp <= 3)
;PCODE: $00001686 VOL: 0
;PCODE: $00001687 VOL: 0
;PCODE: $00001688 VOL: 0
;PCODE: $00001689 VOL: 0
;PCODE: $0000168A VOL: 0
;PCODE: $0000168B VOL: 0
;PCODE: $0000168C VOL: 0
;PCODE: $0000168D VOL: 0
;PCODE: $0000168E VOL: 0
;PCODE: $0000168F VOL: 0
;           {
;            switch(tmp){  //phase/polarity select
;PCODE: $00001690 VOL: 0
;             case 0:
;PCODE: $00001691 VOL: 0
;PCODE: $00001692 VOL: 0
;              Tmp_param_1 = 0; Tmp_param_2 = 0;
;PCODE: $00001693 VOL: 0
;PCODE: $00001694 VOL: 0
;PCODE: $00001695 VOL: 0
;PCODE: $00001696 VOL: 0
;             break;
;PCODE: $00001697 VOL: 0
;             case 1:
;PCODE: $00001698 VOL: 0
;PCODE: $00001699 VOL: 0
;PCODE: $0000169A VOL: 0
;              Tmp_param_1 = 0; Tmp_param_2 = 1;
;PCODE: $0000169B VOL: 0
;PCODE: $0000169C VOL: 0
;PCODE: $0000169D VOL: 0
;PCODE: $0000169E VOL: 0
;             break;
;PCODE: $0000169F VOL: 0
;             case 2:
;PCODE: $000016A0 VOL: 0
;PCODE: $000016A1 VOL: 0
;PCODE: $000016A2 VOL: 0
;              Tmp_param_1 = 1; Tmp_param_2 = 0;
;PCODE: $000016A3 VOL: 0
;PCODE: $000016A4 VOL: 0
;PCODE: $000016A5 VOL: 0
;PCODE: $000016A6 VOL: 0
;             break;
;PCODE: $000016A7 VOL: 0
;             case 3:
;PCODE: $000016A8 VOL: 0
;PCODE: $000016A9 VOL: 0
;PCODE: $000016AA VOL: 0
;              Tmp_param_1 = 1; Tmp_param_2 = 1;
;PCODE: $000016AB VOL: 0
;PCODE: $000016AC VOL: 0
;PCODE: $000016AD VOL: 0
;PCODE: $000016AE VOL: 0
;             break;
;PCODE: $000016AF VOL: 0
;             default:
;PCODE: $000016B0 VOL: 0
;              Tmp_param_1 = 0; Tmp_param_2 = 0;
;PCODE: $000016B1 VOL: 0
;PCODE: $000016B2 VOL: 0
;PCODE: $000016B3 VOL: 0
;PCODE: $000016B4 VOL: 0
;             break;
;PCODE: $000016B5 VOL: 0
;            } response = ok;
;PCODE: $000016B6 VOL: 0
;PCODE: $000016B7 VOL: 0
;PCODE: $000016B8 VOL: 0
;#ifdef DEBUG
; Put_In_Log("\rS PhaPol-");
;PCODE: $000016B9 VOL: 0
;PCODE: $000016BA VOL: 0
;PCODE: $000016BB VOL: 0
;PCODE: $000016BC VOL: 0
;#endif
;            RAM_settings.PhaPol_of_Spi[Interface_Num] = tmp; //Upd - 1
;PCODE: $000016BD VOL: 0
;PCODE: $000016BE VOL: 0
;PCODE: $000016BF VOL: 0
;PCODE: $000016C0 VOL: 0
;PCODE: $000016C1 VOL: 0
;PCODE: $000016C2 VOL: 0
;PCODE: $000016C3 VOL: 0
;           }
;           else{response = wrongValue; goto exit;}
;PCODE: $000016C4 VOL: 0
;PCODE: $000016C5 VOL: 0
;PCODE: $000016C6 VOL: 0
;PCODE: $000016C7 VOL: 0
;PCODE: $000016C8 VOL: 0
;PCODE: $000016C9 VOL: 0
;         }
;     SPI_init(Interface_Num, RAM_settings.MODE_of_Spi[Interface_Num], Tmp_param_2 ,Tmp_param_1, RAM_settings.prescaller_of_Spi[Interface_Num]);
;PCODE: $000016CA VOL: 0
;PCODE: $000016CB VOL: 0
;PCODE: $000016CC VOL: 0
;PCODE: $000016CD VOL: 0
;PCODE: $000016CE VOL: 0
;PCODE: $000016CF VOL: 0
;PCODE: $000016D0 VOL: 0
;PCODE: $000016D1 VOL: 0
;PCODE: $000016D2 VOL: 0
;PCODE: $000016D3 VOL: 0
;PCODE: $000016D4 VOL: 0
;PCODE: $000016D5 VOL: 0
;PCODE: $000016D6 VOL: 0
;PCODE: $000016D7 VOL: 0
;PCODE: $000016D8 VOL: 0
;     i = 0; Tmp_param_1=0; Tmp_param_2=0;
;PCODE: $000016D9 VOL: 0
;PCODE: $000016DA VOL: 0
;PCODE: $000016DB VOL: 0
;PCODE: $000016DC VOL: 0
;PCODE: $000016DD VOL: 0
;PCODE: $000016DE VOL: 0
;
;      EE_settings.MODE_of_Spi[Interface_Num] = RAM_settings.MODE_of_Spi[Interface_Num];
;PCODE: $000016DF VOL: 0
;PCODE: $000016E0 VOL: 0
;PCODE: $000016E1 VOL: 0
;PCODE: $000016E2 VOL: 0
;PCODE: $000016E3 VOL: 0
;PCODE: $000016E4 VOL: 0
;PCODE: $000016E5 VOL: 0
;PCODE: $000016E6 VOL: 0
;PCODE: $000016E7 VOL: 0
;PCODE: $000016E8 VOL: 0
;PCODE: $000016E9 VOL: 0
;PCODE: $000016EA VOL: 0
;      EE_settings.PhaPol_of_Spi[Interface_Num] = RAM_settings.PhaPol_of_Spi[Interface_Num];//Upd - 1
;PCODE: $000016EB VOL: 0
;PCODE: $000016EC VOL: 0
;PCODE: $000016ED VOL: 0
;PCODE: $000016EE VOL: 0
;PCODE: $000016EF VOL: 0
;PCODE: $000016F0 VOL: 0
;PCODE: $000016F1 VOL: 0
;PCODE: $000016F2 VOL: 0
;PCODE: $000016F3 VOL: 0
;PCODE: $000016F4 VOL: 0
;PCODE: $000016F5 VOL: 0
;PCODE: $000016F6 VOL: 0
;     // Tmp_param_2 ,Tmp_param_1,
;      EE_settings.prescaller_of_Spi[Interface_Num] = RAM_settings.prescaller_of_Spi[Interface_Num];
;PCODE: $000016F7 VOL: 0
;PCODE: $000016F8 VOL: 0
;PCODE: $000016F9 VOL: 0
;PCODE: $000016FA VOL: 0
;PCODE: $000016FB VOL: 0
;PCODE: $000016FC VOL: 0
;PCODE: $000016FD VOL: 0
;PCODE: $000016FE VOL: 0
;PCODE: $000016FF VOL: 0
;PCODE: $00001700 VOL: 0
;PCODE: $00001701 VOL: 0
;PCODE: $00001702 VOL: 0
;
;
;#ifdef DEBUG
; Put_In_Log("\rS SpiInit");
;PCODE: $00001703 VOL: 0
;PCODE: $00001704 VOL: 0
;PCODE: $00001705 VOL: 0
;PCODE: $00001706 VOL: 0
;#endif
;      }
;     }
;PCODE: $00001707 VOL: 0
;    }
;PCODE: $00001708 VOL: 0
;/////////////////////SPI_SET_END//////////////////////////////////
;//////////////////////////////////////////////////////////////////
;  }
;PCODE: $00001709 VOL: 0
; }
;PCODE: $0000170A VOL: 0
;
;/////////////////////WRITE_COMAND////////////////////////////////
;/////////////////////////////////////////////////////////////////
;if (!strcmpf(argv[0], W)) //Write
;PCODE: $0000170B VOL: 0
;PCODE: $0000170C VOL: 0
;PCODE: $0000170D VOL: 0
;PCODE: $0000170E VOL: 0
;PCODE: $0000170F VOL: 0
;PCODE: $00001710 VOL: 0
;PCODE: $00001711 VOL: 0
;PCODE: $00001712 VOL: 0
;PCODE: $00001713 VOL: 0
; {
; #ifdef DEBUG
; Put_In_Log("\r W");
;PCODE: $00001714 VOL: 0
;PCODE: $00001715 VOL: 0
;PCODE: $00001716 VOL: 0
;PCODE: $00001717 VOL: 0
;#endif
;  if (argc > 1)
;PCODE: $00001718 VOL: 0
;PCODE: $00001719 VOL: 0
;PCODE: $0000171A VOL: 0
;  {
;///////////////////////////////////////////////////////////////////
;/////////////////////UART_WRITE_START//////////////////////////////
;      if (!strcmpf(argv[1], Uart))
;PCODE: $0000171B VOL: 0
;PCODE: $0000171C VOL: 0
;PCODE: $0000171D VOL: 0
;PCODE: $0000171E VOL: 0
;PCODE: $0000171F VOL: 0
;PCODE: $00001720 VOL: 0
;PCODE: $00001721 VOL: 0
;PCODE: $00001722 VOL: 0
;     {
;       if (argc > 2)
;PCODE: $00001723 VOL: 0
;PCODE: $00001724 VOL: 0
;PCODE: $00001725 VOL: 0
;        {
;          tmp = PARS_StrToUchar(argv[2]);//Get number of interface to write
;PCODE: $00001726 VOL: 0
;PCODE: $00001727 VOL: 0
;PCODE: $00001728 VOL: 0
;PCODE: $00001729 VOL: 0
;PCODE: $0000172A VOL: 0
;PCODE: $0000172B VOL: 0
;          if (tmp <= COUNT_OF_UARTS){Interface_Num = tmp; response = ok;}
;PCODE: $0000172C VOL: 0
;PCODE: $0000172D VOL: 0
;PCODE: $0000172E VOL: 0
;PCODE: $0000172F VOL: 0
;PCODE: $00001730 VOL: 0
;PCODE: $00001731 VOL: 0
;PCODE: $00001732 VOL: 0
;          else{response = largeValue;}
;PCODE: $00001733 VOL: 0
;PCODE: $00001734 VOL: 0
;PCODE: $00001735 VOL: 0
;PCODE: $00001736 VOL: 0
;PCODE: $00001737 VOL: 0
;      if (argc > 3)    //Data
;PCODE: $00001738 VOL: 0
;PCODE: $00001739 VOL: 0
;PCODE: $0000173A VOL: 0
;      {
;      StopRTOS; //так как передача по UART-у может быть медленной,RTOS на время замедляется (Ибо внешний интерфейс приоритетнее)
;PCODE: $0000173B VOL: 0
;        USART_SendStr(Interface_Num, argv[3]);
;PCODE: $0000173C VOL: 0
;PCODE: $0000173D VOL: 0
;PCODE: $0000173E VOL: 0
;PCODE: $0000173F VOL: 0
;PCODE: $00001740 VOL: 0
;      RunRTOS;
;PCODE: $00001741 VOL: 0
;      #ifdef DEBUG
;Put_In_Log("\r U D>TX ");
;PCODE: $00001742 VOL: 0
;PCODE: $00001743 VOL: 0
;PCODE: $00001744 VOL: 0
;PCODE: $00001745 VOL: 0
;  ltoa(PARS_StrToUint(argv[3]),str);
;PCODE: $00001746 VOL: 0
;PCODE: $00001747 VOL: 0
;PCODE: $00001748 VOL: 0
;PCODE: $00001749 VOL: 0
;PCODE: $0000174A VOL: 0
;PCODE: $0000174B VOL: 0
;PCODE: $0000174C VOL: 0
;PCODE: $0000174D VOL: 0
;PCODE: $0000174E VOL: 0
;Put_In_Log(str); //convert dec to str
;PCODE: $0000174F VOL: 0
;PCODE: $00001750 VOL: 0
;PCODE: $00001751 VOL: 0
;     #endif
;      }
;     }
;PCODE: $00001752 VOL: 0
;    }
;PCODE: $00001753 VOL: 0
;/////////////////////UART_WRITE_END////////////////////////////////
;///////////////////////////////////////////////////////////////////
;
;///////////////////////////////////////////////////////////////////
;/////////////////////SPI_WRITE-READ_START//////////////////////////
;    if (!strcmpf(argv[1], Spi))
;PCODE: $00001754 VOL: 0
;PCODE: $00001755 VOL: 0
;PCODE: $00001756 VOL: 0
;PCODE: $00001757 VOL: 0
;PCODE: $00001758 VOL: 0
;PCODE: $00001759 VOL: 0
;PCODE: $0000175A VOL: 0
;PCODE: $0000175B VOL: 0
;PCODE: $0000175C VOL: 0
;     {
; #ifdef DEBUG
; //USART_SendStr(SYSTEM_USART,"\r SPI ");
; #endif
;       if (argc > 2)
;PCODE: $0000175D VOL: 0
;PCODE: $0000175E VOL: 0
;PCODE: $0000175F VOL: 0
;        {
;          tmp = PARS_StrToUchar(argv[2]);//Get number of interface to write
;PCODE: $00001760 VOL: 0
;PCODE: $00001761 VOL: 0
;PCODE: $00001762 VOL: 0
;PCODE: $00001763 VOL: 0
;PCODE: $00001764 VOL: 0
;PCODE: $00001765 VOL: 0
;          if (tmp <= COUNT_OF_SPI){Interface_Num = tmp; response = ok;
;PCODE: $00001766 VOL: 0
;PCODE: $00001767 VOL: 0
;PCODE: $00001768 VOL: 0
;PCODE: $00001769 VOL: 0
;PCODE: $0000176A VOL: 0
;PCODE: $0000176B VOL: 0
;PCODE: $0000176C VOL: 0
; #ifdef DEBUG
; //USART_SendStr(SYSTEM_USART,"\r SPI num w ");
; #endif
;          }
;          else{response = largeValue;}
;PCODE: $0000176D VOL: 0
;PCODE: $0000176E VOL: 0
;PCODE: $0000176F VOL: 0
;PCODE: $00001770 VOL: 0
;PCODE: $00001771 VOL: 0
;
;      if (argc > 3)    //Data
;PCODE: $00001772 VOL: 0
;PCODE: $00001773 VOL: 0
;PCODE: $00001774 VOL: 0
;      {
;#ifdef DEBUG
;
;Put_In_Log("\r S D>TX ");
;PCODE: $00001775 VOL: 0
;PCODE: $00001776 VOL: 0
;PCODE: $00001777 VOL: 0
;PCODE: $00001778 VOL: 0
; ltoa(PARS_StrToUint(argv[3]),str);  //возможно вывести не > 65535
;PCODE: $00001779 VOL: 0
;PCODE: $0000177A VOL: 0
;PCODE: $0000177B VOL: 0
;PCODE: $0000177C VOL: 0
;PCODE: $0000177D VOL: 0
;PCODE: $0000177E VOL: 0
;PCODE: $0000177F VOL: 0
;PCODE: $00001780 VOL: 0
;PCODE: $00001781 VOL: 0
;Put_In_Log(str); //convert dec to str
;PCODE: $00001782 VOL: 0
;PCODE: $00001783 VOL: 0
;PCODE: $00001784 VOL: 0
; #endif
;
; SPI_RW_Buf(10/*array_size(argv[3])*/, argv[3], Spi0_RX_buf); //TODO определять кол-во автоматически
;PCODE: $00001785 VOL: 0
;PCODE: $00001786 VOL: 0
;PCODE: $00001787 VOL: 0
;PCODE: $00001788 VOL: 0
;PCODE: $00001789 VOL: 0
;PCODE: $0000178A VOL: 1
;PCODE: $0000178B VOL: 0
;PCODE: $0000178C VOL: 0
;
; #ifdef DEBUG
;Put_In_Log("\r S D<RX ");
;PCODE: $0000178D VOL: 0
;PCODE: $0000178E VOL: 0
;PCODE: $0000178F VOL: 0
;PCODE: $00001790 VOL: 0
;Put_In_Log(Spi0_RX_buf);
;PCODE: $00001791 VOL: 1
;PCODE: $00001792 VOL: 0
;PCODE: $00001793 VOL: 0
;//SetTimerTask(Task_SPI_ClrBuf, 10);
; // USART_SendStr(SYSTEM_USART, Spi0_RX_buf);
;  #endif
;      }
;     }
;PCODE: $00001794 VOL: 0
;    }
;PCODE: $00001795 VOL: 0
;/////////////////////SPI_WRITE-READ_END////////////////////////////
;///////////////////////////////////////////////////////////////////
;
;///////////////////////////////////////////////////////////////////
;/////////////////////I2C_WRITE_START//////////////////////////////
;    if (!strcmpf(argv[1], I2c))
;PCODE: $00001796 VOL: 0
;PCODE: $00001797 VOL: 0
;PCODE: $00001798 VOL: 0
;PCODE: $00001799 VOL: 0
;PCODE: $0000179A VOL: 0
;PCODE: $0000179B VOL: 0
;PCODE: $0000179C VOL: 0
;PCODE: $0000179D VOL: 0
;PCODE: $0000179E VOL: 0
;     {
; #ifdef DEBUG
; //USART_SendStr(SYSTEM_USART,"\r I2c ");
; #endif
;       if (argc > 2)
;PCODE: $0000179F VOL: 0
;PCODE: $000017A0 VOL: 0
;PCODE: $000017A1 VOL: 0
;        {
;          tmp = PARS_StrToUchar(argv[2]);//Get number of interface to write
;PCODE: $000017A2 VOL: 0
;PCODE: $000017A3 VOL: 0
;PCODE: $000017A4 VOL: 0
;PCODE: $000017A5 VOL: 0
;PCODE: $000017A6 VOL: 0
;PCODE: $000017A7 VOL: 0
;          if (tmp <= COUNT_OF_I2C){Interface_Num = tmp; response = ok;
;PCODE: $000017A8 VOL: 0
;PCODE: $000017A9 VOL: 0
;PCODE: $000017AA VOL: 0
;PCODE: $000017AB VOL: 0
;PCODE: $000017AC VOL: 0
;PCODE: $000017AD VOL: 0
;PCODE: $000017AE VOL: 0
; #ifdef DEBUG
; //USART_SendStr(SYSTEM_USART,"\r I2C num w ");
; #endif
;          }
;          else{response = largeValue;}
;PCODE: $000017AF VOL: 0
;PCODE: $000017B0 VOL: 0
;PCODE: $000017B1 VOL: 0
;PCODE: $000017B2 VOL: 0
;PCODE: $000017B3 VOL: 0
;
;      if (argc > 3)    //Data
;PCODE: $000017B4 VOL: 0
;PCODE: $000017B5 VOL: 0
;PCODE: $000017B6 VOL: 0
;      {
;#ifdef DEBUG
;
;Put_In_Log("\r I2C D>TX ");
;PCODE: $000017B7 VOL: 0
;PCODE: $000017B8 VOL: 0
;PCODE: $000017B9 VOL: 0
;PCODE: $000017BA VOL: 0
; ltoa(PARS_StrToUint(argv[3]),str);  //возможно вывести не > 65535
;PCODE: $000017BB VOL: 0
;PCODE: $000017BC VOL: 0
;PCODE: $000017BD VOL: 0
;PCODE: $000017BE VOL: 0
;PCODE: $000017BF VOL: 0
;PCODE: $000017C0 VOL: 0
;PCODE: $000017C1 VOL: 0
;PCODE: $000017C2 VOL: 0
;PCODE: $000017C3 VOL: 0
; USART_SendStr(SYSTEM_USART,str); //convert dec to str
;PCODE: $000017C4 VOL: 0
;PCODE: $000017C5 VOL: 0
;PCODE: $000017C6 VOL: 0
;PCODE: $000017C7 VOL: 0
;PCODE: $000017C8 VOL: 0
; #endif
;
; //I2C_RW_Buf(10/*array_size(argv[3])*/, argv[3], Spi0_RX_buf); //TODO определять кол-во автоматически
; //I2C_write(argv[3]);
;
;
; #ifdef DEBUG
;Put_In_Log("\r I2C D<RX ");
;PCODE: $000017C9 VOL: 0
;PCODE: $000017CA VOL: 0
;PCODE: $000017CB VOL: 0
;PCODE: $000017CC VOL: 0
;  USART_SendStr(SYSTEM_USART, Spi0_RX_buf);
;PCODE: $000017CD VOL: 0
;PCODE: $000017CE VOL: 0
;PCODE: $000017CF VOL: 1
;PCODE: $000017D0 VOL: 0
;PCODE: $000017D1 VOL: 0
;  #endif
;      }
;     }
;PCODE: $000017D2 VOL: 0
;    }
;PCODE: $000017D3 VOL: 0
;/////////////////////I2C_WRITE_END/////////////////////////////////
;///////////////////////////////////////////////////////////////////
;   }
;PCODE: $000017D4 VOL: 0
; }
;PCODE: $000017D5 VOL: 0
;
; /*
; Проверить  приём с uart1,
; дописать настройки spi (в 1 переменную!!).
; дописать сохранение в еепром,
;
; сделать и2с,
; добавить опцию автопередачи с/на выбраный интерфейс.
;
; +Поднять диспетчер
; */
;
;    if (!strcmpf(argv[0], Help)){ print_help(); response = ok; }
;PCODE: $000017D6 VOL: 0
;PCODE: $000017D7 VOL: 0
;PCODE: $000017D8 VOL: 0
;PCODE: $000017D9 VOL: 0
;PCODE: $000017DA VOL: 0
;PCODE: $000017DB VOL: 0
;PCODE: $000017DC VOL: 0
;PCODE: $000017DD VOL: 0
;PCODE: $000017DE VOL: 0
;PCODE: $000017DF VOL: 0
;PCODE: $000017E0 VOL: 0
;PCODE: $000017E1 VOL: 0
;    if (!strcmpf(argv[0], boot)){#asm("call 0x1E00");response = ok;}//Boot_reset "Goto bootloader"
;PCODE: $000017E2 VOL: 0
;PCODE: $000017E3 VOL: 0
;PCODE: $000017E4 VOL: 0
;PCODE: $000017E5 VOL: 0
;PCODE: $000017E6 VOL: 0
;PCODE: $000017E7 VOL: 0
;PCODE: $000017E8 VOL: 0
;PCODE: $000017E9 VOL: 0
;PCODE: $000017EA VOL: 0
;PCODE: $000017EB VOL: 0
	call 0x1E00
;PCODE: $000017EC VOL: 0
;PCODE: $000017ED VOL: 0
;PCODE: $000017EE VOL: 0
;    if (!strcmpf(argv[0], reset)){#asm("jmp 0x0000");response = ok;} //reset
;PCODE: $000017EF VOL: 0
;PCODE: $000017F0 VOL: 0
;PCODE: $000017F1 VOL: 0
;PCODE: $000017F2 VOL: 0
;PCODE: $000017F3 VOL: 0
;PCODE: $000017F4 VOL: 0
;PCODE: $000017F5 VOL: 0
;PCODE: $000017F6 VOL: 0
;PCODE: $000017F7 VOL: 0
;PCODE: $000017F8 VOL: 0
	jmp 0x0000
;PCODE: $000017F9 VOL: 0
;PCODE: $000017FA VOL: 0
;PCODE: $000017FB VOL: 0
;    // dbg не успевает вывестись из-за прерывания ртос(вунужден временно останавливать, а с help всё ок.)
;    if (!strcmpf(argv[0], dbg)){StopRTOS(); print_settings_eeprom(); print_settings_ram(); print_sys(); response = ok; RunRTOS();}
;PCODE: $000017FC VOL: 0
;PCODE: $000017FD VOL: 0
;PCODE: $000017FE VOL: 0
;PCODE: $000017FF VOL: 0
;PCODE: $00001800 VOL: 0
;PCODE: $00001801 VOL: 0
;PCODE: $00001802 VOL: 0
;PCODE: $00001803 VOL: 0
;PCODE: $00001804 VOL: 0
;PCODE: $00001805 VOL: 0
;PCODE: $00001806 VOL: 0
;PCODE: $00001807 VOL: 0
;PCODE: $00001808 VOL: 0
;PCODE: $00001809 VOL: 0
;PCODE: $0000180A VOL: 0
;PCODE: $0000180B VOL: 0
;    if (!strcmpf(argv[0], "s")){ print_sys(); response = ok;}
;PCODE: $0000180C VOL: 0
;PCODE: $0000180D VOL: 0
;PCODE: $0000180E VOL: 0
;PCODE: $0000180F VOL: 0
;PCODE: $00001810 VOL: 0
;PCODE: $00001811 VOL: 0
;PCODE: $00001812 VOL: 0
;PCODE: $00001813 VOL: 0
;PCODE: $00001814 VOL: 0
;PCODE: $00001815 VOL: 0
;PCODE: $00001816 VOL: 0
;PCODE: $00001817 VOL: 0
;PCODE: $00001818 VOL: 0
;        if (!strcmpf(argv[0], "E")){SetTask(StartWrite2EPP); response = ok;}  // Запускаем процесс записи в ЕЕПРОМ.
;PCODE: $00001819 VOL: 0
;PCODE: $0000181A VOL: 0
;PCODE: $0000181B VOL: 0
;PCODE: $0000181C VOL: 0
;PCODE: $0000181D VOL: 0
;PCODE: $0000181E VOL: 0
;PCODE: $0000181F VOL: 0
;PCODE: $00001820 VOL: 0
;PCODE: $00001821 VOL: 0
;PCODE: $00001822 VOL: 0
;PCODE: $00001823 VOL: 0
;PCODE: $00001824 VOL: 0
;PCODE: $00001825 VOL: 0
;PCODE: $00001826 VOL: 0
;PCODE: $00001827 VOL: 0
;
; //EE_settings = RAM_settings; //rewrite settings to EEPROM
;
;exit:
;PCODE: $00001828 VOL: 0
;PCODE: $00001829 VOL: 0
;  //USART_FlushTxBuf(SYSTEM_USART);
;  USART_SendStrFl(SYSTEM_USART,response);
;PCODE: $0000182A VOL: 0
;PCODE: $0000182B VOL: 0
;PCODE: $0000182C VOL: 0
;PCODE: $0000182D VOL: 0
;#ifdef DEBUG
; // RunRTOS();
;#endif
;}
;PCODE: $0000182E VOL: 0
;PCODE: $0000182F VOL: 0
;PCODE: $00001830 VOL: 0
;PCODE: $00001831 VOL: 0

	.DSEG
_0x1E8:
	.BYTE 0xAA
;
;// G_vars are here
;
;void main(void)
; 0000 0018 {

	.CSEG
;PCODE: $00001832 VOL: 0
; 0000 0019 char i;
; 0000 001A char str[7];
; 0000 001B 
; 0000 001C HARDWARE_init();
;PCODE: $00001833 VOL: 0
;	i -> R17
;	str -> Y+0
;PCODE: $00001834 VOL: 0
; 0000 001D SOFTWARE_init();
;PCODE: $00001835 VOL: 0
; 0000 001E 
; 0000 001F #ifdef DEBUG
; 0000 0020     //DDRD.7=1;//PORTD.7=1;  //Led VD2
; 0000 0021     //DDRD.6=1;PORTD.6=1;    //Led VD1
; 0000 0022     USART_SendStrFl(USART_1,start);
;PCODE: $00001836 VOL: 0
;PCODE: $00001837 VOL: 0
;PCODE: $00001838 VOL: 0
;PCODE: $00001839 VOL: 0
;PCODE: $0000183A VOL: 0
; 0000 0023     USART_SendStrFl(SYSTEM_USART,start);
;PCODE: $0000183B VOL: 0
;PCODE: $0000183C VOL: 0
;PCODE: $0000183D VOL: 0
;PCODE: $0000183E VOL: 0
;PCODE: $0000183F VOL: 0
; 0000 0024 #endif
; 0000 0025 
; 0000 0026 
; 0000 0027 //#asm("sei") // Global enable interrupts Upd-1
; 0000 0028 //sprintf(lcd_buf, "Z=%d", SYS_TICK); ;LcdString(1,3); LcdUpdate();
; 0000 0029 RunRTOS();			// Старт ядра.
;PCODE: $00001840 VOL: 0
; 0000 002A 
; 0000 002B //delay_ms(1000);// Запуск фоновых задач.
; 0000 002C SetTask(Task_Start);     //290uS (50/50) and (10/10) но при 1/1 таск 1 лагает
;PCODE: $00001841 VOL: 0
;PCODE: $00001842 VOL: 0
;PCODE: $00001843 VOL: 0
; 0000 002D 
; 0000 002E ///-----------------Upd-7-----------------------------
; 0000 002F // первичный запуск всех задач
; 0000 0030 SetTimerTask(Task_pars_cmd, 25); //Upd-6
;PCODE: $00001844 VOL: 0
;PCODE: $00001845 VOL: 0
;PCODE: $00001846 VOL: 0
;PCODE: $00001847 VOL: 0
;PCODE: $00001848 VOL: 0
; 0000 0031 #ifdef DEBUG                    //Upd-6
; 0000 0032 SetTimerTask(Task_LogOut,50);
;PCODE: $00001849 VOL: 0
;PCODE: $0000184A VOL: 0
;PCODE: $0000184B VOL: 0
;PCODE: $0000184C VOL: 0
;PCODE: $0000184D VOL: 0
; 0000 0033 SetTimerTask(Task_ADC_test,5000);   //Upd-6
;PCODE: $0000184E VOL: 0
;PCODE: $0000184F VOL: 0
;PCODE: $00001850 VOL: 0
;PCODE: $00001851 VOL: 0
;PCODE: $00001852 VOL: 0
; 0000 0034 SetTask(Task_LcdGreetImage);    //Upd-4
;PCODE: $00001853 VOL: 0
;PCODE: $00001854 VOL: 0
;PCODE: $00001855 VOL: 0
; 0000 0035 SetTask(Task_AdcOnLcd);
;PCODE: $00001856 VOL: 0
;PCODE: $00001857 VOL: 0
;PCODE: $00001858 VOL: 0
; 0000 0036 #endif
; 0000 0037 ///---------------------------------------------------
; 0000 0038 
; 0000 0039 
; 0000 003A delay_ms(1000); //?
;PCODE: $00001859 VOL: 0
;PCODE: $0000185A VOL: 0
;PCODE: $0000185B VOL: 0
; 0000 003B while (1)
;PCODE: $0000185C VOL: 0
; 0000 003C  {
; 0000 003D //wdt_reset();	// Сброс собачьего таймера
; 0000 003E TaskManager();	// Вызов диспетчера
;PCODE: $0000185D VOL: 0
; 0000 003F  }
;PCODE: $0000185E VOL: 0
;PCODE: $0000185F VOL: 0
; 0000 0040 } //END MAIN
;PCODE: $00001860 VOL: 0
;PCODE: $00001861 VOL: 0
;PCODE: $00001862 VOL: 0
;PCODE: $00001863 VOL: 0
;
;
;
;// Timer2 interrupt service routine
;interrupt [RTOS_ISR] void timer2_comp_isr(void)//RTOS Interrupt 1mS
; 0000 0046 {
;PCODE: $00001864 VOL: 0
;PCODE: $00001865 VOL: 0
; 0000 0047  TimerService();
;PCODE: $00001866 VOL: 0
; 0000 0048  SYS_TICK++;
;PCODE: $00001867 VOL: 1
;PCODE: $00001868 VOL: 0
;PCODE: $00001869 VOL: 0
;PCODE: $0000186A VOL: 0
; 0000 0049 }
;PCODE: $0000186B VOL: 0
;PCODE: $0000186C VOL: 0
;PCODE: $0000186D VOL: 0
