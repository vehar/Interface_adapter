
;CodeVisionAVR C Compiler V2.05.0 Professional
;(C) Copyright 1998-2010 Pavel Haiduc, HP InfoTech s.r.l.
;http://www.hpinfotech.com

;Chip type                : ATmega128
;Program type             : Application
;Clock frequency          : 16,000000 MHz
;Memory model             : Small
;Optimize for             : Size
;(s)printf features       : int, width
;(s)scanf features        : int, width
;External RAM size        : 0
;Data Stack size          : 256 byte(s)
;Heap size                : 0 byte(s)
;Promote 'char' to 'int'  : No
;'char' is unsigned       : Yes
;8 bit enums              : Yes
;global 'const' stored in FLASH: Yes
;Enhanced core instructions    : On
;Smart register allocation     : On
;Automatic register allocation : Off

	#pragma AVRPART ADMIN PART_NAME ATmega128
	#pragma AVRPART MEMORY PROG_FLASH 131072
	#pragma AVRPART MEMORY EEPROM 4096
	#pragma AVRPART MEMORY INT_SRAM SIZE 4351
	#pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100

	#define CALL_SUPPORTED 1

	.LISTMAC
	.EQU UDRE=0x5
	.EQU RXC=0x7
	.EQU USR=0xB
	.EQU UDR=0xC
	.EQU SPSR=0xE
	.EQU SPDR=0xF
	.EQU EERE=0x0
	.EQU EEWE=0x1
	.EQU EEMWE=0x2
	.EQU EECR=0x1C
	.EQU EEDR=0x1D
	.EQU EEARL=0x1E
	.EQU EEARH=0x1F
	.EQU WDTCR=0x21
	.EQU MCUCR=0x35
	.EQU RAMPZ=0x3B
	.EQU SPL=0x3D
	.EQU SPH=0x3E
	.EQU SREG=0x3F
	.EQU XMCRA=0x6D
	.EQU XMCRB=0x6C

	.DEF R0X0=R0
	.DEF R0X1=R1
	.DEF R0X2=R2
	.DEF R0X3=R3
	.DEF R0X4=R4
	.DEF R0X5=R5
	.DEF R0X6=R6
	.DEF R0X7=R7
	.DEF R0X8=R8
	.DEF R0X9=R9
	.DEF R0XA=R10
	.DEF R0XB=R11
	.DEF R0XC=R12
	.DEF R0XD=R13
	.DEF R0XE=R14
	.DEF R0XF=R15
	.DEF R0X10=R16
	.DEF R0X11=R17
	.DEF R0X12=R18
	.DEF R0X13=R19
	.DEF R0X14=R20
	.DEF R0X15=R21
	.DEF R0X16=R22
	.DEF R0X17=R23
	.DEF R0X18=R24
	.DEF R0X19=R25
	.DEF R0X1A=R26
	.DEF R0X1B=R27
	.DEF R0X1C=R28
	.DEF R0X1D=R29
	.DEF R0X1E=R30
	.DEF R0X1F=R31

	.EQU __SRAM_START=0x0100
	.EQU __SRAM_END=0x10FF
	.EQU __DSTACK_SIZE=0x0100
	.EQU __HEAP_SIZE=0x0000
	.EQU __CLEAR_SRAM_SIZE=__SRAM_END-__SRAM_START+1

	.MACRO __CPD1N
	CPI  R30,LOW(@0)
	LDI  R26,HIGH(@0)
	CPC  R31,R26
	LDI  R26,BYTE3(@0)
	CPC  R22,R26
	LDI  R26,BYTE4(@0)
	CPC  R23,R26
	.ENDM

	.MACRO __CPD2N
	CPI  R26,LOW(@0)
	LDI  R30,HIGH(@0)
	CPC  R27,R30
	LDI  R30,BYTE3(@0)
	CPC  R24,R30
	LDI  R30,BYTE4(@0)
	CPC  R25,R30
	.ENDM

	.MACRO __CPWRR
	CP   R@0,R@2
	CPC  R@1,R@3
	.ENDM

	.MACRO __CPWRN
	CPI  R@0,LOW(@2)
	LDI  R30,HIGH(@2)
	CPC  R@1,R30
	.ENDM

	.MACRO __ADDB1MN
	SUBI R30,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDB2MN
	SUBI R26,LOW(-@0-(@1))
	.ENDM

	.MACRO __ADDW1MN
	SUBI R30,LOW(-@0-(@1))
	SBCI R31,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW2MN
	SUBI R26,LOW(-@0-(@1))
	SBCI R27,HIGH(-@0-(@1))
	.ENDM

	.MACRO __ADDW1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1FN
	SUBI R30,LOW(-2*@0-(@1))
	SBCI R31,HIGH(-2*@0-(@1))
	SBCI R22,BYTE3(-2*@0-(@1))
	.ENDM

	.MACRO __ADDD1N
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	SBCI R22,BYTE3(-@0)
	SBCI R23,BYTE4(-@0)
	.ENDM

	.MACRO __ADDD2N
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	SBCI R24,BYTE3(-@0)
	SBCI R25,BYTE4(-@0)
	.ENDM

	.MACRO __SUBD1N
	SUBI R30,LOW(@0)
	SBCI R31,HIGH(@0)
	SBCI R22,BYTE3(@0)
	SBCI R23,BYTE4(@0)
	.ENDM

	.MACRO __SUBD2N
	SUBI R26,LOW(@0)
	SBCI R27,HIGH(@0)
	SBCI R24,BYTE3(@0)
	SBCI R25,BYTE4(@0)
	.ENDM

	.MACRO __ANDBMNN
	LDS  R30,@0+(@1)
	ANDI R30,LOW(@2)
	STS  @0+(@1),R30
	.ENDM

	.MACRO __ANDWMNN
	LDS  R30,@0+(@1)
	ANDI R30,LOW(@2)
	STS  @0+(@1),R30
	LDS  R30,@0+(@1)+1
	ANDI R30,HIGH(@2)
	STS  @0+(@1)+1,R30
	.ENDM

	.MACRO __ANDD1N
	ANDI R30,LOW(@0)
	ANDI R31,HIGH(@0)
	ANDI R22,BYTE3(@0)
	ANDI R23,BYTE4(@0)
	.ENDM

	.MACRO __ANDD2N
	ANDI R26,LOW(@0)
	ANDI R27,HIGH(@0)
	ANDI R24,BYTE3(@0)
	ANDI R25,BYTE4(@0)
	.ENDM

	.MACRO __ORBMNN
	LDS  R30,@0+(@1)
	ORI  R30,LOW(@2)
	STS  @0+(@1),R30
	.ENDM

	.MACRO __ORWMNN
	LDS  R30,@0+(@1)
	ORI  R30,LOW(@2)
	STS  @0+(@1),R30
	LDS  R30,@0+(@1)+1
	ORI  R30,HIGH(@2)
	STS  @0+(@1)+1,R30
	.ENDM

	.MACRO __ORD1N
	ORI  R30,LOW(@0)
	ORI  R31,HIGH(@0)
	ORI  R22,BYTE3(@0)
	ORI  R23,BYTE4(@0)
	.ENDM

	.MACRO __ORD2N
	ORI  R26,LOW(@0)
	ORI  R27,HIGH(@0)
	ORI  R24,BYTE3(@0)
	ORI  R25,BYTE4(@0)
	.ENDM

	.MACRO __DELAY_USB
	LDI  R24,LOW(@0)
__DELAY_USB_LOOP:
	DEC  R24
	BRNE __DELAY_USB_LOOP
	.ENDM

	.MACRO __DELAY_USW
	LDI  R24,LOW(@0)
	LDI  R25,HIGH(@0)
__DELAY_USW_LOOP:
	SBIW R24,1
	BRNE __DELAY_USW_LOOP
	.ENDM

	.MACRO __GETD1S
	LDD  R30,Y+@0
	LDD  R31,Y+@0+1
	LDD  R22,Y+@0+2
	LDD  R23,Y+@0+3
	.ENDM

	.MACRO __GETD2S
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	LDD  R24,Y+@0+2
	LDD  R25,Y+@0+3
	.ENDM

	.MACRO __PUTD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R31
	STD  Y+@0+2,R22
	STD  Y+@0+3,R23
	.ENDM

	.MACRO __PUTD2S
	STD  Y+@0,R26
	STD  Y+@0+1,R27
	STD  Y+@0+2,R24
	STD  Y+@0+3,R25
	.ENDM

	.MACRO __PUTDZ2
	STD  Z+@0,R26
	STD  Z+@0+1,R27
	STD  Z+@0+2,R24
	STD  Z+@0+3,R25
	.ENDM

	.MACRO __CLRD1S
	STD  Y+@0,R30
	STD  Y+@0+1,R30
	STD  Y+@0+2,R30
	STD  Y+@0+3,R30
	.ENDM

	.MACRO __POINTB1MN
	LDI  R30,LOW(@0+(@1))
	.ENDM

	.MACRO __POINTW1MN
	LDI  R30,LOW(@0+(@1))
	LDI  R31,HIGH(@0+(@1))
	.ENDM

	.MACRO __POINTD1M
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __POINTW1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	.ENDM

	.MACRO __POINTD1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	LDI  R22,BYTE3(2*@0+(@1))
	LDI  R23,BYTE4(2*@0+(@1))
	.ENDM

	.MACRO __POINTB2MN
	LDI  R26,LOW(@0+(@1))
	.ENDM

	.MACRO __POINTW2MN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	.ENDM

	.MACRO __POINTBRM
	LDI  R@0,LOW(@1)
	.ENDM

	.MACRO __POINTWRM
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __POINTBRMN
	LDI  R@0,LOW(@1+(@2))
	.ENDM

	.MACRO __POINTWRMN
	LDI  R@0,LOW(@2+(@3))
	LDI  R@1,HIGH(@2+(@3))
	.ENDM

	.MACRO __POINTWRFN
	LDI  R@0,LOW(@2*2+(@3))
	LDI  R@1,HIGH(@2*2+(@3))
	.ENDM

	.MACRO __GETD1N
	LDI  R30,LOW(@0)
	LDI  R31,HIGH(@0)
	LDI  R22,BYTE3(@0)
	LDI  R23,BYTE4(@0)
	.ENDM

	.MACRO __GETD2N
	LDI  R26,LOW(@0)
	LDI  R27,HIGH(@0)
	LDI  R24,BYTE3(@0)
	LDI  R25,BYTE4(@0)
	.ENDM

	.MACRO __GETB1MN
	LDS  R30,@0+(@1)
	.ENDM

	.MACRO __GETB1HMN
	LDS  R31,@0+(@1)
	.ENDM

	.MACRO __GETW1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	.ENDM

	.MACRO __GETD1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	LDS  R22,@0+(@1)+2
	LDS  R23,@0+(@1)+3
	.ENDM

	.MACRO __GETBRMN
	LDS  R@0,@1+(@2)
	.ENDM

	.MACRO __GETWRMN
	LDS  R@0,@2+(@3)
	LDS  R@1,@2+(@3)+1
	.ENDM

	.MACRO __GETWRZ
	LDD  R@0,Z+@2
	LDD  R@1,Z+@2+1
	.ENDM

	.MACRO __GETD2Z
	LDD  R26,Z+@0
	LDD  R27,Z+@0+1
	LDD  R24,Z+@0+2
	LDD  R25,Z+@0+3
	.ENDM

	.MACRO __GETB2MN
	LDS  R26,@0+(@1)
	.ENDM

	.MACRO __GETW2MN
	LDS  R26,@0+(@1)
	LDS  R27,@0+(@1)+1
	.ENDM

	.MACRO __GETD2MN
	LDS  R26,@0+(@1)
	LDS  R27,@0+(@1)+1
	LDS  R24,@0+(@1)+2
	LDS  R25,@0+(@1)+3
	.ENDM

	.MACRO __PUTB1MN
	STS  @0+(@1),R30
	.ENDM

	.MACRO __PUTW1MN
	STS  @0+(@1),R30
	STS  @0+(@1)+1,R31
	.ENDM

	.MACRO __PUTD1MN
	STS  @0+(@1),R30
	STS  @0+(@1)+1,R31
	STS  @0+(@1)+2,R22
	STS  @0+(@1)+3,R23
	.ENDM

	.MACRO __PUTB1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRB
	.ENDM

	.MACRO __PUTW1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRW
	.ENDM

	.MACRO __PUTD1EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMWRD
	.ENDM

	.MACRO __PUTBR0MN
	STS  @0+(@1),R0
	.ENDM

	.MACRO __PUTBMRN
	STS  @0+(@1),R@2
	.ENDM

	.MACRO __PUTWMRN
	STS  @0+(@1),R@2
	STS  @0+(@1)+1,R@3
	.ENDM

	.MACRO __PUTBZR
	STD  Z+@1,R@0
	.ENDM

	.MACRO __PUTWZR
	STD  Z+@2,R@0
	STD  Z+@2+1,R@1
	.ENDM

	.MACRO __GETW1R
	MOV  R30,R@0
	MOV  R31,R@1
	.ENDM

	.MACRO __GETW2R
	MOV  R26,R@0
	MOV  R27,R@1
	.ENDM

	.MACRO __GETWRN
	LDI  R@0,LOW(@2)
	LDI  R@1,HIGH(@2)
	.ENDM

	.MACRO __PUTW1R
	MOV  R@0,R30
	MOV  R@1,R31
	.ENDM

	.MACRO __PUTW2R
	MOV  R@0,R26
	MOV  R@1,R27
	.ENDM

	.MACRO __ADDWRN
	SUBI R@0,LOW(-@2)
	SBCI R@1,HIGH(-@2)
	.ENDM

	.MACRO __ADDWRR
	ADD  R@0,R@2
	ADC  R@1,R@3
	.ENDM

	.MACRO __SUBWRN
	SUBI R@0,LOW(@2)
	SBCI R@1,HIGH(@2)
	.ENDM

	.MACRO __SUBWRR
	SUB  R@0,R@2
	SBC  R@1,R@3
	.ENDM

	.MACRO __ANDWRN
	ANDI R@0,LOW(@2)
	ANDI R@1,HIGH(@2)
	.ENDM

	.MACRO __ANDWRR
	AND  R@0,R@2
	AND  R@1,R@3
	.ENDM

	.MACRO __ORWRN
	ORI  R@0,LOW(@2)
	ORI  R@1,HIGH(@2)
	.ENDM

	.MACRO __ORWRR
	OR   R@0,R@2
	OR   R@1,R@3
	.ENDM

	.MACRO __EORWRR
	EOR  R@0,R@2
	EOR  R@1,R@3
	.ENDM

	.MACRO __GETWRS
	LDD  R@0,Y+@2
	LDD  R@1,Y+@2+1
	.ENDM

	.MACRO __PUTBSR
	STD  Y+@1,R@0
	.ENDM

	.MACRO __PUTWSR
	STD  Y+@2,R@0
	STD  Y+@2+1,R@1
	.ENDM

	.MACRO __MOVEWRR
	MOV  R@0,R@2
	MOV  R@1,R@3
	.ENDM

	.MACRO __INWR
	IN   R@0,@2
	IN   R@1,@2+1
	.ENDM

	.MACRO __OUTWR
	OUT  @2+1,R@1
	OUT  @2,R@0
	.ENDM

	.MACRO __CALL1MN
	LDS  R30,@0+(@1)
	LDS  R31,@0+(@1)+1
	ICALL
	.ENDM

	.MACRO __CALL1FN
	LDI  R30,LOW(2*@0+(@1))
	LDI  R31,HIGH(2*@0+(@1))
	CALL __GETW1PF
	ICALL
	.ENDM

	.MACRO __CALL2EN
	LDI  R26,LOW(@0+(@1))
	LDI  R27,HIGH(@0+(@1))
	CALL __EEPROMRDW
	ICALL
	.ENDM

	.MACRO __GETW1STACK
	IN   R26,SPL
	IN   R27,SPH
	ADIW R26,@0+1
	LD   R30,X+
	LD   R31,X
	.ENDM

	.MACRO __GETD1STACK
	IN   R26,SPL
	IN   R27,SPH
	ADIW R26,@0+1
	LD   R30,X+
	LD   R31,X+
	LD   R22,X
	.ENDM

	.MACRO __NBST
	BST  R@0,@1
	IN   R30,SREG
	LDI  R31,0x40
	EOR  R30,R31
	OUT  SREG,R30
	.ENDM


	.MACRO __PUTB1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SN
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNS
	LDD  R26,Y+@0
	LDD  R27,Y+@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMN
	LDS  R26,@0
	LDS  R27,@0+1
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1PMNS
	LDS  R26,@0
	LDS  R27,@0+1
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RN
	MOVW R26,R@0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RNS
	MOVW R26,R@0
	ADIW R26,@1
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RNS
	MOVW R26,R@0
	ADIW R26,@1
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RON
	MOV  R26,R@0
	MOV  R27,R@1
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	CALL __PUTDP1
	.ENDM

	.MACRO __PUTB1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X,R30
	.ENDM

	.MACRO __PUTW1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1RONS
	MOV  R26,R@0
	MOV  R27,R@1
	ADIW R26,@2
	CALL __PUTDP1
	.ENDM


	.MACRO __GETB1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R30,Z
	.ENDM

	.MACRO __GETB1HSX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	.ENDM

	.MACRO __GETW1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R31,Z
	MOV  R30,R0
	.ENDM

	.MACRO __GETD1SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R0,Z+
	LD   R1,Z+
	LD   R22,Z+
	LD   R23,Z
	MOVW R30,R0
	.ENDM

	.MACRO __GETB2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R26,X
	.ENDM

	.MACRO __GETW2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	.ENDM

	.MACRO __GETD2SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R1,X+
	LD   R24,X+
	LD   R25,X
	MOVW R26,R0
	.ENDM

	.MACRO __GETBRSX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	LD   R@0,Z
	.ENDM

	.MACRO __GETWRSX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	LD   R@0,Z+
	LD   R@1,Z
	.ENDM

	.MACRO __GETBRSX2
	MOVW R26,R28
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	LD   R@0,X
	.ENDM

	.MACRO __GETWRSX2
	MOVW R26,R28
	SUBI R26,LOW(-@2)
	SBCI R27,HIGH(-@2)
	LD   R@0,X+
	LD   R@1,X
	.ENDM

	.MACRO __LSLW8SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	LD   R31,Z
	CLR  R30
	.ENDM

	.MACRO __PUTB1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __CLRW1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __CLRD1SX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	ST   X+,R30
	ST   X+,R30
	ST   X+,R30
	ST   X,R30
	.ENDM

	.MACRO __PUTB2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z,R26
	.ENDM

	.MACRO __PUTW2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z,R27
	.ENDM

	.MACRO __PUTD2SX
	MOVW R30,R28
	SUBI R30,LOW(-@0)
	SBCI R31,HIGH(-@0)
	ST   Z+,R26
	ST   Z+,R27
	ST   Z+,R24
	ST   Z,R25
	.ENDM

	.MACRO __PUTBSRX
	MOVW R30,R28
	SUBI R30,LOW(-@1)
	SBCI R31,HIGH(-@1)
	ST   Z,R@0
	.ENDM

	.MACRO __PUTWSRX
	MOVW R30,R28
	SUBI R30,LOW(-@2)
	SBCI R31,HIGH(-@2)
	ST   Z+,R@0
	ST   Z,R@1
	.ENDM

	.MACRO __PUTB1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X,R30
	.ENDM

	.MACRO __PUTW1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X,R31
	.ENDM

	.MACRO __PUTD1SNX
	MOVW R26,R28
	SUBI R26,LOW(-@0)
	SBCI R27,HIGH(-@0)
	LD   R0,X+
	LD   R27,X
	MOV  R26,R0
	SUBI R26,LOW(-@1)
	SBCI R27,HIGH(-@1)
	ST   X+,R30
	ST   X+,R31
	ST   X+,R22
	ST   X,R23
	.ENDM

	.MACRO __MULBRR
	MULS R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRRU
	MUL  R@0,R@1
	MOVW R30,R0
	.ENDM

	.MACRO __MULBRR0
	MULS R@0,R@1
	.ENDM

	.MACRO __MULBRRU0
	MUL  R@0,R@1
	.ENDM

	.MACRO __MULBNWRU
	LDI  R26,@2
	MUL  R26,R@0
	MOVW R30,R0
	MUL  R26,R@1
	ADD  R31,R0
	.ENDM

	.CSEG
	.ORG 0x00

;START OF CODE MARKER
__START_OF_CODE:

;INTERRUPT VECTORS
	JMP  __RESET
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer2_comp_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _timer1_ovf_isr
	JMP  _timer0_comp_isr
	JMP  _timer0_ovf_isr
	JMP  _spi_isr
	JMP  _usart0_rxc
	JMP  _usart0_dre_my
	JMP  0x00
	JMP  _adc_isr
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  0x00
	JMP  _usart1_rxc
	JMP  _usart1_dre_my
	JMP  0x00
	JMP  _twi_isr
	JMP  0x00

_Help:
	.DB  0x48,0x65,0x6C,0x70,0x0
_Set:
	.DB  0x53,0x65,0x74,0x0
_Uart:
	.DB  0x55,0x61,0x72,0x74,0x0
_Mode:
	.DB  0x4D,0x6F,0x64,0x65,0x0
_Speed:
	.DB  0x53,0x70,0x65,0x65,0x64,0x0
_Spi:
	.DB  0x53,0x70,0x69,0x0
_Prescaller:
	.DB  0x50,0x72,0x65,0x73,0x63,0x0
_PhaPol:
	.DB  0x70,0x70,0x0
_I2c:
	.DB  0x49,0x32,0x63,0x0
_W:
	.DB  0x57,0x0
_reset:
	.DB  0x72,0x73,0x74,0x0
_boot:
	.DB  0x62,0x6F,0x6F,0x74,0x0
_dbg:
	.DB  0x64,0x62,0x67,0x0
_error:
	.DB  0x20,0x45,0xD,0x0
_ok:
	.DB  0x20,0x6F,0x6B,0xD,0x0
_largeValue:
	.DB  0x20,0x4C,0x61,0x72,0x67,0x65,0x5F,0x76
	.DB  0x61,0x6C,0x75,0x65,0xD,0x0
_wrongValue:
	.DB  0x20,0x57,0x72,0x6F,0x6E,0x67,0x5F,0x76
	.DB  0x61,0x6C,0x75,0x65,0xD,0x0
_start:
	.DB  0x20,0x53,0x0
_help_mess_0:
	.DB  0xD,0x3E,0x3E,0x3E,0x20,0x48,0x45,0x4C
	.DB  0x50,0x20,0x3C,0x3C,0x3C,0xD,0x20,0x43
	.DB  0x6F,0x6D,0x6D,0x61,0x6E,0x64,0x73,0x3A
	.DB  0xD,0x0
_help_mess_1:
	.DB  0xD,0x20,0x53,0x65,0x74,0x20,0x2D,0x49
	.DB  0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65
	.DB  0x5F,0x6E,0x61,0x6D,0x65,0x2D,0x20,0x2D
	.DB  0x6E,0x75,0x6D,0x62,0x65,0x72,0x2D,0x20
	.DB  0x4D,0x6F,0x64,0x65,0x20,0x2D,0x76,0x61
	.DB  0x6C,0x75,0x65,0x28,0x6F,0x70,0x74,0x69
	.DB  0x6F,0x6E,0x61,0x6C,0x29,0x2D,0x20,0x53
	.DB  0x70,0x65,0x65,0x64,0x20,0x2D,0x76,0x61
	.DB  0x6C,0x75,0x65,0x28,0x6F,0x70,0x74,0x69
	.DB  0x6F,0x6E,0x61,0x6C,0x29,0x2D,0x0
_help_mess_2:
	.DB  0xD,0x20,0x57,0x20,0x20,0x20,0x2D,0x49
	.DB  0x6E,0x74,0x65,0x72,0x66,0x61,0x63,0x65
	.DB  0x5F,0x6E,0x61,0x6D,0x65,0x2D,0x20,0x2D
	.DB  0x6E,0x75,0x6D,0x62,0x65,0x72,0x2D,0x20
	.DB  0x2D,0x64,0x61,0x74,0x61,0x2D,0x0
_help_mess_3:
	.DB  0xD,0x20,0x47,0x65,0x74,0x20,0x2D,0x65
	.DB  0x6E,0x74,0x69,0x74,0x79,0x2D,0x0
_help_mess_4:
	.DB  0xD,0x20,0x20,0x49,0x6E,0x74,0x65,0x72
	.DB  0x66,0x61,0x63,0x65,0x73,0x20,0x61,0x76
	.DB  0x61,0x69,0x6C,0x61,0x62,0x6C,0x65,0x3A
	.DB  0xD,0x20,0x20,0x20,0x55,0x61,0x72,0x74
	.DB  0x28,0x30,0x2C,0x31,0x29,0xD,0x20,0x20
	.DB  0x20,0x53,0x70,0x69,0x28,0x30,0x2D,0x48
	.DB  0x61,0x72,0x64,0x2C,0x20,0x31,0x2D,0x53
	.DB  0x6F,0x66,0x74,0x29,0xD,0x0
_help_Uart_0:
	.DB  0xD,0x3E,0x3E,0x3E,0x20,0x55,0x41,0x52
	.DB  0x54,0x5F,0x48,0x45,0x4C,0x50,0x20,0x3C
	.DB  0x3C,0x3C,0xD,0x20,0x4D,0x6F,0x64,0x65
	.DB  0x3A,0x20,0x30,0x2D,0x20,0x4E,0x4F,0x52
	.DB  0x4D,0x41,0x4C,0x3B,0x20,0x31,0x2D,0x20
	.DB  0x44,0x4F,0x55,0x42,0x4C,0x45,0x44,0x20
	.DB  0x73,0x70,0x65,0x65,0x64,0x0
_help_Uart_1:
	.DB  0xD,0x20,0x53,0x70,0x65,0x65,0x64,0x3A
	.DB  0x20,0x62,0x61,0x75,0x64,0x2F,0x31,0x30
	.DB  0x30,0x20,0x28,0x45,0x78,0x3A,0x20,0x35
	.DB  0x37,0x36,0x20,0x69,0x73,0x20,0x35,0x37
	.DB  0x36,0x30,0x30,0x29,0xD,0x0
_help_Spi_0:
	.DB  0xD,0x3E,0x3E,0x3E,0x20,0x53,0x50,0x49
	.DB  0x5F,0x48,0x45,0x4C,0x50,0x20,0x3C,0x3C
	.DB  0x3C,0xD,0x20,0x4D,0x6F,0x64,0x65,0x3A
	.DB  0x20,0x30,0x2D,0x20,0x53,0x4C,0x41,0x56
	.DB  0x45,0x3B,0x20,0x31,0x2D,0x20,0x4D,0x41
	.DB  0x53,0x54,0x45,0x52,0xA,0x0
_help_Spi_1:
	.DB  0xD,0x20,0x50,0x72,0x65,0x73,0x63,0x61
	.DB  0x6C,0x6C,0x65,0x72,0x3A,0x20,0x70,0x6F
	.DB  0x77,0x20,0x6F,0x66,0x20,0x32,0x20,0x28
	.DB  0x45,0x78,0x3A,0x20,0x50,0x72,0x65,0x73
	.DB  0x63,0x20,0x31,0x36,0x29,0xD,0x0
_table:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5F
	.DB  0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x14
	.DB  0x7F,0x14,0x7F,0x14,0x24,0x2A,0x7F,0x2A
	.DB  0x12,0x23,0x13,0x8,0x64,0x62,0x36,0x49
	.DB  0x55,0x22,0x50,0x0,0x5,0x3,0x0,0x0
	.DB  0x0,0x1C,0x22,0x41,0x0,0x0,0x41,0x22
	.DB  0x1C,0x0,0x14,0x8,0x3E,0x8,0x14,0x8
	.DB  0x8,0x3E,0x8,0x8,0x0,0x50,0x30,0x0
	.DB  0x0,0x8,0x8,0x8,0x8,0x8,0x0,0x60
	.DB  0x60,0x0,0x0,0x20,0x10,0x8,0x4,0x2
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5F
	.DB  0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x14
	.DB  0x7F,0x14,0x7F,0x14,0x24,0x2A,0x7F,0x2A
	.DB  0x12,0x23,0x13,0x8,0x64,0x62,0x36,0x49
	.DB  0x55,0x22,0x50,0x0,0x5,0x3,0x0,0x0
	.DB  0x0,0x1C,0x22,0x41,0x0,0x0,0x41,0x22
	.DB  0x1C,0x0,0x14,0x8,0x3E,0x8,0x14,0x8
	.DB  0x8,0x3E,0x8,0x8,0x0,0x50,0x30,0x0
	.DB  0x0,0x8,0x8,0x8,0x8,0x8,0x0,0x60
	.DB  0x60,0x0,0x0,0x20,0x10,0x8,0x4,0x2
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5F
	.DB  0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x14
	.DB  0x7F,0x14,0x7F,0x14,0x24,0x2A,0x7F,0x2A
	.DB  0x12,0x23,0x13,0x8,0x64,0x62,0x36,0x49
	.DB  0x55,0x22,0x50,0x0,0x5,0x3,0x0,0x0
	.DB  0x0,0x1C,0x22,0x41,0x0,0x0,0x41,0x22
	.DB  0x1C,0x0,0x14,0x8,0x3E,0x8,0x14,0x8
	.DB  0x8,0x3E,0x8,0x8,0x0,0x50,0x30,0x0
	.DB  0x0,0x8,0x8,0x8,0x8,0x8,0x0,0x60
	.DB  0x60,0x0,0x0,0x20,0x10,0x8,0x4,0x2
	.DB  0x3E,0x51,0x49,0x45,0x3E,0x0,0x42,0x7F
	.DB  0x40,0x0,0x42,0x61,0x51,0x49,0x46,0x21
	.DB  0x41,0x45,0x4B,0x31,0x18,0x14,0x12,0x7F
	.DB  0x10,0x27,0x45,0x45,0x45,0x39,0x3C,0x4A
	.DB  0x49,0x49,0x30,0x1,0x71,0x9,0x5,0x3
	.DB  0x36,0x49,0x49,0x49,0x36,0x6,0x49,0x49
	.DB  0x29,0x1E,0x0,0x36,0x36,0x0,0x0,0x0
	.DB  0x56,0x36,0x0,0x0,0x8,0x14,0x22,0x41
	.DB  0x0,0x14,0x14,0x14,0x14,0x14,0x0,0x41
	.DB  0x22,0x14,0x8,0x2,0x1,0x51,0x9,0x6
	.DB  0x32,0x49,0x79,0x41,0x3E,0x7E,0x11,0x11
	.DB  0x11,0x7E,0x7F,0x49,0x49,0x49,0x36,0x3E
	.DB  0x41,0x41,0x41,0x22,0x7F,0x41,0x41,0x22
	.DB  0x1C,0x7F,0x49,0x49,0x49,0x41,0x7F,0x9
	.DB  0x9,0x9,0x1,0x3E,0x41,0x49,0x49,0x7A
	.DB  0x7F,0x8,0x8,0x8,0x7F,0x0,0x41,0x7F
	.DB  0x41,0x0,0x20,0x40,0x41,0x3F,0x1,0x7F
	.DB  0x8,0x14,0x22,0x41,0x7F,0x40,0x40,0x40
	.DB  0x40,0x7F,0x2,0xC,0x2,0x7F,0x7F,0x4
	.DB  0x8,0x10,0x7F,0x3E,0x41,0x41,0x41,0x3E
	.DB  0x7F,0x9,0x9,0x9,0x6,0x3E,0x41,0x51
	.DB  0x21,0x5E,0x7F,0x9,0x19,0x29,0x46,0x46
	.DB  0x49,0x49,0x49,0x31,0x1,0x1,0x7F,0x1
	.DB  0x1,0x3F,0x40,0x40,0x40,0x3F,0x1F,0x20
	.DB  0x40,0x20,0x1F,0x3F,0x40,0x38,0x40,0x3F
	.DB  0x63,0x14,0x8,0x14,0x63,0x7,0x8,0x70
	.DB  0x8,0x7,0x61,0x51,0x49,0x45,0x43,0x0
	.DB  0x7F,0x41,0x41,0x0,0x2,0x4,0x8,0x10
	.DB  0x20,0x0,0x41,0x41,0x7F,0x0,0x4,0x2
	.DB  0x1,0x2,0x4,0x40,0x40,0x40,0x40,0x40
	.DB  0x0,0x1,0x2,0x4,0x0,0x20,0x54,0x54
	.DB  0x54,0x78,0x7F,0x48,0x44,0x44,0x38,0x38
	.DB  0x44,0x44,0x44,0x20,0x38,0x44,0x44,0x48
	.DB  0x7F,0x38,0x54,0x54,0x54,0x18,0x8,0x7E
	.DB  0x9,0x1,0x2,0xC,0x52,0x52,0x52,0x3E
	.DB  0x7F,0x8,0x4,0x4,0x78,0x0,0x44,0x7D
	.DB  0x40,0x0,0x20,0x40,0x44,0x3D,0x0,0x7F
	.DB  0x10,0x28,0x44,0x0,0x0,0x41,0x7F,0x40
	.DB  0x0,0x7C,0x4,0x18,0x4,0x78,0x7C,0x8
	.DB  0x4,0x4,0x78,0x38,0x44,0x44,0x44,0x38
	.DB  0x7C,0x14,0x14,0x14,0x8,0x8,0x14,0x14
	.DB  0x18,0x7C,0x7C,0x8,0x4,0x4,0x8,0x48
	.DB  0x54,0x54,0x54,0x20,0x4,0x3F,0x44,0x40
	.DB  0x20,0x3C,0x40,0x40,0x20,0x7C,0x1C,0x20
	.DB  0x40,0x20,0x1C,0x3C,0x40,0x30,0x40,0x3C
	.DB  0x44,0x28,0x10,0x28,0x44,0xC,0x50,0x50
	.DB  0x50,0x3C,0x44,0x64,0x54,0x4C,0x44,0x0
	.DB  0x8,0x36,0x41,0x0,0x0,0x0,0x7F,0x0
	.DB  0x0,0x0,0x41,0x36,0x8,0x0,0x10,0x8
	.DB  0x8,0x10,0x8,0x78,0x46,0x41,0x46,0x78
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5F
	.DB  0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x14
	.DB  0x7F,0x14,0x7F,0x14,0x24,0x2A,0x7F,0x2A
	.DB  0x12,0x23,0x13,0x8,0x64,0x62,0x36,0x49
	.DB  0x55,0x22,0x50,0x0,0x5,0x3,0x0,0x0
	.DB  0x0,0x1C,0x22,0x41,0x0,0x0,0x41,0x22
	.DB  0x1C,0x0,0x14,0x8,0x3E,0x8,0x14,0x8
	.DB  0x8,0x3E,0x8,0x8,0x0,0x50,0x30,0x0
	.DB  0x0,0x8,0x8,0x8,0x8,0x8,0x0,0x60
	.DB  0x60,0x0,0x0,0x20,0x10,0x8,0x4,0x2
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5F
	.DB  0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x14
	.DB  0x7F,0x14,0x7F,0x14,0x24,0x2A,0x7F,0x2A
	.DB  0x12,0x23,0x13,0x8,0x64,0x62,0x36,0x49
	.DB  0x55,0x22,0x50,0x0,0x5,0x3,0x0,0x0
	.DB  0x0,0x1C,0x22,0x41,0x0,0x0,0x41,0x22
	.DB  0x1C,0x0,0x14,0x8,0x3E,0x8,0x14,0x8
	.DB  0x8,0x3E,0x8,0x8,0x0,0x50,0x30,0x0
	.DB  0x0,0x8,0x8,0x8,0x8,0x8,0x0,0x60
	.DB  0x60,0x0,0x0,0x20,0x10,0x8,0x4,0x2
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5F
	.DB  0x0,0x0,0x0,0x7,0x0,0x7,0x0,0x14
	.DB  0x7F,0x14,0x7F,0x14,0x24,0x2A,0x7F,0x2A
	.DB  0x12,0x23,0x13,0x8,0x64,0x62,0x36,0x49
	.DB  0x55,0x22,0x50,0x0,0x5,0x3,0x0,0x0
	.DB  0x0,0x1C,0x22,0x41,0x0,0x0,0x41,0x22
	.DB  0x1C,0x0,0x14,0x8,0x3E,0x8,0x14,0x8
	.DB  0x8,0x3E,0x8,0x8,0x0,0x50,0x30,0x0
	.DB  0x0,0x8,0x8,0x8,0x8,0x8,0x0,0x60
	.DB  0x60,0x0,0x0,0x20,0x10,0x8,0x4,0x2
	.DB  0x3E,0x51,0x49,0x45,0x3E,0x0,0x42,0x7F
	.DB  0x40,0x0,0x42,0x61,0x51,0x49,0x46,0x21
	.DB  0x41,0x45,0x4B,0x31,0x18,0x14,0x12,0x7F
	.DB  0x10,0x27,0x45,0x45,0x45,0x39,0x3C,0x4A
	.DB  0x49,0x49,0x30,0x1,0x71,0x9,0x5,0x3
	.DB  0x36,0x49,0x49,0x49,0x36,0x6,0x49,0x49
	.DB  0x29,0x1E,0x0,0x36,0x36,0x0,0x0,0x0
	.DB  0x56,0x36,0x0,0x0,0x8,0x14,0x22,0x41
	.DB  0x0,0x14,0x14,0x14,0x14,0x14,0x0,0x41
	.DB  0x22,0x14,0x8,0x2,0x1,0x51,0x9,0x6
	.DB  0x7E,0x11,0x11,0x11,0x7E,0x7F,0x49,0x49
	.DB  0x49,0x31,0x7F,0x49,0x49,0x49,0x36,0x7F
	.DB  0x1,0x1,0x1,0x3,0x70,0x29,0x27,0x21
	.DB  0x7F,0x7F,0x49,0x49,0x49,0x41,0x77,0x8
	.DB  0x7F,0x8,0x77,0x41,0x41,0x41,0x49,0x76
	.DB  0x7F,0x10,0x8,0x4,0x7F,0x7F,0x10,0x9
	.DB  0x4,0x7F,0x7F,0x8,0x14,0x22,0x41,0x20
	.DB  0x41,0x3F,0x1,0x7F,0x7F,0x2,0xC,0x2
	.DB  0x7F,0x7F,0x8,0x8,0x8,0x7F,0x3E,0x41
	.DB  0x41,0x41,0x3E,0x7F,0x1,0x1,0x1,0x7F
	.DB  0x7F,0x9,0x9,0x9,0x6,0x3E,0x41,0x41
	.DB  0x41,0x22,0x1,0x1,0x7F,0x1,0x1,0x47
	.DB  0x28,0x10,0x8,0x7,0x1E,0x21,0x7F,0x21
	.DB  0x1E,0x63,0x14,0x8,0x14,0x63,0x3F,0x20
	.DB  0x20,0x20,0x5F,0x7,0x8,0x8,0x8,0x7F
	.DB  0x7F,0x40,0x7F,0x40,0x7F,0x3F,0x20,0x3F
	.DB  0x20,0x5F,0x1,0x7F,0x48,0x48,0x30,0x7F
	.DB  0x48,0x30,0x0,0x7F,0x0,0x7F,0x48,0x48
	.DB  0x30,0x41,0x41,0x41,0x49,0x3E,0x7F,0x8
	.DB  0x3E,0x41,0x3E,0x46,0x29,0x19,0x9,0x7F
	.DB  0x20,0x54,0x54,0x54,0x78,0x3C,0x4A,0x4A
	.DB  0x49,0x31,0x7C,0x54,0x54,0x28,0x0,0x7C
	.DB  0x4,0x4,0x4,0xC,0x72,0x2A,0x26,0x22
	.DB  0x7E,0x38,0x54,0x54,0x54,0x18,0x6C,0x10
	.DB  0x7C,0x10,0x6C,0x44,0x44,0x54,0x54,0x38
	.DB  0x7C,0x20,0x10,0x8,0x7C,0x7C,0x21,0x12
	.DB  0x9,0x7C,0x7C,0x10,0x28,0x44,0x0,0x20
	.DB  0x44,0x3C,0x4,0x7C,0x7C,0x8,0x10,0x8
	.DB  0x7C,0x7C,0x10,0x10,0x10,0x7C,0x38,0x44
	.DB  0x44,0x44,0x38,0x7C,0x4,0x4,0x4,0x7C
	.DB  0x7C,0x14,0x14,0x14,0x8,0x38,0x44,0x44
	.DB  0x44,0x20,0x4,0x4,0x7C,0x4,0x4,0x44
	.DB  0x28,0x10,0x8,0x4,0x8,0x14,0x7E,0x14
	.DB  0x8,0x44,0x28,0x10,0x28,0x44,0x3C,0x40
	.DB  0x40,0x7C,0x40,0xC,0x10,0x10,0x10,0x7C
	.DB  0x7C,0x40,0x7C,0x40,0x7C,0x3C,0x20,0x3C
	.DB  0x20,0x7C,0x4,0x7C,0x50,0x50,0x20,0x7C
	.DB  0x50,0x20,0x0,0x7C,0x0,0x7C,0x50,0x50
	.DB  0x20,0x28,0x44,0x44,0x54,0x38,0x7C,0x10
	.DB  0x38,0x44,0x38,0x48,0x54,0x34,0x14,0x7C
_rad2Image:
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x80,0xC0,0xE0,0xF0
	.DB  0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF
	.DB  0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x80,0xC0,0xE0
	.DB  0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE
	.DB  0xFC,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0xE0,0xF8,0xFE,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0
	.DB  0xE0,0x40,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x40,0xE0,0xF0,0xF8,0xFC,0xFE
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x78,0x7F
	.DB  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F
	.DB  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F
	.DB  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F
	.DB  0xF,0x3,0x1,0xF0,0xF8,0xFC,0xFC,0xFE
	.DB  0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8
	.DB  0xF0,0x1,0x3,0xF,0x7F,0x7F,0x7F,0x7F
	.DB  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F
	.DB  0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F
	.DB  0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x80,0xC0,0xE1
	.DB  0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F
	.DB  0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0
	.DB  0xE0,0xC0,0x80,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
	.DB  0x0,0x0,0x0,0x0,0x70,0x88,0x70,0x50
	.DB  0x88,0x70,0x0,0xC8,0xA8,0x90,0x0,0x70
	.DB  0x88,0x70,0x0,0x10,0xF8,0x0,0x70,0x88
	.DB  0x70,0x0,0xC,0xE,0x1F,0x1F,0x1F,0x3F
	.DB  0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
	.DB  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F
	.DB  0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F
	.DB  0xE,0xC,0x0,0x0,0x0,0xF0,0x28,0xF0
	.DB  0x0,0xF8,0x20,0xF8,0x0,0xF8,0xA8,0x88
	.DB  0x0,0x88,0xF8,0x88,0x0,0xF8,0x48,0xB0
_tbl10_G101:
	.DB  0x10,0x27,0xE8,0x3,0x64,0x0,0xA,0x0
	.DB  0x1,0x0
_tbl16_G101:
	.DB  0x0,0x10,0x0,0x1,0x10,0x0,0x1,0x0

;REGISTER BIT VARIABLES INITIALIZATION
__REG_BIT_VARS:
	.DW  0x0001

_0xD:
	.DB  0x3
_0xE:
	.DB  0x3
_0xF:
	.DB  0x46
_0x10:
	.DB  0x2
_0xA0:
	.DB  0xC,0x0,0x1,0x80,0x1,0xC0,0x1,0xE0
	.DB  0x1,0xF0,0x2,0xF8,0x2,0xFC,0x2,0xFE
	.DB  0x2,0xFF,0x1,0xFE,0x1,0xFC,0x1,0xF8
	.DB  0x1,0xF0,0x1,0xE0,0x1,0xC0,0x1,0x80
	.DB  0x16,0x0,0x1,0x80,0x1,0xC0,0x1,0xE0
	.DB  0x1,0xF0,0x1,0xF8,0x1,0xFC,0x1,0xFE
	.DB  0x2,0xFF,0x3,0xFE,0x1,0xFC,0x2,0xF8
	.DB  0x1,0xF0,0x1,0xE0,0x1,0xC0,0x1,0x80
	.DB  0x14,0x0,0x1,0xE0,0x1,0xF8,0x1,0xFE
	.DB  0x15,0xFF,0x1,0xFE,0x1,0xFC,0x1,0xF8
	.DB  0x1,0xF0,0x1,0xE0,0x1,0x40,0x8,0x0
	.DB  0x1,0x40,0x1,0xE0,0x1,0xF0,0x1,0xF8
	.DB  0x1,0xFC,0x1,0xFE,0x15,0xFF,0x1,0xFE
	.DB  0x1,0xF8,0x1,0xE0,0xE,0x0,0x1,0x78
	.DB  0x19,0x7F,0x1,0xF,0x1,0x3,0x1,0x1
	.DB  0x1,0xF0,0x1,0xF8,0x2,0xFC,0x6,0xFE
	.DB  0x2,0xFC,0x1,0xF8,0x1,0xF0,0x1,0x1
	.DB  0x1,0x3,0x1,0xF,0x19,0x7F,0x1,0x78
	.DB  0x27,0x0,0x1,0x80,0x1,0xC0,0x1,0xE1
	.DB  0x1,0xE3,0x1,0xE7,0x1,0xC7,0x1,0xCF
	.DB  0x4,0x8F,0x1,0xCF,0x1,0xC7,0x1,0xE7
	.DB  0x1,0xE3,0x1,0xE1,0x1,0xC0,0x1,0x80
	.DB  0x3A,0x0,0x1,0x80,0x1,0xC0,0x1,0xE0
	.DB  0x1,0xF0,0x1,0xF8,0x1,0xFC,0x1,0xFE
	.DB  0x14,0xFF,0x1,0xFE,0x1,0xFC,0x1,0xF8
	.DB  0x1,0xF0,0x1,0xE0,0x1,0xC0,0x1,0x80
	.DB  0x2F,0x0,0x1,0xC,0x1,0xE,0x3,0x1F
	.DB  0x4,0x3F,0x3,0x7F,0x10,0xFF,0x3,0x7F
	.DB  0x4,0x3F,0x3,0x1F,0x1,0xE,0x1,0xC
	.DB  0x16
_0x14E:
	.DB  0xC8
_0x178:
	.DB  LOW(_DoNothing),HIGH(_DoNothing)
_0x179:
	.DB  LOW(_DoNothing),HIGH(_DoNothing)
_0x17A:
	.DB  LOW(_DoNothing),HIGH(_DoNothing)
_0x0:
	.DB  0x70,0x6F,0x72,0x66,0x0,0x65,0x78,0x74
	.DB  0x72,0x66,0x0,0x62,0x6F,0x72,0x66,0x0
	.DB  0x77,0x64,0x72,0x66,0x0,0x4A,0x54,0x52
	.DB  0x46,0x0,0xD,0x3C,0x52,0x41,0x4D,0x3E
	.DB  0x0,0xD,0x55,0x41,0x52,0x54,0x5F,0x53
	.DB  0x45,0x54,0x54,0x49,0x4E,0x47,0x53,0xD
	.DB  0x0,0x55,0x41,0x52,0x54,0x20,0x0,0xD
	.DB  0x20,0x4D,0x6F,0x64,0x65,0x20,0x0,0xD
	.DB  0x20,0x53,0x70,0x65,0x65,0x64,0x20,0x0
	.DB  0xD,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D,0x2D
	.DB  0x2D,0xD,0x0,0xD,0x53,0x50,0x49,0x5F
	.DB  0x53,0x45,0x54,0x54,0x49,0x4E,0x47,0x53
	.DB  0xD,0x0,0x53,0x50,0x49,0x20,0x0,0xD
	.DB  0x20,0x50,0x72,0x65,0x73,0x63,0x61,0x6C
	.DB  0x6C,0x65,0x72,0x20,0x0,0xD,0x3C,0x45
	.DB  0x45,0x50,0x52,0x4F,0x4D,0x3E,0x0,0xD
	.DB  0x42,0x75,0x74,0x65,0x73,0x5F,0x52,0x58
	.DB  0x20,0x0,0xD,0x42,0x75,0x74,0x65,0x73
	.DB  0x5F,0x54,0x58,0x20,0x0,0x54,0x69,0x63
	.DB  0x6B,0x3D,0x25,0x69,0xA,0x0,0x4F,0x6C
	.DB  0x6F,0x6C,0x6F,0x3D,0x29,0x0,0xD,0x20
	.DB  0x45,0x52,0x52,0x5F,0x55,0x4E,0x44,0x45
	.DB  0x46,0x5F,0x46,0x4C,0x41,0x47,0x20,0x0
	.DB  0xD,0x20,0x53,0x65,0x74,0x0,0xD,0x20
	.DB  0x55,0x61,0x72,0x74,0x0,0xD,0x20,0x4E
	.DB  0x75,0x6D,0x0,0xD,0x20,0x4D,0x6F,0x64
	.DB  0x65,0x0,0xD,0x4D,0x20,0x45,0x58,0x49
	.DB  0x54,0x0,0xD,0x20,0x0,0xD,0x20,0x55
	.DB  0x61,0x72,0x74,0x5F,0x69,0x6E,0x69,0x74
	.DB  0x0,0xD,0x20,0x53,0x70,0x69,0x0,0xD
	.DB  0x53,0x20,0x4E,0x75,0x6D,0x0,0xD,0x53
	.DB  0x20,0x4D,0x6F,0x64,0x65,0x2D,0x0,0xD
	.DB  0x53,0x20,0x50,0x72,0x65,0x73,0x63,0x2D
	.DB  0x0,0xD,0x53,0x20,0x50,0x68,0x61,0x50
	.DB  0x6F,0x6C,0x2D,0x0,0xD,0x53,0x20,0x53
	.DB  0x70,0x69,0x49,0x6E,0x69,0x74,0x0,0xD
	.DB  0x20,0x49,0x32,0x63,0x0,0xD,0x20,0x49
	.DB  0x32,0x63,0x5F,0x69,0x6E,0x69,0x74,0x0
	.DB  0xD,0x20,0x57,0x0,0xD,0x20,0x55,0x20
	.DB  0x44,0x3E,0x54,0x58,0x20,0x0,0xD,0x20
	.DB  0x53,0x20,0x44,0x3E,0x54,0x58,0x20,0x0
	.DB  0xD,0x20,0x53,0x20,0x44,0x3C,0x52,0x58
	.DB  0x20,0x0,0xD,0x20,0x49,0x32,0x43,0x20
	.DB  0x44,0x3E,0x54,0x58,0x20,0x0,0xD,0x20
	.DB  0x49,0x32,0x43,0x20,0x44,0x3C,0x52,0x58
	.DB  0x20,0x0,0x79,0x0,0x6E,0x0,0x61,0x0
	.DB  0x73,0x0,0x45,0x0
_0x20003:
	.DB  0x1
_0x20004:
	.DB  0xE8,0x3
_0x20000:
	.DB  0x25,0xD,0x0,0xD,0xA,0x3C,0x0,0x2C
	.DB  0x0,0x3E,0x0,0xD,0xA,0x0,0x3E,0xD
	.DB  0xA,0x0
_0x2060060:
	.DB  0x1
_0x2060000:
	.DB  0x2D,0x4E,0x41,0x4E,0x0,0x49,0x4E,0x46
	.DB  0x0

__GLOBAL_INI_TBL:
	.DW  0x01
	.DW  0x02
	.DW  __REG_BIT_VARS*2

	.DW  0x01
	.DW  _temp_control
	.DW  _0xD*2

	.DW  0x01
	.DW  _bias
	.DW  _0xE*2

	.DW  0x01
	.DW  _Vop
	.DW  _0xF*2

	.DW  0x01
	.DW  _disp_config
	.DW  _0x10*2

	.DW  0x01
	.DW  _d
	.DW  _0x14E*2

	.DW  0x02
	.DW  _MasterOutFunc
	.DW  _0x178*2

	.DW  0x02
	.DW  _SlaveOutFunc
	.DW  _0x179*2

	.DW  0x02
	.DW  _ErrorOutFunc
	.DW  _0x17A*2

	.DW  0x05
	.DW  _0x1C2
	.DW  _0x0*2

	.DW  0x06
	.DW  _0x1C2+5
	.DW  _0x0*2+5

	.DW  0x05
	.DW  _0x1C2+11
	.DW  _0x0*2+11

	.DW  0x05
	.DW  _0x1C2+16
	.DW  _0x0*2+16

	.DW  0x05
	.DW  _0x1C2+21
	.DW  _0x0*2+21

	.DW  0x07
	.DW  _0x1CB
	.DW  _0x0*2+26

	.DW  0x10
	.DW  _0x1CB+7
	.DW  _0x0*2+33

	.DW  0x06
	.DW  _0x1CB+23
	.DW  _0x0*2+49

	.DW  0x08
	.DW  _0x1CB+29
	.DW  _0x0*2+55

	.DW  0x09
	.DW  _0x1CB+37
	.DW  _0x0*2+63

	.DW  0x0B
	.DW  _0x1CB+46
	.DW  _0x0*2+72

	.DW  0x0F
	.DW  _0x1CB+57
	.DW  _0x0*2+83

	.DW  0x05
	.DW  _0x1CB+72
	.DW  _0x0*2+98

	.DW  0x08
	.DW  _0x1CB+77
	.DW  _0x0*2+55

	.DW  0x0E
	.DW  _0x1CB+85
	.DW  _0x0*2+103

	.DW  0x0B
	.DW  _0x1CB+99
	.DW  _0x0*2+72

	.DW  0x0A
	.DW  _0x1D2
	.DW  _0x0*2+117

	.DW  0x10
	.DW  _0x1D2+10
	.DW  _0x0*2+33

	.DW  0x06
	.DW  _0x1D2+26
	.DW  _0x0*2+49

	.DW  0x08
	.DW  _0x1D2+32
	.DW  _0x0*2+55

	.DW  0x09
	.DW  _0x1D2+40
	.DW  _0x0*2+63

	.DW  0x0B
	.DW  _0x1D2+49
	.DW  _0x0*2+72

	.DW  0x0F
	.DW  _0x1D2+60
	.DW  _0x0*2+83

	.DW  0x05
	.DW  _0x1D2+75
	.DW  _0x0*2+98

	.DW  0x08
	.DW  _0x1D2+80
	.DW  _0x0*2+55

	.DW  0x0E
	.DW  _0x1D2+88
	.DW  _0x0*2+103

	.DW  0x0B
	.DW  _0x1D2+102
	.DW  _0x0*2+72

	.DW  0x0B
	.DW  _0x1D9
	.DW  _0x0*2+127

	.DW  0x0B
	.DW  _0x1D9+11
	.DW  _0x0*2+138

	.DW  0x08
	.DW  _0x1FA
	.DW  _0x0*2+158

	.DW  0x12
	.DW  _0x205
	.DW  _0x0*2+166

	.DW  0x06
	.DW  _0x225
	.DW  _0x0*2+184

	.DW  0x07
	.DW  _0x225+6
	.DW  _0x0*2+190

	.DW  0x06
	.DW  _0x225+13
	.DW  _0x0*2+197

	.DW  0x07
	.DW  _0x225+19
	.DW  _0x0*2+203

	.DW  0x08
	.DW  _0x225+26
	.DW  _0x0*2+210

	.DW  0x03
	.DW  _0x225+34
	.DW  _0x0*2+218

	.DW  0x08
	.DW  _0x225+37
	.DW  _0x0*2+210

	.DW  0x0C
	.DW  _0x225+45
	.DW  _0x0*2+221

	.DW  0x06
	.DW  _0x225+57
	.DW  _0x0*2+233

	.DW  0x07
	.DW  _0x225+63
	.DW  _0x0*2+239

	.DW  0x09
	.DW  _0x225+70
	.DW  _0x0*2+246

	.DW  0x0A
	.DW  _0x225+79
	.DW  _0x0*2+255

	.DW  0x0B
	.DW  _0x225+89
	.DW  _0x0*2+265

	.DW  0x0B
	.DW  _0x225+100
	.DW  _0x0*2+276

	.DW  0x06
	.DW  _0x225+111
	.DW  _0x0*2+287

	.DW  0x06
	.DW  _0x225+117
	.DW  _0x0*2+197

	.DW  0x07
	.DW  _0x225+123
	.DW  _0x0*2+203

	.DW  0x08
	.DW  _0x225+130
	.DW  _0x0*2+210

	.DW  0x03
	.DW  _0x225+138
	.DW  _0x0*2+218

	.DW  0x08
	.DW  _0x225+141
	.DW  _0x0*2+210

	.DW  0x0B
	.DW  _0x225+149
	.DW  _0x0*2+293

	.DW  0x04
	.DW  _0x225+160
	.DW  _0x0*2+304

	.DW  0x0A
	.DW  _0x225+164
	.DW  _0x0*2+308

	.DW  0x0A
	.DW  _0x225+174
	.DW  _0x0*2+318

	.DW  0x0A
	.DW  _0x225+184
	.DW  _0x0*2+328

	.DW  0x0C
	.DW  _0x225+194
	.DW  _0x0*2+338

	.DW  0x0C
	.DW  _0x225+206
	.DW  _0x0*2+350

	.DW  0x01
	.DW  _timers_cnt_tail
	.DW  _0x20003*2

	.DW  0x03
	.DW  _0x20024
	.DW  _0x20000*2

	.DW  0x04
	.DW  _0x20055
	.DW  _0x20000*2+3

	.DW  0x02
	.DW  _0x20055+4
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20055+6
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20055+8
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20055+10
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20055+12
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20055+14
	.DW  _0x20000*2+9

	.DW  0x03
	.DW  _0x20055+16
	.DW  _0x20000*2+11

	.DW  0x04
	.DW  _0x20056
	.DW  _0x20000*2+3

	.DW  0x02
	.DW  _0x20056+4
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20056+6
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20056+8
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20056+10
	.DW  _0x20000*2+7

	.DW  0x02
	.DW  _0x20056+12
	.DW  _0x20000*2+7

	.DW  0x04
	.DW  _0x20056+14
	.DW  _0x20000*2+14

	.DW  0x01
	.DW  __seed_G103
	.DW  _0x2060060*2

_0xFFFFFFFF:
	.DW  0

__RESET:
	CLI
	CLR  R30
	OUT  EECR,R30

;INTERRUPT VECTORS ARE PLACED
;AT THE START OF FLASH
	LDI  R31,1
	OUT  MCUCR,R31
	OUT  MCUCR,R30
	STS  XMCRB,R30

;DISABLE WATCHDOG
	LDI  R31,0x18
	OUT  WDTCR,R31
	OUT  WDTCR,R30

;CLEAR R2-R14
	LDI  R24,(14-2)+1
	LDI  R26,2
	CLR  R27
__CLEAR_REG:
	ST   X+,R30
	DEC  R24
	BRNE __CLEAR_REG

;CLEAR SRAM
	LDI  R24,LOW(__CLEAR_SRAM_SIZE)
	LDI  R25,HIGH(__CLEAR_SRAM_SIZE)
	LDI  R26,LOW(__SRAM_START)
	LDI  R27,HIGH(__SRAM_START)
__CLEAR_SRAM:
	ST   X+,R30
	SBIW R24,1
	BRNE __CLEAR_SRAM

;GLOBAL VARIABLES INITIALIZATION
	LDI  R30,LOW(__GLOBAL_INI_TBL*2)
	LDI  R31,HIGH(__GLOBAL_INI_TBL*2)
__GLOBAL_INI_NEXT:
	LPM  R24,Z+
	LPM  R25,Z+
	SBIW R24,0
	BREQ __GLOBAL_INI_END
	LPM  R26,Z+
	LPM  R27,Z+
	LPM  R0,Z+
	LPM  R1,Z+
	MOVW R22,R30
	MOVW R30,R0
__GLOBAL_INI_LOOP:
	LPM  R0,Z+
	ST   X+,R0
	SBIW R24,1
	BRNE __GLOBAL_INI_LOOP
	MOVW R30,R22
	RJMP __GLOBAL_INI_NEXT
__GLOBAL_INI_END:

	OUT  RAMPZ,R24

;HARDWARE STACK POINTER INITIALIZATION
	LDI  R30,LOW(__SRAM_END-__HEAP_SIZE)
	OUT  SPL,R30
	LDI  R30,HIGH(__SRAM_END-__HEAP_SIZE)
	OUT  SPH,R30

;DATA STACK POINTER INITIALIZATION
	LDI  R28,LOW(__SRAM_START+__DSTACK_SIZE)
	LDI  R29,HIGH(__SRAM_START+__DSTACK_SIZE)

	JMP  _main

	.ESEG
	.ORG 0

	.DSEG
	.ORG 0x200

	.CSEG
;                       /*****************************************************
;Project : Uni_interface_adapter
;Version :
;Date    : 04.02.2014
;Author  : Vlad
;
;Chip type               : ATmega128
;Program type            : Application
;AVR Core Clock frequency: 16,000000 MHz
;Data Stack size         : 1024
;*****************************************************/
;
;#define DEBUG
;
;#include <adapter.h>
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x20
	.EQU __sm_mask=0x1C
	.EQU __sm_powerdown=0x10
	.EQU __sm_powersave=0x18
	.EQU __sm_standby=0x14
	.EQU __sm_ext_standby=0x1C
	.EQU __sm_adc_noise_red=0x08
	.SET power_ctrl_reg=mcucr
	#endif
;//#include "my_debug.h"     //Upd-8 in folder
;
;
;#include "D_Globals/global_defines.h"     //Upd-8 in folder
;#include "D_Globals/global_variables.h"   //Upd-8 in folder
;#include "D_usart/usart.h"
;#include "RTOS/EERTOS.h"
;#include "RTOS/EERTOSHAL.h"
;#include "D_Tasks/task_list.h"
;
;#define LogBufSize 512 //Размер буффера для логов
;static volatile char WorkLog[LogBufSize];
;static volatile uint16_t LogIndex = 0;
;
;/////// Отладочный кусок.
;//Вывод лога работы конечного автомата в буфер памяти, а потом.
;//По окончании работы через UART на волю
;
;void WorkLogPutChar(unsigned char symbol)
; 0000 000F {

	.CSEG
_WorkLogPutChar:
;__disable_interrupts();
;	symbol -> Y+0
	IN   R30,0x3F
	STS  _saved_state_G000,R30
	cli
;if (LogIndex <LogBufSize)            // Если лог не переполнен
	CALL SUBOPT_0x0
	BRSH _0x6
;{
;        WorkLog[LogIndex]= symbol;    // Пишем статус в лог
	CALL SUBOPT_0x1
	LD   R26,Y
	CALL SUBOPT_0x2
;        LogIndex++;
;}
; __restore_interrupts();
_0x6:
	CALL SUBOPT_0x3
;}
	ADIW R28,1
	RET
;
;void Put_In_LogFl (unsigned char __flash* data){
;  while(*data)
;	*data -> Y+0
;  {
;    WorkLogPutChar(*data++);
;  }
;}
;
;//#warning  -добавить после каждого слова прибавление \r\n для єкономии РАМ
;void Put_In_Log (unsigned char * data)
;{
_Put_In_Log:
;  while(*data)
;	*data -> Y+0
_0xA:
	LD   R26,Y
	LDD  R27,Y+1
	LD   R30,X
	CPI  R30,0
	BREQ _0xC
;  {
;    WorkLogPutChar(*data++);
	LD   R30,X+
	ST   Y,R26
	STD  Y+1,R27
	ST   -Y,R30
	RCALL _WorkLogPutChar
;  }
	RJMP _0xA
_0xC:
;  /// WorkLogPutChar(10);//\r
;   //WorkLogPutChar(13);//\n
;}
	RJMP _0x20C000E
;
;void LogOut(void)				// Выброс логов
;{
_LogOut:
;//StopRTOS();
;
;WorkLog[LogIndex]= '+';
	CALL SUBOPT_0x1
	LDI  R26,LOW(43)
	CALL SUBOPT_0x2
;LogIndex++;
;USART_Send_Str(SYSTEM_USART, WorkLog);
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R30,LOW(_WorkLog_G000)
	LDI  R31,HIGH(_WorkLog_G000)
	ST   -Y,R31
	ST   -Y,R30
	RCALL _USART_Send_Str
;
;//RunRTOS();
;
;FLAG_SET(g_tcf, FLUSH_WORKLOG);//SetTimerTask(Task_Flush_WorkLog,25,0);//очистка лог буффера
	CALL SUBOPT_0x4
	ORI  R30,4
	CALL SUBOPT_0x5
;LogIndex = 0;
	LDI  R30,LOW(0)
	STS  _LogIndex_G000,R30
	STS  _LogIndex_G000+1,R30
;}
	RET
;
;void Timer_3_start(void)
;{
;   TCCR3B =(1<<CS31)|(1<<CS30);//presc = 64
;//TIMSK |=0x04; //Tim1 ovrflow Interrupt  ON
;}
;
;void Timer_3_stop(void)
;{
;ICR3H=0x00;     ICR3L=0x00;
;OCR3AH=0x00;    OCR3AL=0x00;
;OCR3BH=0x00;    OCR3BL=0x00;
;OCR3CH=0x00;    OCR3CL=0x00;
;TCNT3H=0x00;    TCNT3L=0x00;
;TCCR3A=0x00;    TCCR3B==0x00;
;//TIMSK &=~0x04; //Tim1 ovrflow Interrupt  OFF
;}
;
;uint16_t Timer_3_get_val (void)
;{
;uint16_t val = 0;
;//__disable_interrupts();
; val = TCNT3H;
;	val -> R16,R17
;//__restore_interrupts();
;return val;
;}
;/////////////
;/**********************************************
;****************PCD8544 Driver*****************
;***********************************************
;
;for original NOKIA 3310 & alternative "chinese" version of display
;
;48x84 dots, 6x14 symbols
;
;**********************************************/
;
;//#define china 1		// если определено - работаем по алгоритмам "китайского" дисплея, иначе - оригинального
;#define SOFT_SPI 1	// если определено - используем программный SPI, иначе - аппаратный
;
;#ifndef SOFT_SPI
;unsigned char SPCR_val = 0x50;	// режим
;unsigned char SPSR_val = 0x01;  // удвоение частоты
;#endif
;
;//LCD Port & pinout setup. Примечание: порты с "кривой" адресацией (типа порт G и т.п.) не поддерживаются
;#define LCD_DC_PORT  	PORTA	// выбор команда-данные; любой пин любого порта
;#define LCD_DC_DDR 	    DDRA
;#define LCD_DC_PIN 	    0
;
;#define LCD_CPORT 	    PORTA	// Chip-Select; любой пин любого порта
;#define LCD_CDDR   	    DDRA
;#define LCD_CPIN    	1
;
;#define LCD_RST_PORT 	PORTA	// сброс экрана; любой пин любого порта
;#define LCD_RST_DDR   	DDRA
;#define LCD_RST_PIN   	2
;
;#define LCD_MOSI_PORT 	PORTA	// выход данных SPI, должен быть соответствующий пин аппаратного SPI, если он используется
;#define LCD_MOSI_DDR	DDRA
;#define LCD_MOSI_PIN    3
;
;#define LCD_CLK_PORT	PORTA	// тактирование SPI, должен быть соответствующий пин аппаратного SPI, если он используется
;#define LCD_CLK_DDR     DDRA
;#define LCD_CLK_PIN     4
;
;
;
;#ifndef SOFT_SPI
;#define LCD_SS_PORT	    PORTB	// ChipSelect SPI, должен быть соответствующий пин аппаратного SPI и настроен на выход
;#define LCD_SS_DDR     	DDRB
;#define LCD_SS_PIN     	0
;#endif
;
;//***********************************************************
;//Настройки контроллера дисплея и переменные для работы с ним
;//***********************************************************
;
;#pragma used+
;
;unsigned char lcd_buf[15];		//текстовый буфер для вывода на LCD
;
;#warning - перенести в дефайны
;bit power_down = 0;			//power-down control: 0 - chip is active, 1 - chip is in PD-mode
;bit addressing = 0;			//направление адресации: 0 - горизонтальная, 1- вертикальная
;//bit instuct_set = 0;			//набор инструкций: 0 - стандартный, 1 - расширенный - в текущей версии не используется
;
;#ifdef china
;bit x_mirror = 0;			//зеркалирование по X: 0 - выкл., 1 - вкл.
;bit y_mirror = 0;			//зеркалирование по Y: 0 - выкл., 1 - вкл.
;bit SPI_invert = 0;			//порядок битов в SPI: 0 - MSB first, 1 - LSB first
;#endif
;
;//unsigned char set_y;			//адрес по У, 0..5 - в текущей версии не используется
;//unsigned char set_x;                 	//адрес по Х, 0..83 - в текущей версии не используется
;uint8_t temp_control = 3;  	//температурный коэффициент, 0..3

	.DSEG
;unsigned char bias = 3;                 //смещение, 0..7
;unsigned char Vop = 70;			//рабочее напрядение LCD, 0..127 (определяет контрастность)
;unsigned char disp_config = 2;		//режим дисплея: 0 - blank, 1 - all on, 2 - normal, 3 - inverse
;
;#ifdef china
;unsigned char shift = 5;		//0..3F - сдвиг экрана вверх, в точках
;#endif
;
;#define PIXEL_OFF	0		//режимы отображения пикселя - используются в графических функциях
;#define PIXEL_ON	1
;#define PIXEL_XOR	2
;
;#define LCD_X_RES               84	//разрешение экрана
;#define LCD_Y_RES               48
;#define LCD_CACHSIZE          LCD_X_RES*LCD_Y_RES/8
;
;#define Cntr_X_RES              102    	//разрешение контроллера - предполагаемое - но работает))
;#define Cntr_Y_RES              64
;#define Cntr_buf_size           Cntr_X_RES*Cntr_Y_RES/8
;
;unsigned char  LcdCache [LCD_CACHSIZE];	//Cache buffer in SRAM 84*48 bits or 504 bytes
;unsigned int   LcdCacheIdx;              	//Cache index
;
;#define LCD_CMD         0
;#define LCD_DATA        1
;
;//***************************************************
;//****************Прототипы функций******************
;//***************************************************
;void LcdSend (unsigned char data, unsigned char cmd);    			//Sends data to display controller
;void LcdUpdate (void);   							//Copies the LCD cache into the device RAM
;void LcdClear (void);    							//Clears the display
;void LcdInit ( void );								//Настройка SPI и дисплея
;void LcdContrast (unsigned char contrast); 					//contrast -> Contrast value from 0x00 to 0x7F
;void LcdMode (unsigned char mode); 						//режимы дисплея: 0 - blank, 1 - all on, 2 - normal, 3 - inverse
;void LcdPwrMode (void);								//инвертирует состояние вкл/выкл дисплея
;void LcdImage (flash unsigned char *imageData);					//вывод изображения
;void LcdPixel (unsigned char x, unsigned char y, unsigned char mode);     	//Displays a pixel at given absolute (x, y) location, mode -> Off, On or Xor
;void LcdLine (int x1, int y1, int x2, int y2, unsigned char mode);  		//Draws a line between two points on the display
;void LcdCircle(char x, char y, char radius, unsigned char mode);		//рисуем круг с координатами центра и радиусом
;void LcdBatt(int x1, int y1, int x2, int y2, unsigned char persent);		//рисуем батарейку и заполняем ее на %
;void LcdGotoXYFont (unsigned char x, unsigned char y);   			//Sets cursor location to xy location. Range: 1,1 .. 14,6
;void LcdTextBufClean (void);							//очистка текстового буфера
;void LcdChr (int ch);								//Displays a character at current cursor location and increment cursor location
;void LcdString (unsigned char x, unsigned char y);				//Displays a string at current cursor location
;void LcdChrBold (int ch);							//Печатает символ на текущем месте, большой и жирный)
;void LcdStringBold (unsigned char x, unsigned char y);				//Печатает большую и жирную строку
;void LcdChrBig (int ch);							//Печатает символ на текущем месте, большой
;void LcdStringBig (unsigned char x, unsigned char y);				//Печатает большую строку
;//***************************************************
;// UPDATE ##1
;void LcdBar(int x1, int y1, int x2, int y2, unsigned char persent);		// рисует прогресс-бар и заполняет его на "процент"
;void LcdBarLine(unsigned char line, unsigned char persent);			// рисуем прошресс-бар в указанной строке
;void LcdStringInv (unsigned char x, unsigned char y);                           // печатает строку в инверсном шрифте (удобно для настроек)
;
;  #warning a lot of nulls -need to compressed!
;const char table[0x0500] =
;{
;0x00, 0x00, 0x00, 0x00, 0x00,// 00
;0x00, 0x00, 0x5F, 0x00, 0x00,// 01
;0x00, 0x07, 0x00, 0x07, 0x00,// 02
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 03
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 04
;0x23, 0x13, 0x08, 0x64, 0x62,// 05
;0x36, 0x49, 0x55, 0x22, 0x50,// 06
;0x00, 0x05, 0x03, 0x00, 0x00,// 07
;0x00, 0x1C, 0x22, 0x41, 0x00,// 08
;0x00, 0x41, 0x22, 0x1C, 0x00,// 09
;0x14, 0x08, 0x3E, 0x08, 0x14,// 0A
;0x08, 0x08, 0x3E, 0x08, 0x08,// 0B
;0x00, 0x50, 0x30, 0x00, 0x00,// 0C
;0x08, 0x08, 0x08, 0x08, 0x08,// 0D
;0x00, 0x60, 0x60, 0x00, 0x00,// 0E
;0x20, 0x10, 0x08, 0x04, 0x02,// 0F
;0x00, 0x00, 0x00, 0x00, 0x00,// 10
;0x00, 0x00, 0x5F, 0x00, 0x00,// 11
;0x00, 0x07, 0x00, 0x07, 0x00,// 12
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 13
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 14
;0x23, 0x13, 0x08, 0x64, 0x62,// 15
;0x36, 0x49, 0x55, 0x22, 0x50,// 16
;0x00, 0x05, 0x03, 0x00, 0x00,// 17
;0x00, 0x1C, 0x22, 0x41, 0x00,// 18
;0x00, 0x41, 0x22, 0x1C, 0x00,// 19
;0x14, 0x08, 0x3E, 0x08, 0x14,// 1A
;0x08, 0x08, 0x3E, 0x08, 0x08,// 1B
;0x00, 0x50, 0x30, 0x00, 0x00,// 1C
;0x08, 0x08, 0x08, 0x08, 0x08,// 1D
;0x00, 0x60, 0x60, 0x00, 0x00,// 1E
;0x20, 0x10, 0x08, 0x04, 0x02,// 1F
;0x00, 0x00, 0x00, 0x00, 0x00,// 20 space
;0x00, 0x00, 0x5F, 0x00, 0x00,// 21 !
;0x00, 0x07, 0x00, 0x07, 0x00,// 22 "
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 23 #
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 24 $
;0x23, 0x13, 0x08, 0x64, 0x62,// 25 %
;0x36, 0x49, 0x55, 0x22, 0x50,// 26 &
;0x00, 0x05, 0x03, 0x00, 0x00,// 27 '
;0x00, 0x1C, 0x22, 0x41, 0x00,// 28 (
;0x00, 0x41, 0x22, 0x1C, 0x00,// 29 )
;0x14, 0x08, 0x3E, 0x08, 0x14,// 2a *
;0x08, 0x08, 0x3E, 0x08, 0x08,// 2b +
;0x00, 0x50, 0x30, 0x00, 0x00,// 2c ,
;0x08, 0x08, 0x08, 0x08, 0x08,// 2d -
;0x00, 0x60, 0x60, 0x00, 0x00,// 2e .
;0x20, 0x10, 0x08, 0x04, 0x02,// 2f /
;0x3E, 0x51, 0x49, 0x45, 0x3E,// 30 0
;0x00, 0x42, 0x7F, 0x40, 0x00,// 31 1
;0x42, 0x61, 0x51, 0x49, 0x46,// 32 2
;0x21, 0x41, 0x45, 0x4B, 0x31,// 33 3
;0x18, 0x14, 0x12, 0x7F, 0x10,// 34 4
;0x27, 0x45, 0x45, 0x45, 0x39,// 35 5
;0x3C, 0x4A, 0x49, 0x49, 0x30,// 36 6
;0x01, 0x71, 0x09, 0x05, 0x03,// 37 7
;0x36, 0x49, 0x49, 0x49, 0x36,// 38 8
;0x06, 0x49, 0x49, 0x29, 0x1E,// 39 9
;0x00, 0x36, 0x36, 0x00, 0x00,// 3a :
;0x00, 0x56, 0x36, 0x00, 0x00,// 3b ;
;0x08, 0x14, 0x22, 0x41, 0x00,// 3c <
;0x14, 0x14, 0x14, 0x14, 0x14,// 3d =
;0x00, 0x41, 0x22, 0x14, 0x08,// 3e >
;0x02, 0x01, 0x51, 0x09, 0x06,// 3f ?
;0x32, 0x49, 0x79, 0x41, 0x3E,// 40 @
;0x7E, 0x11, 0x11, 0x11, 0x7E,// 41 A
;0x7F, 0x49, 0x49, 0x49, 0x36,// 42 B
;0x3E, 0x41, 0x41, 0x41, 0x22,// 43 C
;0x7F, 0x41, 0x41, 0x22, 0x1C,// 44 D
;0x7F, 0x49, 0x49, 0x49, 0x41,// 45 E
;0x7F, 0x09, 0x09, 0x09, 0x01,// 46 F
;0x3E, 0x41, 0x49, 0x49, 0x7A,// 47 G
;0x7F, 0x08, 0x08, 0x08, 0x7F,// 48 H
;0x00, 0x41, 0x7F, 0x41, 0x00,// 49 I
;0x20, 0x40, 0x41, 0x3F, 0x01,// 4a J
;0x7F, 0x08, 0x14, 0x22, 0x41,// 4b K
;0x7F, 0x40, 0x40, 0x40, 0x40,// 4c L
;0x7F, 0x02, 0x0C, 0x02, 0x7F,// 4d M
;0x7F, 0x04, 0x08, 0x10, 0x7F,// 4e N
;0x3E, 0x41, 0x41, 0x41, 0x3E,// 4f O
;0x7F, 0x09, 0x09, 0x09, 0x06,// 50 P
;0x3E, 0x41, 0x51, 0x21, 0x5E,// 51 Q
;0x7F, 0x09, 0x19, 0x29, 0x46,// 52 R
;0x46, 0x49, 0x49, 0x49, 0x31,// 53 S
;0x01, 0x01, 0x7F, 0x01, 0x01,// 54 T
;0x3F, 0x40, 0x40, 0x40, 0x3F,// 55 U
;0x1F, 0x20, 0x40, 0x20, 0x1F,// 56 V
;0x3F, 0x40, 0x38, 0x40, 0x3F,// 57 W
;0x63, 0x14, 0x08, 0x14, 0x63,// 58 X
;0x07, 0x08, 0x70, 0x08, 0x07,// 59 Y
;0x61, 0x51, 0x49, 0x45, 0x43,// 5a Z
;0x00, 0x7F, 0x41, 0x41, 0x00,// 5b [
;0x02, 0x04, 0x08, 0x10, 0x20,// 5c Yen Currency Sign
;0x00, 0x41, 0x41, 0x7F, 0x00,// 5d ]
;0x04, 0x02, 0x01, 0x02, 0x04,// 5e ^
;0x40, 0x40, 0x40, 0x40, 0x40,// 5f _
;0x00, 0x01, 0x02, 0x04, 0x00,// 60 `
;0x20, 0x54, 0x54, 0x54, 0x78,// 61 a
;0x7F, 0x48, 0x44, 0x44, 0x38,// 62 b
;0x38, 0x44, 0x44, 0x44, 0x20,// 63 c
;0x38, 0x44, 0x44, 0x48, 0x7F,// 64 d
;0x38, 0x54, 0x54, 0x54, 0x18,// 65 e
;0x08, 0x7E, 0x09, 0x01, 0x02,// 66 f
;0x0C, 0x52, 0x52, 0x52, 0x3E,// 67 g
;0x7F, 0x08, 0x04, 0x04, 0x78,// 68 h
;0x00, 0x44, 0x7D, 0x40, 0x00,// 69 i
;0x20, 0x40, 0x44, 0x3D, 0x00,// 6a j
;0x7F, 0x10, 0x28, 0x44, 0x00,// 6b k
;0x00, 0x41, 0x7F, 0x40, 0x00,// 6c l
;0x7C, 0x04, 0x18, 0x04, 0x78,// 6d m
;0x7C, 0x08, 0x04, 0x04, 0x78,// 6e n
;0x38, 0x44, 0x44, 0x44, 0x38,// 6f o
;0x7C, 0x14, 0x14, 0x14, 0x08,// 70 p
;0x08, 0x14, 0x14, 0x18, 0x7C,// 71 q
;0x7C, 0x08, 0x04, 0x04, 0x08,// 72 r
;0x48, 0x54, 0x54, 0x54, 0x20,// 73 s
;0x04, 0x3F, 0x44, 0x40, 0x20,// 74 t
;0x3C, 0x40, 0x40, 0x20, 0x7C,// 75 u
;0x1C, 0x20, 0x40, 0x20, 0x1C,// 76 v
;0x3C, 0x40, 0x30, 0x40, 0x3C,// 77 w
;0x44, 0x28, 0x10, 0x28, 0x44,// 78 x
;0x0C, 0x50, 0x50, 0x50, 0x3C,// 79 y
;0x44, 0x64, 0x54, 0x4C, 0x44,// 7a z
;0x00, 0x08, 0x36, 0x41, 0x00,// 7b <
;0x00, 0x00, 0x7F, 0x00, 0x00,// 7c |
;0x00, 0x41, 0x36, 0x08, 0x00,// 7d >
;0x10, 0x08, 0x08, 0x10, 0x08,// 7e Right Arrow ->
;0x78, 0x46, 0x41, 0x46, 0x78,// 7f Left Arrow <-
;0x00, 0x00, 0x00, 0x00, 0x00,// 80
;0x00, 0x00, 0x5F, 0x00, 0x00,// 81
;0x00, 0x07, 0x00, 0x07, 0x00,// 82
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 83
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 84
;0x23, 0x13, 0x08, 0x64, 0x62,// 85
;0x36, 0x49, 0x55, 0x22, 0x50,// 86
;0x00, 0x05, 0x03, 0x00, 0x00,// 87
;0x00, 0x1C, 0x22, 0x41, 0x00,// 88
;0x00, 0x41, 0x22, 0x1C, 0x00,// 89
;0x14, 0x08, 0x3E, 0x08, 0x14,// 8A
;0x08, 0x08, 0x3E, 0x08, 0x08,// 8B
;0x00, 0x50, 0x30, 0x00, 0x00,// 8C
;0x08, 0x08, 0x08, 0x08, 0x08,// 8D
;0x00, 0x60, 0x60, 0x00, 0x00,// 8E
;0x20, 0x10, 0x08, 0x04, 0x02,// 8F
;0x00, 0x00, 0x00, 0x00, 0x00,// 90
;0x00, 0x00, 0x5F, 0x00, 0x00,// 91
;0x00, 0x07, 0x00, 0x07, 0x00,// 92
;0x14, 0x7F, 0x14, 0x7F, 0x14,// 93
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// 94
;0x23, 0x13, 0x08, 0x64, 0x62,// 95
;0x36, 0x49, 0x55, 0x22, 0x50,// 96
;0x00, 0x05, 0x03, 0x00, 0x00,// 97
;0x00, 0x1C, 0x22, 0x41, 0x00,// 98
;0x00, 0x41, 0x22, 0x1C, 0x00,// 99
;0x14, 0x08, 0x3E, 0x08, 0x14,// 9A
;0x08, 0x08, 0x3E, 0x08, 0x08,// 9B
;0x00, 0x50, 0x30, 0x00, 0x00,// 9C
;0x08, 0x08, 0x08, 0x08, 0x08,// 9D
;0x00, 0x60, 0x60, 0x00, 0x00,// 9E
;0x20, 0x10, 0x08, 0x04, 0x02,// 9F
;0x00, 0x00, 0x00, 0x00, 0x00,// A0
;0x00, 0x00, 0x5F, 0x00, 0x00,// A1
;0x00, 0x07, 0x00, 0x07, 0x00,// A2
;0x14, 0x7F, 0x14, 0x7F, 0x14,// A3
;0x24, 0x2A, 0x7F, 0x2A, 0x12,// A4
;0x23, 0x13, 0x08, 0x64, 0x62,// A5
;0x36, 0x49, 0x55, 0x22, 0x50,// A6
;0x00, 0x05, 0x03, 0x00, 0x00,// A7
;0x00, 0x1C, 0x22, 0x41, 0x00,// A8
;0x00, 0x41, 0x22, 0x1C, 0x00,// A9
;0x14, 0x08, 0x3E, 0x08, 0x14,// AA
;0x08, 0x08, 0x3E, 0x08, 0x08,// AB
;0x00, 0x50, 0x30, 0x00, 0x00,// AC
;0x08, 0x08, 0x08, 0x08, 0x08,// AD
;0x00, 0x60, 0x60, 0x00, 0x00,// AE
;0x20, 0x10, 0x08, 0x04, 0x02,// AF
;0x3E, 0x51, 0x49, 0x45, 0x3E,// B0
;0x00, 0x42, 0x7F, 0x40, 0x00,// B1
;0x42, 0x61, 0x51, 0x49, 0x46,// B2
;0x21, 0x41, 0x45, 0x4B, 0x31,// B3
;0x18, 0x14, 0x12, 0x7F, 0x10,// B4
;0x27, 0x45, 0x45, 0x45, 0x39,// B5
;0x3C, 0x4A, 0x49, 0x49, 0x30,// B6
;0x01, 0x71, 0x09, 0x05, 0x03,// B7
;0x36, 0x49, 0x49, 0x49, 0x36,// B8
;0x06, 0x49, 0x49, 0x29, 0x1E,// B9
;0x00, 0x36, 0x36, 0x00, 0x00,// BA
;0x00, 0x56, 0x36, 0x00, 0x00,// BB
;0x08, 0x14, 0x22, 0x41, 0x00,// BC
;0x14, 0x14, 0x14, 0x14, 0x14,// BD
;0x00, 0x41, 0x22, 0x14, 0x08,// BE
;0x02, 0x01, 0x51, 0x09, 0x06,// BF
;0x7E, 0x11, 0x11, 0x11, 0x7E,// C0 А
;0x7F, 0x49, 0x49, 0x49, 0x31,// C1 Б
;0x7F, 0x49, 0x49, 0x49, 0x36,// C2 ?
;0x7F, 0x01, 0x01, 0x01, 0x03,// C3 ?
;0x70, 0x29, 0x27, 0x21, 0x7F,// C4 ?
;0x7F, 0x49, 0x49, 0x49, 0x41,// C5 ?
;0x77, 0x08, 0x7F, 0x08, 0x77,// C6 ?
;0x41, 0x41, 0x41, 0x49, 0x76,// C7 ?
;0x7F, 0x10, 0x08, 0x04, 0x7F,// C8 ?
;0x7F, 0x10, 0x09, 0x04, 0x7F,// C9 ?
;0x7F, 0x08, 0x14, 0x22, 0x41,// CA ?
;0x20, 0x41, 0x3F, 0x01, 0x7F,// CB ?
;0x7F, 0x02, 0x0C, 0x02, 0x7F,// CC ?
;0x7F, 0x08, 0x08, 0x08, 0x7F,// CD ?
;0x3E, 0x41, 0x41, 0x41, 0x3E,// CE ?
;0x7F, 0x01, 0x01, 0x01, 0x7F,// CF ?
;0x7F, 0x09, 0x09, 0x09, 0x06,// D0 ?
;0x3E, 0x41, 0x41, 0x41, 0x22,// D1 ?
;0x01, 0x01, 0x7F, 0x01, 0x01,// D2 ?
;0x47, 0x28, 0x10, 0x08, 0x07,// D3 ?
;0x1E, 0x21, 0x7F, 0x21, 0x1E,// D4 ?
;0x63, 0x14, 0x08, 0x14, 0x63,// D5 ?
;0x3F, 0x20, 0x20, 0x20, 0x5F,// D6 ?
;0x07, 0x08, 0x08, 0x08, 0x7F,// D7 ?
;0x7F, 0x40, 0x7F, 0x40, 0x7F,// D8 ?
;0x3F, 0x20, 0x3F, 0x20, 0x5F,// D9 ?
;0x01, 0x7F, 0x48, 0x48, 0x30,// DA ?
;0x7F, 0x48, 0x30, 0x00, 0x7F,// DB ?
;0x00, 0x7F, 0x48, 0x48, 0x30,// DC ?
;0x41, 0x41, 0x41, 0x49, 0x3E,// DD ?
;0x7F, 0x08, 0x3E, 0x41, 0x3E,// DE ?
;0x46, 0x29, 0x19, 0x09, 0x7F,// DF ?
;0x20, 0x54, 0x54, 0x54, 0x78,// E0 ?
;0x3C, 0x4A, 0x4A, 0x49, 0x31,// E1 ?
;0x7C, 0x54, 0x54, 0x28, 0x00,// E2 ?
;0x7C, 0x04, 0x04, 0x04, 0x0C,// E3 ?
;0x72, 0x2A, 0x26, 0x22, 0x7E,// E4 ?
;0x38, 0x54, 0x54, 0x54, 0x18,// E5 ?
;0x6C, 0x10, 0x7C, 0x10, 0x6C,// E6 ?
;0x44, 0x44, 0x54, 0x54, 0x38,// E7 ?
;0x7C, 0x20, 0x10, 0x08, 0x7C,// E8 ?
;0x7C, 0x21, 0x12, 0x09, 0x7C,// E9 ?
;0x7C, 0x10, 0x28, 0x44, 0x00,// EA ?
;0x20, 0x44, 0x3C, 0x04, 0x7C,// EB ?
;0x7C, 0x08, 0x10, 0x08, 0x7C,// EC ?
;0x7C, 0x10, 0x10, 0x10, 0x7C,// ED ?
;0x38, 0x44, 0x44, 0x44, 0x38,// EE ?
;0x7C, 0x04, 0x04, 0x04, 0x7C,// EF ?
;0x7C, 0x14, 0x14, 0x14, 0x08,// F0 ?
;0x38, 0x44, 0x44, 0x44, 0x20,// F1 ?
;0x04, 0x04, 0x7C, 0x04, 0x04,// F2 ?
;0x44, 0x28, 0x10, 0x08, 0x04,// F3 ?
;0x08, 0x14, 0x7E, 0x14, 0x08,// F4 ?
;0x44, 0x28, 0x10, 0x28, 0x44,// F5 ?
;0x3C, 0x40, 0x40, 0x7C, 0x40,// F6 ?
;0x0C, 0x10, 0x10, 0x10, 0x7C,// F7 ?
;0x7C, 0x40, 0x7C, 0x40, 0x7C,// F8 ?
;0x3C, 0x20, 0x3C, 0x20, 0x7C,// F9 ?
;0x04, 0x7C, 0x50, 0x50, 0x20,// FA ?
;0x7C, 0x50, 0x20, 0x00, 0x7C,// FB ?
;0x00, 0x7C, 0x50, 0x50, 0x20,// FC ?
;0x28, 0x44, 0x44, 0x54, 0x38,// FD ?
;0x7C, 0x10, 0x38, 0x44, 0x38,// FE ?
;0x48, 0x54, 0x34, 0x14, 0x7C }; // FF
;
;void LcdSend (unsigned char data, unsigned char cmd)    //Sends data to display controller
;        {

	.CSEG
_LcdSend:
;        #ifdef SOFT_SPI
;        unsigned char i, mask = 128;
;        #endif
;
;        LCD_CPORT.LCD_CPIN = 0;                //Enable display controller (active low)
	ST   -Y,R17
	ST   -Y,R16
;	data -> Y+3
;	cmd -> Y+2
;	i -> R17
;	mask -> R16
	LDI  R16,128
	CBI  0x1B,1
;         if (cmd) LCD_DC_PORT.LCD_DC_PIN = 1;	//выбираем команда или данные
	LDD  R30,Y+2
	CPI  R30,0
	BREQ _0x13
	SBI  0x1B,0
;         else LCD_DC_PORT.LCD_DC_PIN = 0;
	RJMP _0x16
_0x13:
	CBI  0x1B,0
;
;        #ifdef SOFT_SPI
;        for (i=0;i<8;i++)
_0x16:
	LDI  R17,LOW(0)
_0x1A:
	CPI  R17,8
	BRSH _0x1B
;          {
;            	if ((data&mask)!=0) LCD_MOSI_PORT.LCD_MOSI_PIN = 1;
	MOV  R30,R16
	LDD  R26,Y+3
	AND  R30,R26
	BREQ _0x1C
	SBI  0x1B,3
;                else LCD_MOSI_PORT.LCD_MOSI_PIN = 0;
	RJMP _0x1F
_0x1C:
	CBI  0x1B,3
;        	mask = mask/2;
_0x1F:
	LSR  R16
;        	LCD_CLK_PORT.LCD_CLK_PIN = 1;
	SBI  0x1B,4
;            LCD_CLK_PORT.LCD_CLK_PIN = 0;
	CBI  0x1B,4
;          }
	SUBI R17,-1
	RJMP _0x1A
_0x1B:
;        #endif
;
;        #ifndef SOFT_SPI
;        SPDR = data;                            //Send data to display controller
;        while ( (SPSR & 0x80) != 0x80 ){};        //Wait until Tx register empty
;        #endif
;
;        LCD_CPORT.LCD_CPIN = 1;                //Disable display controller
	SBI  0x1B,1
;        }
	RJMP _0x20C000F
;
;#warning need 7.05ms(!) to execute
;void LcdUpdate (void)   //Copies the LCD cache into the device RAM
;        {
_LcdUpdate:
;        int i;
;	#ifdef china
;	char j;
;	#endif
;
;        LcdSend(0x80, LCD_CMD);		//команды установки указателя памяти дисплея на 0,0
	CALL SUBOPT_0x6
;	i -> R16,R17
;        LcdSend(0x40, LCD_CMD);
;
;    #ifdef china                    		//если китайский дисплей - грузим пустую строку
;		for (j = Cntr_X_RES; j>0; j--) LcdSend(0, LCD_DATA);
;	#endif
;
;        for (i = 0; i < LCD_CACHSIZE; i++)		//грузим данные
_0x29:
	__CPWRN 16,17,504
	BRGE _0x2A
;                {
;                LcdSend(LcdCache[i], LCD_DATA);
	LDI  R26,LOW(_LcdCache)
	LDI  R27,HIGH(_LcdCache)
	ADD  R26,R16
	ADC  R27,R17
	LD   R30,X
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	RCALL _LcdSend
;		#ifdef china				//если дисплей китайский - догружаем каждую строку до размера его буфера
;		if (++j == LCD_X_RES)
;			{
;			for (j = (Cntr_X_RES-LCD_X_RES); j>0; j--) LcdSend(0, LCD_DATA);
;			j=0;
;			}
;		#endif
;                }
	__ADDWRN 16,17,1
	RJMP _0x29
_0x2A:
;        }
	RJMP _0x20C0010
;
;void LcdClear (void)    //Clears the display
;{
_LcdClear:
;        int i;
;	for (i = 0; i < LCD_CACHSIZE; i++) LcdCache[i] = 0;	//забиваем всю память 0
	CALL SUBOPT_0x7
;	i -> R16,R17
_0x2C:
	__CPWRN 16,17,504
	BRGE _0x2D
	LDI  R26,LOW(_LcdCache)
	LDI  R27,HIGH(_LcdCache)
	ADD  R26,R16
	ADC  R27,R17
	LDI  R30,LOW(0)
	ST   X,R30
	__ADDWRN 16,17,1
	RJMP _0x2C
_0x2D:
	RCALL _LcdUpdate
;}
_0x20C0010:
	LD   R16,Y+
	LD   R17,Y+
	RET
;
;/*     or
;void lcd_clear(void) // Clears the display   //Upd - 7
;{
;	lcdCacheIdx = 0;
;	lcd_base_addr(lcdCacheIdx);
;    // Set the entire cache to zero and write 0s to lcd
;    for(int i=0;i<LCD_CACHE_SIZE;i++) {
;		lcd_send(0, LCD_DATA);
;    }
;}
;*/
;
;void LcdInit ( void )	//инициализация SPI и дисплея
;        {
_LcdInit:
;        LCD_RST_PORT.LCD_RST_PIN = 1;       //настроили порты ввода/вывода
	SBI  0x1B,2
;        LCD_RST_DDR.LCD_RST_PIN = LCD_DC_DDR.LCD_DC_PIN = LCD_CDDR.LCD_CPIN = LCD_MOSI_DDR.LCD_MOSI_PIN = LCD_CLK_DDR.LCD_CLK_PIN = 1;
	SBI  0x1A,4
	SBI  0x1A,3
	SBI  0x1A,1
	SBI  0x1A,0
	SBI  0x1A,2
;        LCD_CLK_PORT.LCD_CLK_PIN = 0;
	CBI  0x1B,4
;        	#ifndef SOFT_SPI
;        LCD_SS_DDR.LCD_SS_PIN = 1;
;        LCD_SS_PORT.LCD_SS_PIN = 0;
;        	#endif
;        delay_ms(1);
	LDI  R30,LOW(1)
	LDI  R31,HIGH(1)
	CALL SUBOPT_0x8
;        	#ifndef SOFT_SPI
;        //SPCR = SPCR_val;
;        //SPSR = SPSR_val;
;        	#endif
;        LCD_RST_PORT.LCD_RST_PIN = 0;       //дернули ресет
	CBI  0x1B,2
;        delay_ms(20);
	LDI  R30,LOW(20)
	LDI  R31,HIGH(20)
	CALL SUBOPT_0x8
;        LCD_RST_PORT.LCD_RST_PIN = 1;
	SBI  0x1B,2
;
;        LCD_CPORT.LCD_CPIN = 1;        //Disable LCD controller
	SBI  0x1B,1
;
;/*
;    LCD_PORT |= LCD_SCE_PIN;    // Disable LCD controller
;    lcd_send(0x21, LCD_CMD);  // LCD Extended Commands
;    lcd_send(0xC8, LCD_CMD);  // Set LCD Vop(Contrast)
;    lcd_send(0x06, LCD_CMD);  // Set Temp coefficent
;    lcd_send(0x13, LCD_CMD);  // LCD bias mode 1:48
;    lcd_send(0x20, LCD_CMD);  // Standard Commands, Horizontal addressing
;    lcd_send(0x0C, LCD_CMD);  // LCD in normal mode
;*/
;        LcdSend( 0b00100001, LCD_CMD ); 				//LCD Extended Commands
	LDI  R30,LOW(33)
	CALL SUBOPT_0x9
;        LcdSend( 0b00000100+temp_control, LCD_CMD ); 	//Set Temp coefficent   //! НА 128 - ГЛЮЧИТ
	LDS  R30,_temp_control
	SUBI R30,-LOW(4)
	CALL SUBOPT_0x9
;#ifdef china
;        LcdSend( 0b00001000|SPI_invert<<3, LCD_CMD ); 	//порядок битов в SPI
;#endif
;        LcdSend( 0b00010000+bias, LCD_CMD ); 			//LCD bias mode 1:48
	LDS  R30,_bias
	SUBI R30,-LOW(16)
	CALL SUBOPT_0x9
;#ifdef china
;        LcdSend( 0b01000000+shift, LCD_CMD ); 			//первая строка выше экрана, отображаем со второй
;#endif
;	    LcdSend( 0b10000000+Vop, LCD_CMD ); 			//Set LCD Vop (Contrast)
	LDS  R30,_Vop
	SUBI R30,-LOW(128)
	CALL SUBOPT_0x9
;#ifdef china
;	    LcdSend( 0x20|x_mirror<<5|y_mirror<<4|power_down<<3, LCD_CMD );			//LCD Standard Commands
;#endif
;#ifndef china
;        LcdSend( 0x20|power_down<<3|addressing<<2, LCD_CMD );				//LCD Standard Commands
	LDI  R26,0
	SBRC R2,1
	LDI  R26,1
	MOV  R30,R26
	LSL  R30
	LSL  R30
	LSL  R30
	ORI  R30,0x20
	MOV  R0,R30
	LDI  R26,0
	SBRC R2,2
	LDI  R26,1
	MOV  R30,R26
	LSL  R30
	LSL  R30
	OR   R30,R0
	CALL SUBOPT_0x9
;#endif
;        LcdSend( 0b00001000|((disp_config<<1|disp_config)&0b00000101), LCD_CMD ); 	//LCD mode
	LDS  R30,_disp_config
	LSL  R30
	LDS  R26,_disp_config
	OR   R30,R26
	ANDI R30,LOW(0x5)
	ORI  R30,8
	CALL SUBOPT_0x9
;        LcdClear();
	RCALL _LcdClear
;        }
	RET
;
;void LcdContrast (unsigned char contrast) 	//contrast -> Contrast value from 0x00 to 0x7F
;        {
;        if (contrast > 0x7F) return;
;	contrast -> Y+0
;        LcdSend( 0x21, LCD_CMD );               //LCD Extended Commands
;        LcdSend( 0x80 | contrast, LCD_CMD );    //Set LCD Vop (Contrast)
;        LcdSend( 0x20, LCD_CMD );               //LCD Standard Commands,Horizontal addressing mode
;        }
;
;void LcdMode (unsigned char mode) 		//режим дисплея: 0 - blank, 1 - all on, 2 - normal, 3 - inverse
;        {
;        if (mode > 3) return;
;	mode -> Y+0
;        LcdSend( 0b00001000|((mode<<1|mode)&0b00000101), LCD_CMD ); 	//LCD mode
;        }
;
; void LcdPwrMode (void) 				//инвертирует состояние вкл/выкл дисплея
;        {
;        power_down = ~power_down;
;        LcdSend( 0x20|power_down<<3, LCD_CMD );
;        }
;/*
;void LcdPwrMode (void) 				//инвертирует состояние вкл/выкл дисплея
;        {
;        power_down = ~power_down;
;        	#ifdef china
;	LcdSend( 0x20|x_mirror<<4|y_mirror<<3|power_down<<2|addressing<<1, LCD_CMD );			//LCD Standard Commands
;        	#elif
;        LcdSend( 0x20|0<<2|addressing<<1, LCD_CMD );
;                #endif
;        }
;
;void Lcd_off (void) 				//выкл дисплея
;        {
;        	#ifdef china
;	LcdSend( 0x20|x_mirror<<4|y_mirror<<3|1<<2|addressing<<1, LCD_CMD );			//LCD Standard Commands
;        	#elif
;        LcdSend( 0x20|1<<2|addressing<<1, LCD_CMD );
;                #endif
;        }
;
;void Lcd_on (void) 				//вкл дисплея
;        {
;        	#ifdef china
;	LcdSend( 0x20|x_mirror<<4|y_mirror<<3|0<<2|addressing<<1, LCD_CMD );			//LCD Standard Commands
;        	#elif
;        LcdSend( 0x20|0<<2|addressing<<1, LCD_CMD );
;                #endif
;        }   */
;
;
;
;void LcdImage (flash unsigned char *imageData)	//вывод изображения
;        {
_LcdImage:
;        unsigned int i;
;
;        LcdSend(0x80, LCD_CMD);		//ставим указатель на 0,0
	CALL SUBOPT_0x6
;	*imageData -> Y+2
;	i -> R16,R17
;        LcdSend(0x40, LCD_CMD);
;        for (i = 0; i < LCD_CACHSIZE; i++) LcdCache[i] = imageData[i];	//грузим данные
_0x45:
	__CPWRN 16,17,504
	BRSH _0x46
	MOVW R30,R16
	SUBI R30,LOW(-_LcdCache)
	SBCI R31,HIGH(-_LcdCache)
	MOVW R0,R30
	MOVW R30,R16
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADD  R30,R26
	ADC  R31,R27
	LPM  R30,Z
	MOVW R26,R0
	ST   X,R30
	__ADDWRN 16,17,1
	RJMP _0x45
_0x46:
_0x20C000F:
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,4
	RET
;
; void LcdImageRam (unsigned char *imageData)	//вывод изображения
;        {
;        unsigned int i;
;
;        LcdSend(0x80, LCD_CMD);		//ставим указатель на 0,0
;	*imageData -> Y+2
;	i -> R16,R17
;        LcdSend(0x40, LCD_CMD);
;        for (i = 0; i < LCD_CACHSIZE; i++) LcdCache[i] = imageData[i];	//грузим данные
;
;
;void LcdPixel (unsigned char x, unsigned char y, unsigned char mode)     //Displays a pixel at given absolute (x, y) location, mode -> Off, On or Xor
;        {
;        int index;
;        unsigned char offset, data;
;
;        if ( x > LCD_X_RES ) return;	//если передали в функцию муть - выходим
;	x -> Y+6
;	y -> Y+5
;	mode -> Y+4
;	index -> R16,R17
;	offset -> R19
;	data -> R18
;        if ( y > LCD_Y_RES ) return;
;
;        index = (((int)(y)/8)*84)+x;    //считаем номер байта в массиве памяти дисплея
;        offset  = y-((y/8)*8);          //считаем номер бита в этом байте
;
;        data = LcdCache[index];         //берем байт по найденному индексу
;
;        if ( mode == PIXEL_OFF ) data &= ( ~( 0x01 << offset ) );	//редактируем бит в этом байте
;                else if ( mode == PIXEL_ON ) data |= ( 0x01 << offset );
;                        else if ( mode  == PIXEL_XOR ) data ^= ( 0x01 << offset );
;
;        LcdCache[index] = data;		//загружаем байт назад
;        }
;
;void LcdLine (int x1, int y1, int x2, int y2, unsigned char mode)  	//Draws a line between two points on the display - по Брезенхейму
;        {
;        signed int dy = 0;
;        signed int dx = 0;
;        signed int stepx = 0;
;        signed int stepy = 0;
;        signed int fraction = 0;
;
;        if (x1>LCD_X_RES || x2>LCD_X_RES || y1>LCD_Y_RES || y2>LCD_Y_RES) return;
;	x1 -> Y+17
;	y1 -> Y+15
;	x2 -> Y+13
;	y2 -> Y+11
;	mode -> Y+10
;	dy -> R16,R17
;	dx -> R18,R19
;	stepx -> R20,R21
;	stepy -> Y+8
;	fraction -> Y+6
;
;        dy = y2 - y1;
;        dx = x2 - x1;
;        if (dy < 0)
;                {
;                dy = -dy;
;                stepy = -1;
;                }
;                else stepy = 1;
;        if (dx < 0)
;                {
;                dx = -dx;
;                stepx = -1;
;                }
;                else stepx = 1;
;        dy <<= 1;
;        dx <<= 1;
;        LcdPixel(x1,y1,mode);
;        if (dx > dy)
;                {
;                fraction = dy - (dx >> 1);
;                while (x1 != x2)
;                   {
;                        if (fraction >= 0)
;                                {
;                                y1 += stepy;
;                                fraction -= dx;
;                                }
;                        x1 += stepx;
;                        fraction += dy;
;                        LcdPixel(x1,y1,mode);
;                   }
;                }
;                else
;                        {
;                        fraction = dx - (dy >> 1);
;                        while (y1 != y2)
;                                {
;                                if (fraction >= 0)
;                                        {
;                                        x1 += stepx;
;                                        fraction -= dy;
;                                        }
;                                y1 += stepy;
;                                fraction += dx;
;                                LcdPixel(x1,y1,mode);
;                                }
;                        }
;        }
;
;#warning Upd-7 not tested!
;// Set the base address of the lcd
;void lcd_base_addr(unsigned int addr) {   //Upd-7
;	LcdSend(0x80 |(addr % LCD_X_RES), LCD_CMD);
;	addr -> Y+0
;	LcdSend(0x40 |(addr / LCD_X_RES), LCD_CMD);
;}
;
;/* Clears an area on a line */    //Upd-7
;/*
;void lcd_clear_area(unsigned char line, unsigned char startX, unsigned char endX)
;{
;    // Start and end positions of line
;    int start = (line-1)*84+(startX-1);
;    int end = (line-1)*84+(endX-1);
;
;	lcd_base_addr(start);
;
;    // Clear all data in range from cache
;    for(uint16_t i=start;i<end;i++) {
;       LcdSend(0, LCD_DATA);
;    }
;}  */
;
;/*
; * Имя : LcdRect
; * Описание : Рисует незакрашенный прямоугольник
; * Аргумент(ы) : x1 -> абсолютная координата x левого верхнего угла
; * y1 -> абсолютная координата y левого верхнего угла
; * x2 -> абсолютная координата x правого нижнего угла
; * y2 -> абсолютная координата y правого нижнего угла
; * mode -> Off, On или Xor. Смотри enum в n3310.h
; * Возвращаемое значение : смотри возвращаемое значение в n3310lcd.h
; */
;
; /*
;byte LcdRect ( byte x1, byte y1, byte x2, byte y2, LcdPixelMode mode )    //not tested!
;{
;byte tmpIdx;
;
;// Проверка границ
;if ( ( x1 >= LCD_X_RES) || ( x2 >= LCD_X_RES) || ( y1 >= LCD_Y_RES) || ( y2 >= LCD_Y_RES) )
;return OUT_OF_BORDER;
;
;if ( ( x2 > x1 ) && ( y2 > y1 ) )
;{
;// Рисуем горизонтальные линии
;for ( tmpIdx = x1; tmpIdx <= x2; tmpIdx++ )
;{
;LcdPixel( tmpIdx, y1, mode );
;LcdPixel( tmpIdx, y2, mode );
;}
;
;// Рисуем вертикальные линии
;for ( tmpIdx = y1; tmpIdx <= y2; tmpIdx++ )
;{
;LcdPixel( x1, tmpIdx, mode );
;LcdPixel( x2, tmpIdx, mode );
;}
;
;// Установка флага изменений кэша
;UpdateLcd = TRUE;
;}
;return OK;
;}
;
;
;*/
;
;void LcdCircle(char x, char y, char radius, unsigned char mode)		//рисуем круг по координатам с радиусом - по Брезенхейму
;        {
;        signed char xc = 0;
;        signed char yc = 0;
;        signed char p = 0;
;
;        if (x>LCD_X_RES || y>LCD_Y_RES) return;
;	x -> Y+7
;	y -> Y+6
;	radius -> Y+5
;	mode -> Y+4
;	xc -> R17
;	yc -> R16
;	p -> R19
;
;        yc=radius;
;        p = 3 - (radius<<1);
;        while (xc <= yc)
;                {
;                LcdPixel(x + xc, y + yc, mode);
;                LcdPixel(x + xc, y - yc, mode);
;                LcdPixel(x - xc, y + yc, mode);
;                LcdPixel(x - xc, y - yc, mode);
;                LcdPixel(x + yc, y + xc, mode);
;                LcdPixel(x + yc, y - xc, mode);
;                LcdPixel(x - yc, y + xc, mode);
;                LcdPixel(x - yc, y - xc, mode);
;                if (p < 0) p += (xc++ << 2) + 6;
;                        else p += ((xc++ - yc--)<<2) + 10;
;                }
;        }
;
;void LcdBatt(int x1, int y1, int x2, int y2, unsigned char persent)	//рисуем батарейку с заполнением в %
;        {
;        unsigned char horizon_line,horizon_line2,i;
;        if(persent>100)return;
;	x1 -> Y+11
;	y1 -> Y+9
;	x2 -> Y+7
;	y2 -> Y+5
;	persent -> Y+4
;	horizon_line -> R17
;	horizon_line2 -> R16
;	i -> R19
;        LcdLine(x1,y2,x2,y2,1);  //down
;        LcdLine(x2,y1,x2,y2,1);  //right
;	LcdLine(x1,y1,x1,y2,1);  //left
;	LcdLine(x1,y1,x2,y1,1);  //up
;	LcdLine(x1+7,y1-1,x2-7,y1-1,1);
;	LcdLine(x1+7,y1-2,x2-7,y1-2,1);
;
;        horizon_line=persent*(y2-y1-3)/100;
;        for(i=0;i<horizon_line;i++) LcdLine(x1+2,y2-2-i,x2-2,y2-2-i,1);
;        for(i=horizon_line2;i>horizon_line;i--) LcdLine(x1+2,y2-2-i,x2-2,y2-2-i,0);
;
;void LcdBar(int x1, int y1, int x2, int y2, unsigned char persent)	//рисуем прогресс-бар
;        {
;        unsigned char line;
;        if(persent>100)return;
;	x1 -> Y+8
;	y1 -> Y+6
;	x2 -> Y+4
;	y2 -> Y+2
;	persent -> Y+1
;	line -> R17
;        LcdLine(x1+2,y2,x2-2,y2,1);  //down
;        LcdLine(x2-2,y1,x2-2,y2,1);  //right
;	LcdLine(x1+2,y1,x1+2,y2,1);  //left
;	LcdLine(x1+2,y1,x2-2,y1,1);  //up
;
;        LcdLine(x2-1,y1+1,x2-1,y2-1,1);  //right
;	LcdLine(x1+1,y1+1,x1+1,y2-1,1);  //left
;
;        LcdLine(x2,y1+2,x2,y2-2,1);  //right
;	LcdLine(x1,y1+2,x1,y2-2,1);  //left
;
;        line=persent*(x2-x1-7)/100-1;
;        LcdLine(x1+4,y1+2,x2-4,y2-2,0);
;        LcdLine(x1+4,y1+2,x1+4+line,y2-2,1);
;	}
;
;void LcdBarLine(unsigned char line, unsigned char persent)	//рисуем прошресс-бар
;        {
;        LcdBar(0, (line-1)*7+1, 83, (line-1)*7+5, persent);
;	line -> Y+1
;	persent -> Y+0
;        }
;
;void LcdGotoXYFont (unsigned char x, unsigned char y)   //Sets cursor location to xy location. Range: 1,1 .. 14,6
;        {
_LcdGotoXYFont:
;        if (x <= 14 && y <= 6) LcdCacheIdx = ( (int)(y) - 1 ) * 84 + ( (int)(x) - 1 ) * 6;
;	x -> Y+1
;	y -> Y+0
	LDD  R26,Y+1
	CPI  R26,LOW(0xF)
	BRSH _0x73
	LD   R26,Y
	CPI  R26,LOW(0x7)
	BRLO _0x74
_0x73:
	RJMP _0x72
_0x74:
	LD   R30,Y
	LDI  R31,0
	SBIW R30,1
	LDI  R26,LOW(84)
	LDI  R27,HIGH(84)
	CALL __MULW12
	MOVW R22,R30
	LDD  R30,Y+1
	LDI  R31,0
	SBIW R30,1
	LDI  R26,LOW(6)
	LDI  R27,HIGH(6)
	CALL __MULW12
	ADD  R30,R22
	ADC  R31,R23
	STS  _LcdCacheIdx,R30
	STS  _LcdCacheIdx+1,R31
;        }
_0x72:
_0x20C000E:
	ADIW R28,2
	RET
;
;void LcdTextBufClean (void)	//очистка текстового буфера
;	{
_LcdTextBufClean:
;	char i;
;	for (i=0; i<14; i++) lcd_buf[i] = 0;
	ST   -Y,R17
;	i -> R17
	LDI  R17,LOW(0)
_0x76:
	CPI  R17,14
	BRSH _0x77
	CALL SUBOPT_0xA
	SUBI R30,LOW(-_lcd_buf)
	SBCI R31,HIGH(-_lcd_buf)
	LDI  R26,LOW(0)
	STD  Z+0,R26
	SUBI R17,-1
	RJMP _0x76
_0x77:
	LD   R17,Y+
	RET
;
;void LcdChr (int ch)	//Displays a character at current cursor location and increment cursor location
; 	{
_LcdChr:
;     	unsigned char i;
;
;        for ( i = 0; i < 5; i++ ) LcdCache[LcdCacheIdx++] = table[(ch*5+i)];	//выделяем байт-столбик из символа и грузим в массив - 5 раз
	ST   -Y,R17
;	ch -> Y+1
;	i -> R17
	LDI  R17,LOW(0)
_0x79:
	CPI  R17,5
	BRSH _0x7A
	CALL SUBOPT_0xB
	MOVW R22,R30
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	LDI  R26,LOW(5)
	LDI  R27,HIGH(5)
	CALL __MULW12
	MOVW R26,R30
	CALL SUBOPT_0xA
	ADD  R30,R26
	ADC  R31,R27
	SUBI R30,LOW(-_table*2)
	SBCI R31,HIGH(-_table*2)
	LPM  R30,Z
	MOVW R26,R22
	ST   X,R30
	SUBI R17,-1
	RJMP _0x79
_0x7A:
	CALL SUBOPT_0xB
	LDI  R26,LOW(0)
	STD  Z+0,R26
; 	}
	LDD  R17,Y+0
	RJMP _0x20C000C
;
;void LcdChrInv (int ch)	//Displays a character at current cursor location and increment cursor location
; 	{
;     	unsigned char i;
;
;        for ( i = 0; i < 5; i++ ) LcdCache[LcdCacheIdx++] = ~(table[(ch*5+i)]);	//выделяем байт-столбик из символа и грузим в массив - 5 раз
;	ch -> Y+1
;	i -> R17
; 	}
;
;void LcdString (unsigned char x, unsigned char y)	//Displays a string at current cursor location
;	{
_LcdString:
;	unsigned char i;
;
;	if (x > 14 || y > 6) return;
	ST   -Y,R17
;	x -> Y+2
;	y -> Y+1
;	i -> R17
	LDD  R26,Y+2
	CPI  R26,LOW(0xF)
	BRSH _0x7F
	LDD  R26,Y+1
	CPI  R26,LOW(0x7)
	BRLO _0x7E
_0x7F:
	LDD  R17,Y+0
	RJMP _0x20C000C
;	LcdGotoXYFont (x, y);
_0x7E:
	LDD  R30,Y+2
	ST   -Y,R30
	LDD  R30,Y+2
	ST   -Y,R30
	RCALL _LcdGotoXYFont
;	for ( i = 0; i < 15-x; i++ ) if (lcd_buf[i]) LcdChr (lcd_buf[i]);
	LDI  R17,LOW(0)
_0x82:
	LDD  R26,Y+2
	LDI  R30,LOW(15)
	SUB  R30,R26
	CP   R17,R30
	BRSH _0x83
	CALL SUBOPT_0xA
	SUBI R30,LOW(-_lcd_buf)
	SBCI R31,HIGH(-_lcd_buf)
	LD   R30,Z
	CPI  R30,0
	BREQ _0x84
	CALL SUBOPT_0xA
	SUBI R30,LOW(-_lcd_buf)
	SBCI R31,HIGH(-_lcd_buf)
	CALL SUBOPT_0xC
	RCALL _LcdChr
;	LcdTextBufClean();
_0x84:
	SUBI R17,-1
	RJMP _0x82
_0x83:
	RCALL _LcdTextBufClean
;	}
	LDD  R17,Y+0
	RJMP _0x20C000C
;
;void LcdStringInv (unsigned char x, unsigned char y)	//Displays a string at current cursor location
;	{
;	unsigned char i;
;
;	if (x > 14 || y > 6) return;
;	x -> Y+2
;	y -> Y+1
;	i -> R17
;	LcdGotoXYFont (x, y);
;	for ( i = 0; i < 15-x; i++ ) if (lcd_buf[i]) LcdChrInv (lcd_buf[i]);
;	LcdTextBufClean();
;	}
;
;void LcdChrBold (int ch)	//Displays a bold character at current cursor location and increment cursor location
; 	{
;     	unsigned char i;
;     	unsigned char a = 0, b = 0, c = 0;
;
;     	for ( i = 0; i < 5; i++ )
;	ch -> Y+4
;	i -> R17
;	a -> R16
;	b -> R19
;	c -> R18
;     	        {
;     	        c = table[(ch*5+i)];		//выделяем столбец из символа
;
;     	        b =  (c & 0x01) * 3;            //"растягиваем" столбец на два байта
;              	b |= (c & 0x02) * 6;
;              	b |= (c & 0x04) * 12;
;              	b |= (c & 0x08) * 24;
;
;              	c >>= 4;
;              	a =  (c & 0x01) * 3;
;              	a |= (c & 0x02) * 6;
;              	a |= (c & 0x04) * 12;
;              	a |= (c & 0x08) * 24;
;
;     	        LcdCache[LcdCacheIdx] = b;	//копируем байты в экранный буфер
;     	        LcdCache[LcdCacheIdx+1] = b;    //дублируем для получения жирного шрифта
;     	        LcdCache[LcdCacheIdx+84] = a;
;     	        LcdCache[LcdCacheIdx+85] = a;
;     	        LcdCacheIdx = LcdCacheIdx+2;
;     	        }
;
;     	LcdCache[LcdCacheIdx++] = 0x00;	//для пробела между символами
;     	LcdCache[LcdCacheIdx++] = 0x00;
; 	}
;
;void LcdStringBold (unsigned char x, unsigned char y)	//Displays a string at current cursor location
;	{
;	unsigned char i;
;
;	if (x > 13 || y > 5) return;
;	x -> Y+2
;	y -> Y+1
;	i -> R17
;	LcdGotoXYFont (x, y);
;	for ( i = 0; i < 14-x; i++ ) if (lcd_buf[i]) LcdChrBold (lcd_buf[i]);
;	LcdTextBufClean();
;	}
;
;void LcdChrBig (int ch)	//Displays a character at current cursor location and increment cursor location
; 	{
;     	unsigned char i;
;     	unsigned char a = 0, b = 0, c = 0;
;
;     	for ( i = 0; i < 5; i++ )
;	ch -> Y+4
;	i -> R17
;	a -> R16
;	b -> R19
;	c -> R18
;     	        {
;     	        c = table[(ch*5+i)];		//выделяем столбец из символа
;
;     	        b =  (c & 0x01) * 3;            //"растягиваем" столбец на два байта
;              	b |= (c & 0x02) * 6;
;              	b |= (c & 0x04) * 12;
;              	b |= (c & 0x08) * 24;
;
;              	c >>= 4;
;              	a =  (c & 0x01) * 3;
;              	a |= (c & 0x02) * 6;
;              	a |= (c & 0x04) * 12;
;              	a |= (c & 0x08) * 24;
;     	        LcdCache[LcdCacheIdx] = b;
;     	        LcdCache[LcdCacheIdx+84] = a;
;     	        LcdCacheIdx = LcdCacheIdx+1;
;     	        }
;
;     	LcdCache[LcdCacheIdx++] = 0x00;
;     	}
;
;void LcdStringBig (unsigned char x, unsigned char y)	//Displays a string at current cursor location
;	{
;	unsigned char i;
;
;	if (x > 14 || y > 5) return;
;	x -> Y+2
;	y -> Y+1
;	i -> R17
;	LcdGotoXYFont (x, y);
;	for ( i = 0; i < 15-x; i++ ) if (lcd_buf[i]) LcdChrBig (lcd_buf[i]);
;	LcdTextBufClean();
;	}
;
;#pragma used-
;// картинки для 3310
;
;/*
;  flash unsigned char waitImage[] = {
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x20,0x20,
;  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0xF0,0x10,0x10,0x10,0x10,0xE0,0x00,0x00,0xF0,0x00,0x00,0x80,0x40,0x40,
;  0x40,0x80,0x00,0x00,0x80,0x40,0x40,0x40,0x80,0x00,0x00,0x80,0x40,0x40,0x40,0x80,
;  0x00,0x00,0x80,0x40,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x0F,0x11,0x31,0x31,0xD1,0xF1,0xD1,0xD1,0x31,0x11,0x11,0x0F,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x1F,0x00,
;  0x00,0x0F,0x12,0x12,0x12,0x0B,0x00,0x00,0x0C,0x12,0x12,0x0A,0x1F,0x00,0x00,0x09,
;  0x12,0x12,0x12,0x0C,0x00,0x00,0x0F,0x12,0x12,0x12,0x0B,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0xF0,0x18,0x86,0x86,0xE1,0xF1,0xE1,0xE1,0x86,0x18,0x18,
;  0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x80,0x00,0x80,
;  0x60,0x80,0x00,0x80,0x60,0x00,0x40,0x20,0x20,0x20,0xC0,0x00,0x00,0xE8,0x00,0x20,
;  0xF8,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x07,0x07,0x07,0x07,0x07,
;  0x07,0x07,0x07,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x03,0x0C,0x03,0x00,0x03,0x0C,0x03,0x00,0x00,0x06,0x09,0x09,0x05,0x0F,0x00,
;  0x00,0x0F,0x00,0x00,0x0F,0x08,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x08,0x00,0x00,
;  0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
;  };
;  */
;
;/*
; flash unsigned char rad1Image[] = {	// простая
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
; 0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE,
; 0xFE,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFE,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x40,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x0F,0x03,0x01,0xF0,0xF8,0xFC,0xFC,0xFE,
; 0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF0,0x01,0x03,0x0F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE1,
; 0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F,0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
; 0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,
; 0x0E,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
;
; */
; /*
; flash unsigned char rad1Image[] = {
;  12,  0,  1,128,  1,192,  1,224,  1,240,  2,248,
;  2,252,  2,254,  2,255,  1,254,  1,252,  1,248,
;  1,240,  1,224,  1,192,  1,128, 22,  0,  1,128,
;  1,192,  1,224,  1,240,  1,248,  1,252,  1,254,
;  2,255,  3,254,  1,252,  2,248,  1,240,  1,224,
;  1,192,  1,128, 20,  0,  1,224,  1,248,  1,254,
; 21,255,  1,254,  1,252,  1,248,  1,240,  1,224,
;  1, 64,  8,  0,  1, 64,  1,224,  1,240,  1,248,
;  1,252,  1,254, 21,255,  1,254,  1,248,  1,224,
; 14,  0,  1,120, 25,127,  1, 15,  1,  3,  1,  1,
;  1,240,  1,248,  2,252,  6,254,  2,252,  1,248,
;  1,240,  1,  1,  1,  3,  1, 15, 25,127,  1,120,
; 39,  0,  1,128,  1,192,  1,225,  1,227,  1,231,
;  1,199,  1,207,  4,143,  1,207,  1,199,  1,231,
;  1,227,  1,225,  1,192,  1,128, 58,  0,  1,128,
;  1,192,  1,224,  1,240,  1,248,  1,252,  1,254,
; 20,255,  1,254,  1,252,  1,248,  1,240,  1,224,
;  1,192,  1,128, 47,  0,  1, 12,  1, 14,  3, 31,
;  4, 63,  3,127, 16,255,  3,127,  4, 63,  3, 31,
;  1, 14,  1, 12, 22,  0};  */
;
;  unsigned char rad1Image[] = {
;  12,  0,  1,128,  1,192,  1,224,  1,240,  2,248,
;  2,252,  2,254,  2,255,  1,254,  1,252,  1,248,
;  1,240,  1,224,  1,192,  1,128, 22,  0,  1,128,
;  1,192,  1,224,  1,240,  1,248,  1,252,  1,254,
;  2,255,  3,254,  1,252,  2,248,  1,240,  1,224,
;  1,192,  1,128, 20,  0,  1,224,  1,248,  1,254,
; 21,255,  1,254,  1,252,  1,248,  1,240,  1,224,
;  1, 64,  8,  0,  1, 64,  1,224,  1,240,  1,248,
;  1,252,  1,254, 21,255,  1,254,  1,248,  1,224,
; 14,  0,  1,120, 25,127,  1, 15,  1,  3,  1,  1,
;  1,240,  1,248,  2,252,  6,254,  2,252,  1,248,
;  1,240,  1,  1,  1,  3,  1, 15, 25,127,  1,120,
; 39,  0,  1,128,  1,192,  1,225,  1,227,  1,231,
;  1,199,  1,207,  4,143,  1,207,  1,199,  1,231,
;  1,227,  1,225,  1,192,  1,128, 58,  0,  1,128,
;  1,192,  1,224,  1,240,  1,248,  1,252,  1,254,
; 20,255,  1,254,  1,252,  1,248,  1,240,  1,224,
;  1,192,  1,128, 47,  0,  1, 12,  1, 14,  3, 31,
;  4, 63,  3,127, 16,255,  3,127,  4, 63,  3, 31,
;  1, 14,  1, 12, 22,  0};

	.DSEG
;
;
;
;
;
; flash unsigned char rad2Image[] = {	// простая+копирайт
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
; 0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE,
; 0xFC,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFE,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x40,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x0F,0x03,0x01,0xF0,0xF8,0xFC,0xFC,0xFE,
; 0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF0,0x01,0x03,0x0F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE1,
; 0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F,0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x70,0x88,0x70,0x50,0x88,0x70,0x00,0xC8,0xA8,0x90,0x00,0x70,
; 0x88,0x70,0x00,0x10,0xF8,0x00,0x70,0x88,0x70,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
; 0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,
; 0x0E,0x0C,0x00,0x00,0x00,0xF0,0x28,0xF0,0x00,0xF8,0x20,0xF8,0x00,0xF8,0xA8,0x88,
; 0x00,0x88,0xF8,0x88,0x00,0xF8,0x48,0xB0};
;
;/*
;flash unsigned char rad3Image[] = {	 //простая+копирайт+abc
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
;0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
;0x00,0x00,0x00,0x00,0x00,0xC0,0x20,0x20,0x20,0x40,0x80,0x40,0x20,0x10,0x0C,0x00,
;0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE,
;0xFC,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFE,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x41,0x02,0x02,0x02,0x01,0x00,0x01,
;0x02,0x02,0x41,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x7F,
;0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
;0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x0F,0x03,0x01,0xF0,0xF8,0xFC,0xFC,0xFE,
;0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF0,0x01,0x03,0x0F,0x7F,0x7F,0x7F,0x7F,
;0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
;0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0xF8,0x24,0x24,0x58,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE1,
;0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F,0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x30,0xC0,0xC0,0x30,0x0C,0x02,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x08,0x10,0x10,0x0F,0x02,0x04,0x84,0xC3,0xE0,0xF0,0xF8,0xFC,0xFE,
;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x0F,0x10,0x10,0x0F,0x00,
;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
;0x00,0x00,0x00,0x00,0x70,0x88,0x70,0x50,0x88,0x70,0x00,0xC8,0xA8,0x90,0x00,0x70,
;0x88,0x70,0x00,0x10,0xF8,0x00,0x10,0xF8,0x00,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
; 0x88,0x70,0x00,0x10,0xF8,0x00,0x70,0x88,0x70,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
;0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
;0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,
;0x0E,0x0C,0x00,0x00,0x00,0xF0,0x28,0xF0,0x00,0xF8,0x20,0xF8,0x00,0xF8,0xA8,0x88,
;0x00,0x88,0xF8,0x88,0x00,0xF8,0x48,0xB0};
;
; flash unsigned char rad4Image[] = {	// простая+копирайт+abc(инв)
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,
; 0xF8,0xF8,0xFC,0xFC,0xFE,0xFE,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFE,0xFE,
; 0xFC,0xFC,0xF8,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xFE,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0xEF,0xEF,0xEF,0x5F,0xBF,0x5F,0xEF,0xF7,0x79,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0x40,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x40,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
; 0xFB,0x67,0x9F,0x9F,0x67,0xF9,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xF8,0xE0,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7E,0x7E,0x7E,0x7F,0x7F,0x7F,
; 0x7E,0x7E,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x0F,0x03,0x01,0xF0,0xF8,0xFC,0xFC,0xFE,
; 0xFE,0xFE,0xFE,0xFE,0xFE,0xFC,0xFC,0xF8,0xF0,0x01,0x03,0x0F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x77,0x77,0x78,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,0x7F,
; 0x7F,0x7F,0x7F,0x7F,0x7F,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE1,
; 0xE3,0xE7,0xC7,0xCF,0x8F,0x8F,0x8F,0x8F,0xCF,0xC7,0xE7,0xE3,0xE1,0xC0,0x80,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,
; 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0xDB,0xDB,0xA7,0x7F,0xFF,0xFF,
; 0xFF,0xFF,0xFF,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 0x00,0x00,0x00,0x00,0x70,0x88,0x70,0x50,0x88,0x70,0x00,0xC8,0xA8,0x90,0x00,0x70,
; 0x88,0x70,0x00,0x10,0xF8,0x00,0x70,0x88,0x70,0x00,0x0C,0x0E,0x1F,0x1F,0x1F,0x3F,
; 0x3F,0x3F,0x3F,0x7F,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xF7,0xEF,0xEF,0xF0,0xFD,0xFB,
; 0xFB,0xFC,0xFF,0xFF,0xFF,0xFF,0x7F,0x7F,0x7F,0x3F,0x3F,0x3F,0x3F,0x1F,0x1F,0x1F,
; 0x0E,0x0C,0x00,0x00,0x00,0xF0,0x28,0xF0,0x00,0xF8,0x20,0xF8,0x00,0xF8,0xA8,0x88,
; 0x00,0x88,0xF8,0x88,0x00,0xF8,0x48,0xB0};
;
;
; flash unsigned char mini_WIN[504] =
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x80, 0x80, 0xC0, 0xE0, 0xE0, 0xE0, 0xE0, 0xF0, 0x70,
;  0x70, 0x38, 0x38, 0x38, 0x38, 0x18, 0x18, 0x18, 0x1C, 0x1C, 0x1C, 0x1C,
;  0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C,
;  0x1C, 0x1C, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x38, 0x38, 0x38, 0x79, 0x70,
;  0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0xE0, 0xF0, 0xF8, 0x7C, 0x3E,
;  0x1F, 0x0F, 0x07, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0xC0, 0xE0, 0xF8, 0xF8, 0xF8, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
;  0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0x38, 0x10, 0x80, 0xC0,
;  0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
;  0xC0, 0xC0, 0xC0, 0xC1, 0xC1, 0x61, 0x23, 0x03, 0x07, 0x0F, 0x1F, 0x3E,
;  0x7E, 0x7C, 0xF8, 0xF0, 0xE0, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x03, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xEC,
;  0xE6, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7, 0xF7,
;  0xE7, 0xE7, 0xE7, 0xCF, 0x0F, 0x0F, 0x83, 0x81, 0x9C, 0x3E, 0x3F, 0x7F,
;  0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x3F,
;  0xBF, 0x1F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x3F, 0x7F, 0xFF, 0xFC, 0xF0, 0xE0,
;  0xC0, 0x80, 0x00, 0x00, 0x00, 0x30, 0x38, 0x1E, 0x1F, 0x1F, 0x1F, 0x1F,
;  0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F,
;  0x0F, 0x07, 0x41, 0xF0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x03,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0,
;  0xE0, 0xF0, 0xFE, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03,
;  0x07, 0x0F, 0x0F, 0x1E, 0x1E, 0x3C, 0x3C, 0x38, 0x38, 0x70, 0x70, 0xF0,
;  0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x80, 0x80,
;  0x80, 0x80, 0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
;  0x81, 0x81, 0x81, 0xC1, 0xC1, 0xC1, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xF0,
;  0x70, 0x70, 0x78, 0x38, 0x38, 0x3C, 0x3C, 0x1E, 0x0E, 0x0F, 0x07, 0x07,
;  0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0xF0, 0x10, 0x20, 0x11, 0xF1, 0x01, 0x01, 0xE9, 0x01, 0x03,
;  0xE3, 0x23, 0xE3, 0x03, 0x03, 0xEB, 0x03, 0x03, 0x03, 0x13, 0x23, 0x43,
;  0x83, 0x41, 0x21, 0x41, 0x81, 0x41, 0x21, 0x10, 0x00, 0x00, 0xE8, 0x00,
;  0x00, 0xE0, 0x20, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;
; static const char psydion [504]  =       //псайдион
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x80, 0x80, 0xC0, 0xC0, 0xE0, 0x60, 0x70, 0x30, 0x30, 0x18, 0x18, 0x18,
;  0x0C, 0x2C, 0x2C, 0x2C, 0x2C, 0xE6, 0xE6, 0xE6, 0xC6, 0x02, 0x02, 0x02,
;  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
;  0x02, 0x02, 0xC2, 0xE6, 0xE6, 0xE6, 0x26, 0x2C, 0x2C, 0x2C, 0x0C, 0x08,
;  0x18, 0x18, 0x18, 0x30, 0x30, 0x70, 0x60, 0xE0, 0xC0, 0xC0, 0x80, 0x80,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x80, 0xC0, 0xF0, 0x38, 0x1C, 0x8C, 0x0E, 0x06, 0x07,
;  0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x7F, 0x78, 0x60, 0x40,
;  0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0x40,
;  0x60, 0x78, 0x7F, 0x3F, 0x1F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03,
;  0x07, 0x06, 0x8E, 0x1C, 0x38, 0x78, 0xF0, 0xC0, 0x80, 0x00, 0x00, 0x00,
;  0x00, 0xF8, 0xFE, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x07, 0x06, 0x06, 0x0E,
;  0x0E, 0xEE, 0xEE, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0x8C, 0x9C, 0xF8,
;  0xF0, 0xC0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
;  0x80, 0xC0, 0xE0, 0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0xE0, 0xC0, 0x80, 0x80,
;  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xE0, 0xF8, 0xB8,
;  0x9C, 0x8C, 0x8E, 0x8E, 0x8E, 0x8E, 0x8E, 0xEE, 0xEE, 0x0E, 0x0E, 0x0E,
;  0x06, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1F, 0xFE, 0xF8, 0x00,
;  0x00, 0x3F, 0xFF, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xE0, 0xE0,
;  0xE0, 0xEF, 0xEF, 0xE3, 0xE3, 0xE3, 0xE3, 0x63, 0x73, 0x73, 0x3B, 0x3F,
;  0x1F, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
;  0x03, 0x07, 0x0F, 0xFF, 0xFD, 0xFE, 0xFD, 0xFF, 0x0F, 0x07, 0x03, 0x03,
;  0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0F, 0x1F, 0x3B,
;  0x73, 0x73, 0x63, 0x63, 0xE3, 0xE3, 0xE3, 0xEF, 0xEF, 0xE0, 0xE0, 0xE0,
;  0xE0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0xFF, 0x3F, 0x00,
;  0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x18, 0x30, 0x33, 0x60, 0xE0, 0xC0,
;  0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF8, 0xFC, 0xFC, 0x1C, 0x0E, 0x06,
;  0x86, 0x86, 0x86, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x86, 0x86, 0x86, 0x06,
;  0x0E, 0x1C, 0xFC, 0xF8, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0,
;  0xC0, 0xE0, 0x73, 0x38, 0x38, 0x1E, 0x0F, 0x07, 0x01, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x01, 0x03, 0x03, 0x07, 0x06, 0x0E, 0x0C, 0x0C, 0x18, 0x18, 0x38, 0x30,
;  0x20, 0x28, 0x28, 0x68, 0x6C, 0x6F, 0x6F, 0x67, 0x43, 0xC0, 0xC0, 0xC0,
;  0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC0,
;  0xC0, 0xC0, 0xC3, 0x47, 0x6F, 0x6F, 0x6C, 0x68, 0x68, 0x28, 0x20, 0x30,
;  0x30, 0x38, 0x18, 0x18, 0x0C, 0x0C, 0x0E, 0x06, 0x07, 0x03, 0x03, 0x01,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;  static const char psy[504] =                      // буква  псай
;{ 0x00, 0x00, 0x00, 0x30, 0x30, 0x30, 0x70, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
;  0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0xF0, 0xF0,
;  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
;  0xF0, 0xF0, 0xF0, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xC0, 0xE0, 0xE0,
;  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x70, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF,
;  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0xF0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F,
;  0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xF0, 0xE0,
;  0xC0, 0xC0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0xC0,
;  0xC0, 0xE0, 0xF0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F,
;  0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x07, 0x07,
;  0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
;  0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
;  0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E,
;  0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
;  0x1F, 0x1E, 0x1E, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;  static const char owl[504] =                 //сова
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0xF2, 0x9E, 0x5C,
;  0xDC, 0xFC, 0xF8, 0x38, 0x08, 0xC0, 0xF0, 0xC0, 0x08, 0x38, 0xF8, 0xFC,
;  0xDC, 0x5C, 0x9E, 0xF2, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x7E, 0xE6, 0xDE, 0xBF, 0x77, 0xB3,
;  0x9F, 0xFF, 0xC7, 0x82, 0x00, 0x20, 0x71, 0x20, 0x00, 0x82, 0xC7, 0xFF,
;  0x9F, 0xB3, 0x77, 0xBF, 0xDE, 0xE6, 0x7E, 0x3C, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x02,
;  0x05, 0x01, 0x04, 0x6F, 0x3E, 0x0E, 0x7C, 0x0E, 0x3E, 0x6F, 0x04, 0x01,
;  0x05, 0x02, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x08, 0x0C, 0x0E, 0x0E, 0x0E, 0x0E, 0x1E, 0x1F, 0x1F, 0x3F,
;  0x3F, 0x3F, 0x37, 0x7B, 0xFB, 0x86, 0xFE, 0xEE, 0xE6, 0x3E, 0xCE, 0xFE,
;  0xBC, 0xCC, 0xFC, 0xF8, 0xF8, 0xF0, 0xE0, 0x01, 0x39, 0xF9, 0xFF, 0xCF,
;  0xAE, 0xEE, 0xFC, 0x7C, 0x00, 0x60, 0xF8, 0x60, 0x00, 0x7C, 0xFC, 0xEE,
;  0xAE, 0xCF, 0xFF, 0xF9, 0x39, 0x01, 0xE0, 0xF0, 0xF8, 0xF8, 0xFC, 0xCC,
;  0xBC, 0xFE, 0xCE, 0x3E, 0xE6, 0xEE, 0xFE, 0x86, 0xFB, 0x7B, 0x37, 0x3F,
;  0x3F, 0x3F, 0x1F, 0x1F, 0x1E, 0x0E, 0x0E, 0x0E, 0x0E, 0x0C, 0x08, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x07, 0x01, 0x0F,
;  0x0F, 0x0B, 0x0D, 0x0E, 0x1E, 0x1F, 0x1F, 0x1F, 0x38, 0x07, 0x37, 0x75,
;  0xDB, 0xBF, 0xE7, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xE7, 0xBF,
;  0xDB, 0x75, 0x37, 0x07, 0x38, 0x1F, 0x1F, 0x1F, 0x1E, 0x0E, 0x0D, 0x0B,
;  0x0F, 0x0F, 0x01, 0x07, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x01, 0x63, 0x73, 0x3F, 0xE7, 0xF7, 0x1E, 0xF7, 0xE7, 0x3F, 0x73, 0x63,
;  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;static const char BattFull[504] =
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x42, 0x5A,
;  0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x5A, 0x42, 0x7E, 0x3C,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;
;  static const char bell[504] =
;{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x80, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF8, 0xF8,
;  0xF8, 0x78, 0x7C, 0x7C, 0x7C, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x1E,
;  0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E, 0x1E,
;  0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x7C, 0x7C, 0x7C, 0xF8, 0xF8, 0xF8,
;  0xF8, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF,
;  0x7F, 0x7F, 0x1F, 0x1F, 0x0F, 0x07, 0x07, 0x03, 0x01, 0x01, 0x01, 0x00,
;  0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
;  0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xF0, 0xF0,
;  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x00,
;  0x01, 0x03, 0x03, 0x07, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0xFF, 0xFE,
;  0xFC, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0xC0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x01, 0x01,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
;  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x03, 0x01, 0x01, 0x01, 0x01,
;  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
;  0x01, 0x01, 0x03, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
;  0x07, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0xC0, 0x00, 0x00,
;  0x00, 0x07, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x80,
;  0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFF, 0xFF,
;  0xFF, 0xFF, 0xEF, 0xE7, 0xE3, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
;  0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
;  0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE3, 0xE7, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,
;  0xFF, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
;  0xE0, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x07, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x7F, 0xFF,
;  0xFE, 0xFE, 0xF8, 0xF8, 0xF1, 0xE1, 0xE1, 0xC1, 0x81, 0x81, 0x01, 0x01,
;  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
;  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x01, 0x01,
;  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
;  0x81, 0xC1, 0xC1, 0xC1, 0xE1, 0xF1, 0xF0, 0xF8, 0xFC, 0xFC, 0xFF, 0xFF,
;  0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
;  0x00, 0x01, 0x03, 0x03, 0x07, 0x07, 0x07, 0x0F, 0x0F, 0x1F, 0x1F, 0x1F,
;  0x3F, 0x3F, 0x3E, 0x3E, 0x3E, 0x3C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C,
;  0x7C, 0x78, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7C,
;  0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x3C, 0x3E, 0x3E, 0x3E, 0x3F, 0x1F, 0x1F,
;  0x1F, 0x1F, 0x0F, 0x0F, 0x07, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00,
;  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
;
;*/
;
;/*
;flash unsigned char Batt0[16] = {0x7F,0x41,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};	 // степени заряда батареи
;flash unsigned char Batt1[16] = {0x7F,0x41,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt2[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt3[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt4[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt5[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt6[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt7[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt8[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt9[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x41,0x7F,0x3E};
;flash unsigned char Batt10[16] = {0x7F,0x41,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x5D,0x41,0x7F,0x3E};
;flash unsigned char Batt_done[16] = {0x7F,0x41,0x55,0x49,0x55,0x49,0x55,0x49,0x55,0x49,0x55,0x49,0x55,0x41,0x7F,0x3E};
;
;// flash unsigned char Card[7] = {0x7C,0x42,0x5D,0x55,0x49,0x41,0x7F};
;flash unsigned char Card[7] = {0x7C,0x42,0x41,0x41,0x41,0x41,0x7F};	  //простая карта памяти
;flash unsigned char CardFail[7] = {0x7C,0x62,0x55,0x49,0x55,0x63,0x7F};  // перечеркнутая карта - ошибка доступа
;flash unsigned char CardFull[7] = {0x7C,0x7E,0x7F,0x7F,0x7F,0x7F,0x7F};  // заполненная карта
;
;
;flash unsigned char Power[14] = {0x14,0x14,0x3E,0x22,0x22,0x22,0x1C,0x08,0x04,0x04,0x08,0x10,0x10,0x08};	//  символ вилки
;flash unsigned char USB[12] = {0x1E,0x20,0x20,0x1E,0x00,0x24,0x2A,0x12,0x00,0x3E,0x2A,0x14};	 // USB
;
;flash unsigned char Bell[9] = {0x20,0x50,0x4E,0x61,0x61,0x61,0x4E,0x50,0x20};                  //   будильник
;
;flash unsigned char Radar[8] = {0x03,0x44,0x68,0x78,0x54,0x22,0x20,0x20};                       //  GPS
;flash unsigned char RadarLocate[8] = {0x03,0x44,0x68,0x79,0x54,0x22,0x28,0x25};                 //  GPS со спутниками
;
;flash unsigned char Level0[2] = {0x60,0x60};                                                    //  диаграмма разного уровня
;flash unsigned char Level1[4] = {0x60,0x60,0x70,0x70};
;flash unsigned char Level2[6] = {0x60,0x60,0x70,0x70,0x78,0x78};
;flash unsigned char Level3[8] = {0x60,0x60,0x70,0x70,0x78,0x78,0x7C,0x7C};
;flash unsigned char Level4[10] = {0x60,0x60,0x70,0x70,0x78,0x78,0x7C,0x7C,0x7E,0x7E};
;flash unsigned char Level5[12] = {0x60,0x60,0x70,0x70,0x78,0x78,0x7C,0x7C,0x7E,0x7E,0x7F,0x7F};
;
;*/
;//***************************************************************************
;//
;//  Author(s)...: Pashgan    http://ChipEnable.Ru
;//
;//  Compiler....: CodeVision 2.04
;//
;//  Description.: USART/UART. Используем кольцевой буфер
;//
;//  Data........: 3.01.10
;//
;//***************************************************************************
;#include "usart.h"
;
;
;#warning заменить на структуру+ избавиться от Usart_rxCount!
;/*
;  struct {
;	u08 buff[TX_BUFFER_SIZE];
;	u08 head;
;	u08 tail;
;} TX_buff;
;
;struct {
;	u08 buff[RX_BUFFER_SIZE];
;	u08 head;
;	u08 tail;
;} RX_buff;
;*/
;//передающий буфер
;static volatile char Usart0_TX_buf[SIZE_BUF_TX];
;static volatile uint16_t Usart0_txBufTail = 0;
;static volatile uint16_t Usart0_txBufHead = 0;
;//static volatile uint16_t Usart0_txCount = 0;
;
;static volatile char Usart1_TX_buf[SIZE_BUF_TX];
;static volatile uint16_t Usart1_txBufTail = 0;
;static volatile uint16_t Usart1_txBufHead = 0;
;//static volatile uint16_t Usart1_txCount = 0;
; #warning  Usart0_txCount not used
;
;
;//приемный буфер
;static volatile char Usart0_RX_buf[SIZE_BUF_RX];
;static volatile uint16_t Usart0_rxBufTail = 0;
;static volatile uint16_t Usart0_rxBufHead = 0;
;static volatile uint16_t Usart0_rxCount = 0;
;
;static volatile char Usart1_RX_buf[SIZE_BUF_RX];
;static volatile uint16_t Usart1_rxBufTail = 0;
;static volatile uint16_t Usart1_rxBufHead = 0;
;static volatile uint16_t Usart1_rxCount = 0;
;
;
;void UartTxBufOvf_Handler(void) //обработчик переполнения передающего буфера UART
;{

	.CSEG
_UartTxBufOvf_Handler:
;    PORTD.7=1;
	SBI  0x12,7
;}
	RET
;
;
;uint16_t Calk_safe_baud(uint8_t mode, uint16_t input_baud)   //Проверка возможности работі на заданой скорости
;{
; uint8_t max_total_err = 52; //порог ошибки, если больше - комуникация невозможна. 52 соответствует 2.1%
;
; uint32_t tmp0 = 0;
; uint16_t tmp1 = 0;
;
; if (mode == USART_NORMAL){tmp0 = 16UL*input_baud;}
;	mode -> Y+10
;	input_baud -> Y+8
;	max_total_err -> R17
;	tmp0 -> Y+4
;	tmp1 -> R18,R19
; else {tmp0 = 8UL*input_baud;}
;
; tmp1 = (F_CPU/100)/tmp0;   //{ubrrValue = F_CPU/(16UL*baudRate) - 1;}
; tmp1 = tmp1*tmp0;
; tmp1 = ((F_CPU/100) - tmp1);
; tmp1 = tmp1>>5; // /32
; if(tmp1 > max_total_err){tmp1 = 48;} //при большой потенциальной ошибке передачи (>2.1%) - скорость будет 4800baud (не вызывает ошибки на ЛЮБЫХ частотах)
; else {tmp1 = input_baud;} //если всё ок, вернуть принятую скорость
;return tmp1;
;}
;
;
; void USART_Init (uint8_t sel, uint8_t mode, uint16_t baudRate) //инициализация usart`a
;{
_USART_Init:
;uint16_t ubrrValue;
;#warning возможно надо увеличить разрядность baudRate!
;__disable_interrupts();
	ST   -Y,R17
	ST   -Y,R16
;	sel -> Y+5
;	mode -> Y+4
;	baudRate -> Y+2
;	ubrrValue -> R16,R17
	IN   R30,0x3F
	STS  _saved_state_G000,R30
	cli
;
;#ifdef UART_BAUD-ERR-CONTROL_EN
;baudRate = Calk_safe_baud(mode, baudRate);// Проверка погрешности при выбраной скорости (зависит от F_CPU)
;#endif
;baudRate = baudRate * 100;
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R30,LOW(100)
	CALL __MULB1W2U
	STD  Y+2,R30
	STD  Y+2+1,R31
;
; if (mode == USART_NORMAL)
	LDD  R30,Y+4
	CPI  R30,0
	BRNE _0xAA
; {
;   ubrrValue = (F_CPU+8UL*baudRate)/(16UL*baudRate) - 1;
	CALL SUBOPT_0xD
	CALL SUBOPT_0xE
	__ADDD1N 16000000
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	CALL SUBOPT_0xD
	__GETD2N 0x10
	CALL __MULD12U
	POP  R26
	POP  R27
	POP  R24
	POP  R25
	RJMP _0x289
; }    //Upd-12
;  else
_0xAA:
;  {
;    ubrrValue = (F_CPU+4UL*baudRate)/(8UL*baudRate) - 1; //doubles speed
	CALL SUBOPT_0xD
	MOVW R0,R30
	MOVW R24,R22
	CALL __LSLD1
	CALL __LSLD1
	__ADDD1N 16000000
	PUSH R23
	PUSH R22
	PUSH R31
	PUSH R30
	MOVW R30,R0
	MOVW R22,R24
	CALL SUBOPT_0xE
	POP  R26
	POP  R27
	POP  R24
	POP  R25
_0x289:
	CALL __DIVD21U
	__SUBD1N 1
	MOVW R16,R30
;  } //Upd-12
;
;
;if(sel==USART_0)    //for USART_0
	LDD  R30,Y+5
	CPI  R30,0
	BRNE _0xAC
;{
;  Usart0_txBufTail = 0;  Usart0_txBufHead = 0;
	LDI  R30,LOW(0)
	STS  _Usart0_txBufTail_G000,R30
	STS  _Usart0_txBufTail_G000+1,R30
	CALL SUBOPT_0xF
;  Usart0_rxBufTail = 0;  Usart0_rxBufHead = 0;
	STS  _Usart0_rxBufTail_G000,R30
	STS  _Usart0_rxBufTail_G000+1,R30
	LDI  R30,LOW(0)
	STS  _Usart0_rxBufHead_G000,R30
	STS  _Usart0_rxBufHead_G000+1,R30
;  Usart0_rxCount = 0;
	STS  _Usart0_rxCount_G000,R30
	STS  _Usart0_rxCount_G000+1,R30
;  UCSR0A = 0; // USART0 disabled
	OUT  0xB,R30
;  UCSR0B = 0;  UCSR0C = 0;
	OUT  0xA,R30
	STS  149,R30
;
;    if (mode != USART_NORMAL){ UCSR0A = (1<<U2X0);}//doubles speed  //Upd-12
	LDD  R30,Y+4
	CPI  R30,0
	BREQ _0xAD
	LDI  R30,LOW(2)
	OUT  0xB,R30
;
;  // Communication Parameters: 8 Data, 1 Stop, No Parity
;  // USART1 Receiver: On //Transmitter: On //Mode: Asynchronous
;  UBRR0H = (uint8_t)(ubrrValue >> 8);
_0xAD:
	STS  144,R17
;  UBRR0L = (uint8_t)ubrrValue;
	OUT  0x9,R16
;  UCSR0B = (1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0); //разр. прерыв при приеме и передачи, разр приема, разр передачи.
	LDI  R30,LOW(152)
	OUT  0xA,R30
;  UCSR0C = (1<<UCSZ01)|(1<<UCSZ00); //размер слова 8 разрядов
	LDI  R30,LOW(6)
	STS  149,R30
;}
;else             //for USART_1
	RJMP _0xAE
_0xAC:
;{
;  Usart1_txBufTail = 0;  Usart1_txBufHead = 0;
	LDI  R30,LOW(0)
	STS  _Usart1_txBufTail_G000,R30
	STS  _Usart1_txBufTail_G000+1,R30
	CALL SUBOPT_0x10
;  Usart1_rxBufTail = 0;  Usart1_rxBufHead = 0;
	STS  _Usart1_rxBufTail_G000,R30
	STS  _Usart1_rxBufTail_G000+1,R30
	LDI  R30,LOW(0)
	STS  _Usart1_rxBufHead_G000,R30
	STS  _Usart1_rxBufHead_G000+1,R30
;  Usart1_rxCount = 0;
	STS  _Usart1_rxCount_G000,R30
	STS  _Usart1_rxCount_G000+1,R30
;  UCSR1A = 0;  // USART1 disabled
	STS  155,R30
;  UCSR1B = 0;  UCSR1C = 0;
	STS  154,R30
	STS  157,R30
;
;    if (mode != USART_NORMAL) { UCSR1A = (1<<U2X1);}//doubles speed
	LDD  R30,Y+4
	CPI  R30,0
	BREQ _0xAF
	LDI  R30,LOW(2)
	STS  155,R30
;
;  // Communication Parameters: 8 Data, 1 Stop, No Parity
;  // USART1 Receiver: On //Transmitter: On //Mode: Asynchronous
;  UBRR1H = (uint8_t)(ubrrValue >> 8);
_0xAF:
	STS  152,R17
;  UBRR1L = (uint8_t)ubrrValue;
	STS  153,R16
;  UCSR1B = (1<<RXCIE1)|(1<<RXEN1)|(1<<TXEN1); //разр. прерыв при приеме и передачи, разр приема, разр передачи.
	LDI  R30,LOW(152)
	STS  154,R30
;  UCSR1C = (1<<UCSZ11)|(1<<UCSZ10); //размер слова 8 разрядов
	LDI  R30,LOW(6)
	STS  157,R30
;}
_0xAE:
;__restore_interrupts();
	CALL SUBOPT_0x3
;}
	LDD  R17,Y+1
	LDD  R16,Y+0
	RJMP _0x20C000D
;
;
;//______________________________________________________________________________
; /*
;unsigned char USART_Get_txCount(void) //возвращает колличество символов передающего буфера
;{
;  return Usart_txCount;
;}
;*/
;void USART_FlushTxBuf(uint8_t sel) //"очищает" передающий буфер
;{
;__disable_interrupts();
;	sel -> Y+0
;v_u32_TX_CNT=0;
;
; switch (sel)
; {
;   case USART_0:
;Usart_0_flush:
;  Usart0_txBufTail = 0;
;  Usart0_txBufHead = 0;
;   break;
;   case USART_1:
;  Usart1_txBufTail = 0;
;  Usart1_txBufHead = 0;
;   break;
;     default:
; goto Usart_0_flush;
;   break;
;}
;__restore_interrupts();
;}
;
;
;//OPTIMISED!
;//помещает символ в буфер, инициирует начало передачи
;
;void USART_PutChar(uint8_t sel, unsigned char symbol) //помещает символ в буфер, инициирует начало передачи
;{
_USART_PutChar:
; uint16_t Tmp_0 = Usart0_txBufHead;
; uint16_t Tmp_1 = Usart1_txBufHead;
;
; switch (sel)
	CALL __SAVELOCR4
;	sel -> Y+5
;	symbol -> Y+4
;	Tmp_0 -> R16,R17
;	Tmp_1 -> R18,R19
	__GETWRMN 16,17,0,_Usart0_txBufHead_G000
	__GETWRMN 18,19,0,_Usart1_txBufHead_G000
	LDD  R30,Y+5
; {
;   case USART_0:
	CPI  R30,0
	BRNE _0xBD
; Usart_0:
_0xBE:
;       // if(((UCSR0A & (1<<UDRE0)) == 1)) {UDR0 = symbol;} //если модуль usart свободен //((UCSRA & (1<<UDRE)) == 1) && (Usart0_txCount == 0)
;       //  else {                                                           //пишем символ прямо в регистр UDR
;               if((uint16_t)(Tmp_0 - Usart0_txBufTail ) <= (uint16_t) SIZE_BUF_TX){ // buffer full, wait until symbol transmitted in interrupt
	LDS  R26,_Usart0_txBufTail_G000
	LDS  R27,_Usart0_txBufTail_G000+1
	MOVW R30,R16
	CALL SUBOPT_0x11
	BRSH _0xBF
;               Usart0_TX_buf[Tmp_0 & (SIZE_BUF_TX - 1)] = symbol;
	MOVW R30,R16
	ANDI R31,HIGH(0xFF)
	SUBI R30,LOW(-_Usart0_TX_buf_G000)
	SBCI R31,HIGH(-_Usart0_TX_buf_G000)
	LDD  R26,Y+4
	STD  Z+0,R26
;               ++Tmp_0;
	__ADDWRN 16,17,1
;               __disable_interrupts();
	IN   R30,0x3F
	STS  _saved_state_G000,R30
	cli
;               Usart0_txBufHead = Tmp_0;
	__PUTWMRN _Usart0_txBufHead_G000,0,16,17
;               UCSR0B |= (1 << UDRIE0);
	SBI  0xA,5
;               } else {UartTxBufOvf_Handler();} //if TX buf ovverflowed, go to ovrf handler
	RJMP _0xC3
_0xBF:
	RCALL _UartTxBufOvf_Handler
_0xC3:
;         //    }
;   break;
	RJMP _0xBC
;   case USART_1:
_0xBD:
	CPI  R30,LOW(0x1)
	BRNE _0xCA
;      //  if(((UCSR1A & (1<<UDRE1)) == 1)) {UDR1 = symbol;} //если модуль usart свободен //((UCSRA & (1<<UDRE)) == 1) && (Usart0_txCount == 0)
;       //  else {                                                           //пишем символ прямо в регистр UDR
;               if((uint16_t)(Tmp_1 - Usart1_txBufTail) <= (uint16_t) SIZE_BUF_TX){ // buffer full, wait until symbol transmitted in interrupt
	LDS  R26,_Usart1_txBufTail_G000
	LDS  R27,_Usart1_txBufTail_G000+1
	MOVW R30,R18
	CALL SUBOPT_0x11
	BRSH _0xC5
;               Usart1_TX_buf[Tmp_1 & (SIZE_BUF_TX - 1)] = symbol;
	MOVW R30,R18
	ANDI R31,HIGH(0xFF)
	SUBI R30,LOW(-_Usart1_TX_buf_G000)
	SBCI R31,HIGH(-_Usart1_TX_buf_G000)
	LDD  R26,Y+4
	STD  Z+0,R26
;               ++Tmp_1;
	__ADDWRN 18,19,1
;               __disable_interrupts();
	IN   R30,0x3F
	STS  _saved_state_G000,R30
	cli
;               Usart1_txBufHead = Tmp_1;
	__PUTWMRN _Usart1_txBufHead_G000,0,18,19
;               UCSR1B |= (1 << UDRIE1);
	LDS  R30,154
	ORI  R30,0x20
	STS  154,R30
;               }else {UartTxBufOvf_Handler();} //if TX buf ovverflowed, go to ovrf handler
	RJMP _0xC9
_0xC5:
	RCALL _UartTxBufOvf_Handler
_0xC9:
;          //   }
;   break;
	RJMP _0xBC
;     default:
_0xCA:
;     goto Usart_0;
	RJMP _0xBE
;     break;
; }
_0xBC:
; __restore_interrupts();
	CALL SUBOPT_0x3
;}
	CALL __LOADLOCR4
_0x20C000D:
	ADIW R28,6
	RET
;
;
;
;void USART_Send_Str(uint8_t sel, unsigned char * data)//функция посылающая строку по usart`у
;{
_USART_Send_Str:
;  while(*data)
;	sel -> Y+2
;	*data -> Y+0
_0xCB:
	LD   R26,Y
	LDD  R27,Y+1
	LD   R30,X
	CPI  R30,0
	BREQ _0xCD
;  {
;   USART_PutChar(sel, *data++);//Optimized
	LDD  R30,Y+2
	ST   -Y,R30
	LDD  R26,Y+1
	LDD  R27,Y+1+1
	LD   R30,X+
	STD  Y+1,R26
	STD  Y+1+1,R27
	ST   -Y,R30
	RCALL _USART_PutChar
;  }
	RJMP _0xCB
_0xCD:
;}
	RJMP _0x20C000C
;
;void USART_Send_StrFl(uint8_t sel, unsigned char __flash * data) //функция посылающая строку из флэша по usart`у
;{
_USART_Send_StrFl:
;  while(*data)
;	sel -> Y+2
;	*data -> Y+0
_0xCE:
	LD   R30,Y
	LDD  R31,Y+1
	LPM  R30,Z
	CPI  R30,0
	BREQ _0xD0
;  {
;    USART_PutChar(sel, *data++);
	LDD  R30,Y+2
	ST   -Y,R30
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	ADIW R30,1
	STD  Y+1,R30
	STD  Y+1+1,R31
	SBIW R30,1
	LPM  R30,Z
	ST   -Y,R30
	RCALL _USART_PutChar
;  }
	RJMP _0xCE
_0xD0:
;}
	RJMP _0x20C000C
;
;
;  //Optimised
;//обработчик прерывания по завершению передачи
;interrupt [USART0_DRE] void usart0_dre_my(void)  //USART Data Register Empty Interrupt
;{
_usart0_dre_my:
	CALL SUBOPT_0x12
;uint16_t Tmp = Usart0_txBufTail; // use local variable instead of volatile
;
;      if(Tmp != Usart0_txBufHead) // Not all transmitted
	ST   -Y,R16
;	Tmp -> R16,R17
	__GETWRMN 16,17,0,_Usart0_txBufTail_G000
	LDS  R30,_Usart0_txBufHead_G000
	LDS  R31,_Usart0_txBufHead_G000+1
	CP   R30,R16
	CPC  R31,R17
	BREQ _0xD1
;       {
;       UDR0 = Usart0_TX_buf[Tmp & (SIZE_BUF_TX - 1)];
	MOVW R30,R16
	ANDI R31,HIGH(0xFF)
	SUBI R30,LOW(-_Usart0_TX_buf_G000)
	SBCI R31,HIGH(-_Usart0_TX_buf_G000)
	LD   R30,Z
	OUT  0xC,R30
;       ++Tmp;
	__ADDWRN 16,17,1
;       Usart0_txBufTail = Tmp;
	__PUTWMRN _Usart0_txBufTail_G000,0,16,17
;       }
;       else
	RJMP _0xD2
_0xD1:
;       {
;    // PORTD.7=0;
;         Usart0_txBufHead = 0; Usart0_txBufTail = 0;
	CALL SUBOPT_0xF
	STS  _Usart0_txBufTail_G000,R30
	STS  _Usart0_txBufTail_G000+1,R30
;        UCSR0B &= ~(1 << UDRIE0); // disable this int
	CBI  0xA,5
;       }
_0xD2:
;#ifdef DEBUG
;v_u32_TX_CNT++;
	LDI  R26,LOW(_v_u32_TX_CNT)
	LDI  R27,HIGH(_v_u32_TX_CNT)
	CALL SUBOPT_0x13
;#endif
;}
	LD   R16,Y+
	LD   R17,Y+
	RJMP _0x2A2
;
;//обработчик прерывания по завершению передачи
;interrupt [USART1_DRE] void usart1_dre_my(void)  //USART Data Register Empty Interrupt
;{
_usart1_dre_my:
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
;uint16_t Tmp = Usart1_txBufTail; // use local variable instead of volatile
;
;        UDR1 = Usart1_TX_buf[Tmp & (SIZE_BUF_TX - 1)];
	ST   -Y,R17
	ST   -Y,R16
;	Tmp -> R16,R17
	__GETWRMN 16,17,0,_Usart1_txBufTail_G000
	MOVW R30,R16
	ANDI R31,HIGH(0xFF)
	SUBI R30,LOW(-_Usart1_TX_buf_G000)
	SBCI R31,HIGH(-_Usart1_TX_buf_G000)
	LD   R30,Z
	STS  156,R30
;       ++Tmp;
	__ADDWRN 16,17,1
;       Usart1_txBufTail = Tmp;
	__PUTWMRN _Usart1_txBufTail_G000,0,16,17
;      if(Tmp == Usart1_txBufHead) // all transmitted
	CALL SUBOPT_0x14
	CP   R30,R16
	CPC  R31,R17
	BRNE _0xD3
;       {
;       //PORTD.7=0;
;         Usart1_txBufHead = 0; Usart1_txBufTail = 0;
	CALL SUBOPT_0x10
	STS  _Usart1_txBufTail_G000,R30
	STS  _Usart1_txBufTail_G000+1,R30
;        UCSR1B &= ~(1 << UDRIE1); // disable this int
	LDS  R30,154
	ANDI R30,0xDF
	STS  154,R30
;       }
;#ifdef DEBUG
;//v_u32_TX_CNT++;
;#endif
;}
_0xD3:
	LD   R16,Y+
	LD   R17,Y+
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	RETI
;/*
;ISR (USART_TXC_vect) {
;	if (TX_buff.head!=TX_buff.tail) {
;		UDR = TX_buff.buff[TX_buff.head];
;		TX_buff.head = (TX_buff.head+1)&(TX_BUFFER_SIZE-1);
;	} else {
;		UART_message = UART_TX_COMPLETE;
;		SendMessageWParam(MSG_UART, &UART_message);
;	}
;}
;*/
;//______________________________________________________________________________
;
;unsigned char USART_Get_rxCount(uint8_t sel) //возвращает колличество символов находящихся в приемном буфере
;{
;return  sel ? Usart1_rxCount : Usart0_rxCount;
;	sel -> Y+0
;}
;
;void USART_FlushRxBuf(uint8_t sel)//"очищает" приемный буфер
;{
;  // uint8_t saved_state;
;   v_u32_RX_CNT = 0;
;	sel -> Y+0
;__disable_interrupts();
;if(!sel){
;  Usart0_rxBufTail = 0;
;  Usart0_rxBufHead = 0;
;  Usart0_rxCount = 0;
;} else{
;  Usart1_rxBufTail = 0;
;  Usart1_rxBufHead = 0;
;  Usart1_rxCount = 0;
;}
;__restore_interrupts();
;}
;
;
;char USART_Get_Char(uint8_t Uart_sel) //чтение буфера
;{
;  unsigned char symbol;
;  uint8_t saved_state;
;if(!Uart_sel)
;	Uart_sel -> Y+2
;	symbol -> R17
;	saved_state -> R16
;{
;  if (Usart0_rxCount > 0)        //если приемный буфер не пустой
;  {
;    symbol = Usart0_RX_buf[Usart0_rxBufHead];        //прочитать из него символ
;    Usart0_rxBufHead++;                        //инкрементировать индекс головы буфера
;    if (Usart0_rxBufHead == SIZE_BUF_RX) Usart0_rxBufHead = 0;
;__disable_interrupts();
;    Usart0_rxCount--;                          //уменьшить счетчик символов
;__restore_interrupts();
;    return symbol;                         //вернуть прочитанный символ
;  }
;  return 0;
;}
;  else
;  {
;   if (Usart1_rxCount > 0)        //если приемный буфер не пустой
;  {
;    symbol = Usart1_RX_buf[Usart1_rxBufHead];        //прочитать из него символ
;    Usart1_rxBufHead++;                        //инкрементировать индекс головы буфера
;    if (Usart1_rxBufHead == SIZE_BUF_RX) Usart1_rxBufHead = 0;
;__disable_interrupts();
;    Usart1_rxCount--;                          //уменьшить счетчик символов
;__restore_interrupts();
;    return symbol;                         //вернуть прочитанный символ
;  }
;  return 0;
;  }
;}
;
;
;/*
;  ISR (USART_RXC_vect) {
;	u08 tmp = 0;
;	tmp = UDR;
;	if (((RX_buff.tail - RX_buff.head + 256) & (RX_BUFFER_SIZE-1)) < (RX_BUFFER_SIZE-1)) {
;		RX_buff.buff[RX_buff.tail] = tmp;
;		RX_buff.tail = (RX_buff.tail+1)&(RX_BUFFER_SIZE-1);
;		if (tmp == 0x0D) {										// found end string classifier
;			RX_buff.tail = (RX_buff.tail-1)&(RX_BUFFER_SIZE-1); // remove string end classifier from buffer
;			///RX_buff.buff[RX_buff.tail] = '\0';				// replace string end delimiter with C standard string end
;			UART_message = UART_RX_COMPLETE;
;			SendMessageWParam(MSG_UART, &UART_message);
;		}
;	} else {
;		sys_error = SYS_ERR_RX_BUF_FULL;
;	}
;}
;*/
;#warning проверить, действительно ли нужно наращивать при приёме Tail а не Head!
; interrupt [USART0_RXC] void usart0_rxc(void) //переривання по завершенню прийому
;{
_usart0_rxc:
	CALL SUBOPT_0x12
;char data;
;data =  UDR0;// read to clear RxC flag
;	data -> R17
	IN   R17,12
;    if (Usart0_rxCount < SIZE_BUF_RX) //якщо в буфері ще є місце
	LDS  R26,_Usart0_rxCount_G000
	LDS  R27,_Usart0_rxCount_G000+1
	CPI  R26,LOW(0x100)
	LDI  R30,HIGH(0x100)
	CPC  R27,R30
	BRSH _0xE8
;    {
;       Usart0_RX_buf[Usart0_rxBufTail] = data;//зчитати символ до буфера
	LDS  R30,_Usart0_rxBufTail_G000
	LDS  R31,_Usart0_rxBufTail_G000+1
	SUBI R30,LOW(-_Usart0_RX_buf_G000)
	SBCI R31,HIGH(-_Usart0_RX_buf_G000)
	ST   Z,R17
;      Usart0_rxBufTail++;                    //збільшити індекс кінця буферу
	LDI  R26,LOW(_Usart0_rxBufTail_G000)
	LDI  R27,HIGH(_Usart0_rxBufTail_G000)
	CALL SUBOPT_0x15
;      Usart0_rxCount++;
	LDI  R26,LOW(_Usart0_rxCount_G000)
	LDI  R27,HIGH(_Usart0_rxCount_G000)
	CALL SUBOPT_0x15
;#warning проверить необходимость следующего куска
;     if (Usart0_rxBufTail == SIZE_BUF_RX)
	LDS  R26,_Usart0_rxBufTail_G000
	LDS  R27,_Usart0_rxBufTail_G000+1
	CPI  R26,LOW(0x100)
	LDI  R30,HIGH(0x100)
	CPC  R27,R30
	BRNE _0xE9
;      {
;       Usart0_rxBufTail = 0;
	LDI  R30,LOW(0)
	STS  _Usart0_rxBufTail_G000,R30
	STS  _Usart0_rxBufTail_G000+1,R30
;      }
;    }
_0xE9:
;#ifdef DEBUG
;v_u32_RX_CNT++;
_0xE8:
	LDI  R26,LOW(_v_u32_RX_CNT)
	LDI  R27,HIGH(_v_u32_RX_CNT)
	CALL SUBOPT_0x13
;#endif
;}
	LD   R17,Y+
_0x2A2:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R23,Y+
	LD   R22,Y+
	RETI
;
;
;
;
; interrupt [USART1_RXC] void usart1_rxc(void) //прерывание по завершению приема
;{
_usart1_rxc:
	CALL SUBOPT_0x16
;char data;//!
;data =  UDR1;//! read to clear RxC flag!
	ST   -Y,R17
;	data -> R17
	LDS  R17,156
;if(!U1_in_buf_flag)
	LDS  R30,_U1_in_buf_flag
	CPI  R30,0
	BRNE _0xEA
;  {
;    if (Usart1_rxCount < SIZE_BUF_RX) //если в буфере еще есть место
	LDS  R26,_Usart1_rxCount_G000
	LDS  R27,_Usart1_rxCount_G000+1
	CPI  R26,LOW(0x100)
	LDI  R30,HIGH(0x100)
	CPC  R27,R30
	BRSH _0xEB
;    {
;       Usart1_RX_buf[Usart1_rxBufTail] = data;//!    //считать символ  в буфер
	LDS  R30,_Usart1_rxBufTail_G000
	LDS  R31,_Usart1_rxBufTail_G000+1
	SUBI R30,LOW(-_Usart1_RX_buf_G000)
	SBCI R31,HIGH(-_Usart1_RX_buf_G000)
	ST   Z,R17
;      Usart1_rxBufTail++;                    //увеличить индекс хвоста приемного буфера
	LDI  R26,LOW(_Usart1_rxBufTail_G000)
	LDI  R27,HIGH(_Usart1_rxBufTail_G000)
	CALL SUBOPT_0x15
;      Usart1_rxCount++;                      //увеличить счетчик принятых символов
	LDI  R26,LOW(_Usart1_rxCount_G000)
	LDI  R27,HIGH(_Usart1_rxCount_G000)
	CALL SUBOPT_0x15
;#warning проверить необходимость следующего куска
;    if (Usart1_rxBufTail == SIZE_BUF_RX)
	LDS  R26,_Usart1_rxBufTail_G000
	LDS  R27,_Usart1_rxBufTail_G000+1
	CPI  R26,LOW(0x100)
	LDI  R30,HIGH(0x100)
	CPC  R27,R30
	BRNE _0xEC
;      {
;       Usart1_rxBufTail = 0;
	LDI  R30,LOW(0)
	STS  _Usart1_rxBufTail_G000,R30
	STS  _Usart1_rxBufTail_G000+1,R30
;      }
;     }  //TODO - добавить переход на обработчик переполнения буффера!
_0xEC:
;  }
_0xEB:
; else   //При флаге - грузим в буфер системного юарта и сразу на вывод!
	RJMP _0xED
_0xEA:
; {      //эмуляция приёма системным юартом данніх извне! отладить!
;    if((uint16_t)(Usart1_txBufHead - Usart1_txBufTail) <= (uint16_t) SIZE_BUF_TX) //если в буфере еще есть место
	LDS  R26,_Usart1_txBufTail_G000
	LDS  R27,_Usart1_txBufTail_G000+1
	CALL SUBOPT_0x14
	CALL SUBOPT_0x11
	BRSH _0xEE
;    {
;      Usart0_TX_buf[Usart1_txBufHead & (SIZE_BUF_TX - 1)] = data;//!    //считать символ  в буфер
	CALL SUBOPT_0x14
	ANDI R31,HIGH(0xFF)
	SUBI R30,LOW(-_Usart0_TX_buf_G000)
	SBCI R31,HIGH(-_Usart0_TX_buf_G000)
	ST   Z,R17
;      Usart0_txBufHead++;     //увеличить индекс   буфера
	LDI  R26,LOW(_Usart0_txBufHead_G000)
	LDI  R27,HIGH(_Usart0_txBufHead_G000)
	CALL SUBOPT_0x15
;      #warning возможно не Голову, а Хвост!! Проверить!
;      //UCSR0B |= (1 << UDRIE0); // TX int - on
;      }
; }
_0xEE:
_0xED:
;}
	LD   R17,Y+
	CALL SUBOPT_0x17
	RETI
;
;/*
;*/
;
;//считает кол-во данных в кольцевом буфере
; uint16_t usart_calc_BufData (uint16_t BufTail, uint16_t BufHead)
;{
;    if (BufTail >=  BufHead)
;	BufTail -> Y+2
;	BufHead -> Y+0
;        return (BufTail -  BufHead);
;    else
;        return ((SIZE_BUF_TX -  BufHead) + BufTail);
;}
;
;
;
;
;
;
;
;
;
;
;#include "parser.h"
;
;char buf[SIZE_RECEIVE_BUF];
;char *argv[AMOUNT_PAR];
;uint8_t argc;
;
;uint8_t i = 0;
;uint8_t devider_f = 0;
;
;void PARSER_Init(void)
;{
_PARSER_Init:
;  argc = 0;
	LDI  R30,LOW(0)
	STS  _argc,R30
;  argv[0] = buf;
	LDI  R30,LOW(_buf)
	LDI  R31,HIGH(_buf)
	STS  _argv,R30
	STS  _argv+1,R31
;  devider_f = FALSE;
	LDI  R30,LOW(0)
	STS  _devider_f,R30
;  i = 0;
	STS  _i,R30
;}
	RET
;
;void PARS_Parser(char symbol)
;{
;   if (symbol !='\r')    //'\r' //end of string
;	symbol -> Y+0
;   {
;     if (i < SIZE_RECEIVE_BUF - 1)
;     {
;        if (symbol != ' ')
;         {
;           if (!argc)
;           {
;              argv[0] = buf;
;              argc++;
;           }
;
;           if (devider_f)
;           {
;              if (argc < AMOUNT_PAR)
;              {
;                 argv[argc] = &buf[i];
;                 argc++;
;              }
;              devider_f = FALSE;
;            }
;
;            buf[i] = symbol;
;            i++;
;         }
;        else
;         {                 // "space" - is divider
;           if (!devider_f)
;           {
;              buf[i] = 0;
;              i++;
;              devider_f = TRUE;
;           }
;         }
;     }
;     buf[i] = 0;
;     return;
;   }
;   else
;   {
;      buf[i] = 0;
;        if (argc)
;           {
;                PARS_Handler(argc, argv);
;           }
;      argc = 0;
;      devider_f = FALSE;
;      i = 0;
;   }
;}
;
;#ifdef  __GNUC__
;
;uint8_t PARS_EqualStrFl(char *s1, char const *s2)
;{
;  uint8_t i = 0;
;
;  while(s1[i] == pgm_read_byte(&s2[i]) && s1[i] != '\0' && pgm_read_byte(&s2[i]) != '\0')
;  {
;     i++;
;  }
;  if (s1[i] =='\0' && pgm_read_byte(&s2[i]) == '\0')
;  {
;     return TRUE;
;  }
;  else
;  {
;     return FALSE;
;  }
;}
;
;#else
;
;#warning standart strcmpf req less memory
;uint8_t PARS_EqualStrFl(char *s1, char __flash *s2)
;{
;  uint8_t i = 0;
;
;  while(s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
;	*s1 -> Y+3
;	*s2 -> Y+1
;	i -> R17
;  {
;     i++;
;  }
;  if (s1[i] =='\0' && s2[i] == '\0')
;  {
;     return TRUE;
;  }
;  else
;  {
;     return FALSE;
;  }
;}
;
;#endif
;
;#warning standart strcmp req less memory
;uint8_t PARS_EqualStr(char *s1, char *s2)
;{
;  uint8_t i = 0;
;
;  while(s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
;	*s1 -> Y+3
;	*s2 -> Y+1
;	i -> R17
;  {
;     i++;
;  }
;  if (s1[i] =='\0' && s2[i] == '\0')
;  {
;     return TRUE;
;  }
;  else
;  {
;     return FALSE;
;  }
;}
;
;uint8_t PARS_StrToUchar(char *s)
;{
;   uint8_t value = 0;
;  // while(*s == '0'){s++;} // For what?
;   while(*s)
;	*s -> Y+1
;	value -> R17
;   {
;      value += (*s - 0x30);
;      s++;
;      if (*s){
;         value *= 10;
;      }
;   };
;
;  return value;
;}
;
;//atoi
;uint16_t PARS_StrToUint(char *s)
;{
;   uint16_t value = 0;
;   //while(*s == '0'){s++;}
;   while(*s)
;	*s -> Y+2
;	value -> R16,R17
;   {
;      value += (*s - 0x30);
;      s++;
;      if (*s){
;         value *= 10;
;      }
;   };
;
;  return value;
;}
;//***************************************************************************
;//
;//  Author(s)...: Vlad
;//
;//  Target(s)...: Mega
;//
;//  Compiler....:
;//
;//  Description.: Драйвер SPI
;//
;//  Data........: 11.2.14
;//
;//***************************************************************************
;#include "spi.h"
;
;#include "RTOS/EERTOS.h"
;#include "RTOS/EERTOSHAL.h"
; #include "D_Tasks/task_list.h"
; /*
; Забирать значение из SPDR можно в прерывании таймера!
; */
;#warning заменить на структуру
;//передающий буфер
;static volatile char Spi0_TX_buf[SIZE_SPI_BUF_TX];
;static volatile uint16_t Spi0_txBufTail = 0;
;static volatile uint16_t Spi0_txBufHead = 0;
;
;static volatile char Spi1_TX_buf[SIZE_SPI_BUF_TX];
;static volatile uint16_t Spi1_txBufTail = 0;
;static volatile uint16_t Spi1_txBufHead = 0;
; #warning  Spi0_txCount not used
;
;
;//приемный буфер
;static volatile char Spi0_RX_buf[SIZE_SPI_BUF_RX];
;static volatile uint16_t Spi0_rxBufTail = 0;
;static volatile uint16_t Spi0_rxBufHead = 0;
;static volatile uint16_t Spi0_rxCount = 0;
;
;static volatile char Spi1_RX_buf[SIZE_SPI_BUF_RX];
;static volatile uint16_t Spi1_rxBufTail = 0;
;static volatile uint16_t Spi1_rxBufHead = 0;
;static volatile uint16_t Spi1_rxCount = 0;
;
;bool TX_flag = 0;
;bool RX_flag = 0;
;
;
;void SpiTxBufOvf_Handler(void){
;PORTD.7=0;
;}
;
;void SPI_FlushTxBuf(uint8_t sel) //"очищает" передающий буфер
;{
;  uint8_t saved_state;
;__disable_interrupts();
;	sel -> Y+1
;	saved_state -> R17
;
; switch (sel)
; {
;   case SPI_0:
;Spi_0_flush:
;  Spi0_txBufTail = 0;
;  Spi0_txBufHead = 0;
;   break;
;   case SPI_1:
;
;   break;
;     default:
; goto Spi_0_flush;
;   break;
;}
;__restore_interrupts();
;}
;
;
;///////////////////////////////////////////////////////////////
;////////////////////SOFTWARE SPI///////////////////////////////
;
;#warning наполовину софтовый!
;/*инициализация SPI*/
;void Soft_SPI_Master_Init(void)
;{
;  /*настройка портов ввода-вывода
;  все выводы, кроме MISO выходы*/
;  SPI_DDRX = (1<<SPI_MOSI)|(1<<SPI_SCK)|(1<<SPI_SS)|(0<<SPI_MISO);
;  SPI_PORTX = (1<<SPI_MOSI)|(1<<SPI_SCK)|(1<<SPI_SS)|(1<<SPI_MISO);
;
;  /*разрешение spi,старший бит вперед,мастер, режим 0*/
;  SPCR = (1<<SPE)|(0<<DORD)|(1<<MSTR)|(0<<CPOL)|(0<<CPHA)|(1<<SPR1)|(0<<SPR0);
; // SPSR = (0<<SPI2X);
; SPCR = (1<<SPIE); /* Enable SPI, Interrupt */
;}
;
;////////////////////SOFTWARE SPI///////////////////////////////
;///////////////////////////////////////////////////////////////
;
;
;
;
;
;
;///////////////////////////////////////////////////////////////
;////////////////////HARDWARE SPI///////////////////////////////
;
;//---------------MASTER-----------------//
;
;void Hard_SPI_Master_Init_default(void)
;{
_Hard_SPI_Master_Init_default:
;SPCR = 0; /* Set MOSI and SCK output, all others input */
	LDI  R30,LOW(0)
	OUT  0xD,R30
;  DDR_SPI = (1<<_MOSI)|(1<<_SCK)|(1<<_SS)|(0<<_MISO);;
	LDI  R30,LOW(7)
	OUT  0x17,R30
;  PORT_SPI = (1<<_MOSI)|(1<<_SCK)|(1<<_SS)|(1<<_MISO);
	LDI  R30,LOW(15)
	OUT  0x18,R30
;/* Enable SPI, Master, set clock rate fck/16, Interrupt */
;
;SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
	LDI  R30,LOW(81)
	RJMP _0x20C000B
;//SPCR = (1<<SPIE)|(1<<SPE); /* Enable SPI, Interrupt */  в прерывание не переходит!
;}
;
;
;void Hard_SPI_Master_Init(bool phase, bool polarity, uint8_t prescaller)
;{
_Hard_SPI_Master_Init:
;SPCR = 0;
;	phase -> Y+2
;	polarity -> Y+1
;	prescaller -> Y+0
	LDI  R30,LOW(0)
	OUT  0xD,R30
;/* Set MOSI and SCK output, all others input */
;  DDR_SPI = (1<<_MOSI)|(1<<_SCK)|(1<<_SS);  DDR_SPI &=~(1<<_MISO);
	LDI  R30,LOW(7)
	OUT  0x17,R30
	CBI  0x17,3
;  PORT_SPI = (1<<_MOSI)|(1<<_SCK)|(1<<_SS);//|(1<<_MISO);//Лучше с подтяжкой!
	OUT  0x18,R30
;
;  SPCR = (phase<<CPHA) | (polarity<<CPOL);
	LDD  R30,Y+2
	LSL  R30
	LSL  R30
	MOV  R26,R30
	LDD  R30,Y+1
	LSL  R30
	LSL  R30
	LSL  R30
	OR   R30,R26
	OUT  0xD,R30
;
;        switch(prescaller)  //prescaller
	LD   R30,Y
;        {
;          case 2:
	CPI  R30,LOW(0x2)
	BRNE _0x124
;           SPSR = (1<<SPI2X);
	LDI  R30,LOW(1)
	OUT  0xE,R30
;          break;
	RJMP _0x123
;          case 4:
_0x124:
	CPI  R30,LOW(0x4)
	BRNE _0x125
;           SPCR = (0<<SPR1) | (0<<SPR0);
	LDI  R30,LOW(0)
	RJMP _0x28A
;          break;
;          case 8:
_0x125:
	CPI  R30,LOW(0x8)
	BRNE _0x126
;           SPSR |= (1<<SPI2X);
	SBI  0xE,0
;           SPCR |= (1<<SPR0);
	SBI  0xD,0
;          break;
	RJMP _0x123
;          case 16:
_0x126:
	CPI  R30,LOW(0x10)
	BREQ _0x28B
;            SPCR = (1<<SPR0);
;          break;
;          case 32:
	CPI  R30,LOW(0x20)
	BRNE _0x128
;           SPSR = (1<<SPI2X);
	LDI  R30,LOW(1)
	OUT  0xE,R30
;           SPCR = (1<<SPR1);
	LDI  R30,LOW(2)
	RJMP _0x28A
;          break;
;          case 64:
_0x128:
;           SPCR = (1<<SPR0);
;          break;
;          case 128:
;            SPCR = (1<<SPR0) | (1<<SPR0);
;          break;
;          default:
;            SPCR = (1<<SPR0);
_0x28B:
	LDI  R30,LOW(1)
_0x28A:
	OUT  0xD,R30
;          break;
;        }
_0x123:
;SPCR = (1<<SPE)|(1<<MSTR);
	LDI  R30,LOW(80)
	OUT  0xD,R30
;}
_0x20C000C:
	ADIW R28,3
	RET
;
;/*
;sel - number of spi(0 - hardware)
;mode - master/slave
;*/
;
;void SPI_init(char sel, bool mode, bool phase, bool polarity, uint8_t prescaller){
_SPI_init:
; switch (sel)
;	sel -> Y+4
;	mode -> Y+3
;	phase -> Y+2
;	polarity -> Y+1
;	prescaller -> Y+0
	LDD  R30,Y+4
; {
;  case SPI_0:
	CPI  R30,0
	BRNE _0x132
;   SPCR = 0;
	LDI  R30,LOW(0)
	OUT  0xD,R30
;   SPSR = 0;
	OUT  0xE,R30
;     if(mode == SPI_MASTER)
	LDD  R26,Y+3
	CPI  R26,LOW(0x1)
	BRNE _0x130
;     {
;       Hard_SPI_Master_Init(phase, polarity, prescaller);
	LDD  R30,Y+2
	ST   -Y,R30
	LDD  R30,Y+2
	ST   -Y,R30
	LDD  R30,Y+2
	ST   -Y,R30
	RCALL _Hard_SPI_Master_Init
;     }
;     else //SLAVE
	RJMP _0x131
_0x130:
;     {
;       Hard_SPI_Slave_Init();
	RCALL _Hard_SPI_Slave_Init
;     }
_0x131:
;  break;
	RJMP _0x12E
;  /*
;   case SPI_1:  //soft spi
;   break;
;  */
;  default:
_0x132:
;  Hard_SPI_Master_Init_default();
	RCALL _Hard_SPI_Master_Init_default
;  break;
; }
_0x12E:
;}
	ADIW R28,5
	RET
;
;#warning can be optimized!
;void SPI_RW_Buf(uint8_t num, uint8_t *data_tx, uint8_t *data_rx)   //SPI write-read
;{
;uint8_t i=0; //char data;
;   SPI_PORTX &= ~(1<<SPI_SS);
;	num -> Y+5
;	*data_tx -> Y+3
;	*data_rx -> Y+1
;	i -> R17
;/*
;while(num)
;{
;      SPDR = data_tx[i];  data_tx[i] = 0;
;      while(!(SPSR & (1<<SPIF))){};
;      data_rx[i] = SPDR;
;      // *data_tx++; *data_rx++;
;       --num;
;        i++;
;}  */
;
;
; while(*data_tx)
;  {
;      SPDR = *data_tx++;  //data_tx[i] = 0;
;      while(!(SPSR & (1<<SPIF)));
;      if(i<SIZE_SPI_BUF_RX){data_rx[i] = SPDR;}
;      i++;
;  }
;   SPI_PORTX |= (1<<SPI_SS);
;  SetTask(Task_SPI_ClrBuf); //починить
;}
;//---------------END_MASTER-----------------//
;
;
;//---------------SLAVE------------------------//
;void Hard_SPI_Slave_Init(void)
;{
_Hard_SPI_Slave_Init:
;SPCR = 0;
	LDI  R30,LOW(0)
	OUT  0xD,R30
;DDR_SPI = (1<<_MISO);/* Set MISO output, all others input */
	LDI  R30,LOW(8)
	OUT  0x17,R30
;SPCR = (1<<SPE);/* Enable SPI */
	LDI  R30,LOW(64)
_0x20C000B:
	OUT  0xD,R30
;}
	RET
;//---------------END SLAVE----------------------//
;
;
;////////////////////HARDWARE SPI///////////////////////////////
;///////////////////////////////////////////////////////////////
;
;
;
;//обработчик прерывания по завершению передачи/приёма
;interrupt [SPI_STC] void spi_isr(void)  //разобраться с приёмом/передачей!!!!!
;{
_spi_isr:
	ST   -Y,R26
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
;char data;
;uint8_t Tmp = Spi0_txBufTail; // use local variable instead of volatile
; SPCR = (1<<MSTR);  //Master
	ST   -Y,R17
	ST   -Y,R16
;	data -> R17
;	Tmp -> R16
	LDS  R16,_Spi0_txBufTail_G000
	LDI  R30,LOW(16)
	OUT  0xD,R30
;  PORTD.7^=1;
	LDI  R26,0
	SBIC 0x12,7
	LDI  R26,1
	LDI  R30,LOW(1)
	EOR  R30,R26
	BRNE _0x13A
	CBI  0x12,7
	RJMP _0x13B
_0x13A:
	SBI  0x12,7
_0x13B:
;////////RX
;data =  SPDR;
	IN   R17,15
;/*
;    if (Spi0_rxCount < SIZE_SPI_BUF_RX) //если в буфере еще есть место
;    {
;       Spi0_RX_buf[Spi0_rxBufTail] = data;//!    //считать символ из SPDR в буфер
;       Spi0_rxBufTail++;                    //увеличить индекс хвоста приемного буфера
;      if (Spi0_rxBufTail == SIZE_BUF_RX)
;      {
;       Spi0_rxBufTail = 0;
;      }
;      Spi0_rxCount++;                      //увеличить счетчик принятых символов
;    }
;    */
;///////////
;
;//////////TX
;/*
; if(Tmp != Spi0_txBufHead) // all transmitted
;  {
;  // SPDR = Spi0_TX_buf[Tmp & (SIZE_SPI_BUF_TX - 1)];
;   ++Tmp;
;   Spi0_txBufTail = Tmp;
;   SPDR = Spi0_TX_buf[Tmp & (SIZE_SPI_BUF_TX - 1)];
;  }
;   */
;/////////
;
;}
	LD   R16,Y+
	LD   R17,Y+
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	LD   R26,Y+
	RETI
;
;
;
;
;
;  /*
;interrupt [SPI_STC] void spi_isr(void)
;{
;char data;
;uint8_t Tmp = Spi0_txBufTail; // use local variable instead of volatile
; SPCR = (1<<MSTR);  //Master
;////////RX
;data =  SPDR;
;    if (Spi0_rxCount < SIZE_SPI_BUF_RX) //якщо в буфері є місцк
;    {
;       Spi0_RX_buf[Spi0_rxBufTail] = data;//!    //зчитати символ з SPDR в буфер
;       Spi0_rxBufTail++;
;      if (Spi0_rxBufTail == SIZE_BUF_RX)
;      {
;       Spi0_rxBufTail = 0;
;      }
;      Spi0_rxCount++;
;    }
;///////////
;//////////TX
; if(Tmp != Spi0_txBufHead) // all transmitted
;  {
;   ++Tmp;
;   Spi0_txBufTail = Tmp;
;   SPDR = Spi0_TX_buf[Tmp & (SIZE_SPI_BUF_TX - 1)];
;  }
;/////////
;}
;  */
;
;
;
;
;
;
;/*
;unsigned char spi(unsigned char data)
;{
;_ATXMEGA_SPI_.DATA=data;
;while ((_ATXMEGA_SPI_.STATUS & SPI_IF_bm)==0);
;return _ATXMEGA_SPI_.DATA;
;}
;
;void spi_init(bool master_mode,bool lsb_first,SPI_MODE_t mode,bool clk2x,SPI_PRESCALER_t clock_div, unsigned char ss_pin)
;{
;if (master_mode)
;   {
;   // Init SS pin as output with wired AND and pull-up
;   _ATXMEGA_SPI_PORT_.DIRSET=ss_pin;
;   _ATXMEGA_SPI_PORT_.PIN4CTRL=PORT_OPC_WIREDANDPULL_gc;
;
;   // Set SS output to high
;   _ATXMEGA_SPI_PORT_.OUTSET=ss_pin;
;
;   // SPI master mode
;   _ATXMEGA_SPI_.CTRL=clock_div |                      // SPI prescaler.
;                      (clk2x ? SPI_CLK2X_bm : 0) |     // SPI Clock double.
;                      SPI_ENABLE_bm |                  // Enable SPI module.
;                      (lsb_first ? SPI_DORD_bm : 0) |  // Data order.
;                      SPI_MASTER_bm |                  // SPI master.
;                      mode;                            // SPI mode.
;
;   // MOSI and SCK as output
;   _ATXMEGA_SPI_PORT_.DIRSET=SPI_MOSI_bm | SPI_SCK_bm;
;   }
;else
;   {
;   // SPI slave mode
;   _ATXMEGA_SPI_.CTRL=SPI_ENABLE_bm |                 // Enable SPI module.
;                      (lsb_first ? SPI_DORD_bm : 0) | // Data order.
;	                  mode;                           // SPI mode.
;
;   // MISO as output
;   _ATXMEGA_SPI_PORT_.DIRSET=SPI_MISO_bm;
;   };
;// No interrupts, polled mode
;_ATXMEGA_SPI_.INTCTRL=SPI_INTLVL_OFF_gc;
;}
;*/
   .equ __i2c_port=0x1B ;PORTA
   .equ __sda_bit=0
   .equ __scl_bit=1
;//***************************************************************************
;//
;//  Author(s)...: Vlad
;//
;//  Target(s)...: Mega
;//
;//  Compiler....:
;//
;//  Description.: Драйвер I2C
;//
;//  Data........:
;//
;//***************************************************************************
;#include "I2C.h"
;
;
;/*
;TODO:
;Hard/Software implementations
;
;*/
;////////////////HARDWARE_TWI/I2C///////////////////////////
;///////////////////////////////////////////////////////////
;
;void hard_twi_init(void){// TWI initialization
;// Bit Rate: 400,000 kHz
;TWBR=0x02;
;// Two Wire Bus Slave Address: 0x0
;// General Call Recognition: Off
;TWAR=0x00;
;// Generate Acknowledge Pulse: Off
;// TWI Interrupt: On
;TWCR = (1<<TWIE)|(1<<TWEN) ;
;TWSR=0x00;
;}
;
;
;/*
;void hard_twi_init(void);
;void hard_twi_start(void);
;void hard_twi_stop(void);
;unsigned char hard_twi_read(unsigned char ack);
;unsigned char hard_twi_write(unsigned char data);
;*/
;
;void hard_twi_start() {
;	TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN); // send start condition
;	while (!(TWCR & (1 << TWINT))){};
;    //возможно сдесь нужно очистить  TWSTA
;}
;
;void hard_twi_write_byte(char byte) {
;	TWDR = byte;
;	byte -> Y+0
;	TWCR = (1 << TWINT) | (1 << TWEN); // start address transmission
;	while (!(TWCR & (1 << TWINT))){};
;}
;
;char hard_twi_read_byte() {
;	TWCR = (1 << TWINT) | (1 << TWEA) | (1 << TWEN); // start data reception, transmit ACK
;	while (!(TWCR & (1 << TWINT))){};
;	return TWDR;
;}
;
;char hard_twi_read_last_byte() {
;	TWCR = (1 << TWINT) | (1 << TWEN); // start data reception
;	while (!(TWCR & (1 << TWINT))){};
;	return TWDR;
;}
;
;void hard_twi_stop() {
;	  TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN); // send stop condition
;}
;
;uint8_t hard_twi_read_ACK(void)
;{
;    TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
;    while ((TWCR & (1<<TWINT)) == 0){};
;    return TWDR;
;}
;//read byte with NACK
;uint8_t hard_twi_read_NACK(void)
;{
;    TWCR = (1<<TWINT)|(1<<TWEN);
;    while ((TWCR & (1<<TWINT)) == 0){};
;    return TWDR;
;}
;
;uint8_t hard_twi_get_status(void)
;{
;    uint8_t status;
;    status = TWSR & 0xF8;     //mask status
;	status -> R17
;    return status;
;}
;
;/*
;// Two Wire bus interrupt service routine
;interrupt [TWI] void twi_isr(void)
;{
;
;TWCR = (1<<TWINT) ;// At the end - clear interrupt flag
;}
;*/

	.DSEG
;#include "ADC.h"
;
;interrupt [ADC_INT] void adc_isr(void)// ADC interrupt service routine
;{

	.CSEG
_adc_isr:
	ST   -Y,R0
	ST   -Y,R1
	ST   -Y,R22
	ST   -Y,R23
	ST   -Y,R25
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
; adc_result=ADCW*3-ADCW/7; //умножаем чтобы получить мВ и немного учитываем погрешности
	IN   R30,0x4
	IN   R31,0x4+1
	LDI  R26,LOW(3)
	LDI  R27,HIGH(3)
	CALL __MULW12U
	MOVW R22,R30
	IN   R30,0x4
	IN   R31,0x4+1
	MOVW R26,R30
	LDI  R30,LOW(7)
	LDI  R31,HIGH(7)
	CALL __DIVW21U
	MOVW R26,R22
	SUB  R26,R30
	SBC  R27,R31
	STS  _adc_result,R26
	STS  _adc_result+1,R27
;  ADCSRA=0;  //выкл
	LDI  R30,LOW(0)
	OUT  0x6,R30
;}
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R25,Y+
	LD   R23,Y+
	LD   R22,Y+
	LD   R1,Y+
	LD   R0,Y+
	RETI
;
;
;
;void ADC_init(void){ // ADC initialization  //Upd-6
_ADC_init:
;PORTF=0x00; DDRF=0x00;
	CALL SUBOPT_0x18
;// ADC Clock frequency: 1000,000 kHz
;// ADC Voltage Reference: Int., cap. on AREF
;ADMUX=ADC_VREF_TYPE & 0xff;
	LDI  R30,LOW(192)
	OUT  0x7,R30
;ADCSRA=0x8C;
	LDI  R30,LOW(140)
	OUT  0x6,R30
;}
	RET
;
;void ADC_use (void)
;{
;  ADMUX |=0x01;
;  ADCSRA=0b11011111;  //вкл
;};
;
;
;//-----------Функция автокалибровки АЦП-----------------   //Upd-7
;void ADC_calibrate (void)   //Поиск оптимального напряжения Vref
;{
_ADC_calibrate:
;  ADMUX &= 0xDF & 0x7F & 0xFE; ADMUX |= 0x40 | 0x0E;   //Регистр ADMUX: АЦП 10 бит, Vref=AVCC (5B), ИОН=1,23В
	IN   R30,0x7
	ANDI R30,LOW(0x5E)
	OUT  0x7,R30
	IN   R30,0x7
	ORI  R30,LOW(0x4E)
	OUT  0x7,R30
;  ADCSRA &= 0xDF & 0xFC; ADCSRA |= 0x80 | 0x40 | 0x04; //Регистр ADCSRA: вкл. АЦП, одиночный пуск, Fацп=62 кГц
	IN   R30,0x6
	ANDI R30,LOW(0xDC)
	OUT  0x6,R30
	IN   R30,0x6
	ORI  R30,LOW(0xC4)
	OUT  0x6,R30
;  for (volt=0, adc_calib_cnt=100; adc_calib_cnt>0; adc_calib_cnt--) //Усреднение 100 замеров
	LDI  R30,LOW(0)
	STS  _volt,R30
	STS  _volt+1,R30
	LDI  R30,LOW(100)
	LDI  R31,HIGH(100)
	STS  _adc_calib_cnt,R30
	STS  _adc_calib_cnt+1,R31
_0x150:
	LDS  R26,_adc_calib_cnt
	LDS  R27,_adc_calib_cnt+1
	CALL __CPW02
	BRSH _0x151
;  {
;    ADCSRA |= 0x40;        //Запуск нового измерения АЦП
	SBI  0x6,6
;    while (ADCSRA & 0x40){};   //Проверка окончания замера
_0x152:
	SBIC 0x6,6
	RJMP _0x152
;    volt += ADCL;    //Чтение младших 8 битов результата
	IN   R30,0x4
	CALL SUBOPT_0x19
	LDI  R31,0
	CALL SUBOPT_0x1A
;    volt += ((int)ADCH << 8);    //Плюс два старших бита
	IN   R30,0x5
	MOV  R31,R30
	LDI  R30,0
	CALL SUBOPT_0x19
	CALL SUBOPT_0x1A
;  }                   //Окончание 100 замеров напряжения
	LDI  R26,LOW(_adc_calib_cnt)
	LDI  R27,HIGH(_adc_calib_cnt)
	LD   R30,X+
	LD   R31,X+
	SBIW R30,1
	ST   -X,R31
	ST   -X,R30
	RJMP _0x150
_0x151:
;  for (avcc=4750; avcc<5250; avcc++) //Диапазон AVCC, мВ
	LDI  R30,LOW(4750)
	LDI  R31,HIGH(4750)
	STS  _avcc,R30
	STS  _avcc+1,R31
_0x156:
	LDS  R26,_avcc
	LDS  R27,_avcc+1
	CPI  R26,LOW(0x1482)
	LDI  R30,HIGH(0x1482)
	CPC  R27,R30
	BRLO PC+3
	JMP _0x157
;  {
;     adc_tmp = volt*avcc/1024; //Текущее значение ИОН (1,23В)
	LDS  R30,_avcc
	LDS  R31,_avcc+1
	CALL SUBOPT_0x19
	CALL __MULW12U
	CALL __LSRW2
	MOV  R30,R31
	LDI  R31,0
	STS  _adc_tmp,R30
	STS  _adc_tmp+1,R31
;     if (adc_tmp > ION) {delta=adc_tmp-ION;}   //Положительная разность
	LDS  R26,_adc_tmp
	LDS  R27,_adc_tmp+1
	CPI  R26,LOW(0x513)
	LDI  R30,HIGH(0x513)
	CPC  R27,R30
	BRLO _0x158
	LDS  R30,_adc_tmp
	LDS  R31,_adc_tmp+1
	SUBI R30,LOW(1298)
	SBCI R31,HIGH(1298)
	RJMP _0x28C
;     else delta=ION-adc_tmp;           //Отрицательная разность
_0x158:
	LDS  R26,_adc_tmp
	LDS  R27,_adc_tmp+1
	LDI  R30,LOW(1298)
	LDI  R31,HIGH(1298)
	SUB  R30,R26
	SBC  R31,R27
_0x28C:
	STS  _delta,R30
	STS  _delta+1,R31
;     if (delta < d){d=delta; vref=avcc;} //Если меньше минимальной разности - запомнить новую минимальную разность и оптимальное напряжение Vref
	LDS  R30,_d
	LDS  R31,_d+1
	LDS  R26,_delta
	LDS  R27,_delta+1
	CP   R26,R30
	CPC  R27,R31
	BRSH _0x15A
	LDS  R30,_delta
	LDS  R31,_delta+1
	STS  _d,R30
	STS  _d+1,R31
	LDS  R30,_avcc
	LDS  R31,_avcc+1
	STS  _vref,R30
	STS  _vref+1,R31
;  }                                      //Окончание сохранения новых значений, Окончание поиска оптимального напряжения Vref
_0x15A:
	LDI  R26,LOW(_avcc)
	LDI  R27,HIGH(_avcc)
	CALL SUBOPT_0x15
	RJMP _0x156
_0x157:
;}                 //Окончание функции автокалибровки АЦП
	RET
;
;uint16_t ADC_get_volt(void)
;{
;   return vref-adc_result*vref/1024;
;}
;
;/*
;//Автокалибровка АЦП,=AVR. Ступень 8=, РА, №9, 2005 г     =1
;//Make: avr83,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
;//Фьюзы: SUT0=CKSEL3=CKSEL2=CKSEL1="0" (Генератор 1 МГц)  =3
;#include <avr/io.h>             //Библиотека ввода-вывода =4
;#define RIZM 200  //Сопротивление измер. резистора в Омах =5
;#define ION 1298 //Напряжение внутреннего ИОН (1,23) в мВ =6
;extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =7
;extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =8
;extern void lcd_init(void);           //Инициализация ЖКИ =9
;unsigned char t0[]=" ==WATTMETER==          mWt     "; //=10
;unsigned long vref=0,volt,watt,delta,i,d=200,avcc;     //=11
;unsigned int a;                //Вспомогательный счетчик =12
;//-----------Функция автокалибровки АЦП----------------- =13
;void calib (void)   //Поиск оптимального напряжения Vref =14
;{ //Регистр ADMUX: АЦП 10 бит, Vref=AVCC (5B), ИОН=1,23В =15
;        ADMUX &= 0xDF & 0x7F & 0xFE; ADMUX |= 0x40 | 0x0E;   //=16
;//Регистр ADCSRA: вкл. АЦП, одиночный пуск, Fацп=62 кГц  =17
;        ADCSRA &= 0xDF & 0xFC; ADCSRA |= 0x80 | 0x40 | 0x04; //=18
;  for (volt=0, a=100; a>0; a--) //Усреднение 100 замеров =19
;  {    ADCSRA |= 0x40;        //Запуск нового измерения АЦП =20
;          while (ADCSRA & 0x40){};   //Проверка окончания замера =21
;          volt += ADCL;    //Чтение младших 8 битов результата =22
;    volt += ((int)ADCH << 8);    //Плюс два старших бита =23
;        }                   //Окончание 100 замеров напряжения =24
;        for (avcc=4750; avcc<5250; avcc++) //Диапазон AVCC, мВ =25
;  { i = volt*avcc/102400; //Текущее значение ИОН (1,23В) =26
;          if (i > ION) delta=i-ION;   //Положительная разность =27
;          else delta=ION-i;           //Отрицательная разность =28
;          if (delta < d)    //Если меньше минимальной разности =29
;    { d=delta;    //Запомнить новую минимальную разность =30
;      vref=avcc; //Запомнить оптимальное напряжение Vref =31
;    }              //Окончание сохранения новых значений =32
;  }      //Окончание поиска оптимального напряжения Vref =33
;}                 //Окончание функции автокалибровки АЦП =34
;//================ОСНОВНАЯ ПРОГРАММА==================== =35
;int main(void)               //Начало основной программы =36
;{ PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =37
;  PORTC = 0xF0; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =38
;  lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =39
;  for (lcd_com(0x80), a=0; a<32; a++)  //Начальный текст =40
;        { if (a==16) lcd_com(0xC0); //Переход на нижнюю строку =41
;          lcd_dat(t0[a]);             //Вывод текущего символа =42
;        }       //Окончание вывода начальной надписи WATTMETER =43
;        calib(); //Автокалибровка АЦП по внутреннему ИОН 1,23В =44
;        ADMUX &= 0xF3; ADMUX |= 0x03;   //Подключение канала-3 =45
;        ADCSRA |= 0x20 | 0x40;   //Пуск постоянных замеров АЦП =46
;        while (1)                           //Бесконечный цикл =47
;        { for (a=65000; a>0; a--);       //Пауза для индикации =48
;          volt = ADCL;     //Чтение младших 8 битов результата =49
;    volt += ((int)ADCH << 8);    //Плюс два старших бита =50
;          watt=(vref-volt*vref/1024)*(volt*vref/1024)/RIZM; // =51
;                lcd_com(0xC4);               //Установка курсора ЖКИ =52
;                lcd_dat(watt/1000 + 0x30); //Единицы милливатт (мВт) =53
;				lcd_dat(',');	lcd_dat((watt/100)%10 +0x30); //0,1мВт =54
;		}                     //Переход к новому измерению АЦП =55
;}              //WinAVR-20050214, длина кода 1342 байтов =56
;
;
;
;//Осциллограф на ЖКИ (АЦП),=AVR. Ступень 9=, РА, №10-2005 =1
;//Make: avr91,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
;//Фьюзы: SUT0=CKSEL3=CKSEL1=CKSEL0="0" (Генератор 8 МГц)  =3
;#include <avr/io.h>             //Библиотека ввода-вывода =4
;extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =5
;extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =6
;extern void lcd_init(void);           //Инициализация ЖКИ =7
;unsigned char t[]="        јєc/гe» ";    //Текст заставки =8
;//================ОСНОВНАЯ ПРОГРАММА===================== =9
;int main(void)               //Начало основной программы =10
;{ unsigned char a, b, c, scan, ur, h;         //Счетчики =11
;  unsigned int izm, d, k;       //Счетчики больших чисел =12
;		unsigned int osc[32];   //Массив амплитуд осциллографа =13
;		PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =14
;  PORTC = 0xC2; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =15
;		ADMUX &= 0x7F; ADMUX |= 0x20 | 0x40;  //8-10 бит, AVCC =16
;//Регистр ADCSRA: вкл.АЦП, постоян. измерен., Fацп=1 МГц =17
;		ADCSRA &= 0xFB; ADCSRA |= 0x80 | 0x40 | 0x20 | 0x03; //=18
;		lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =19
;		lcd_com(0x40); lcd_dat(0x00); //Начало знакогенератора =20
;		for (a=1; a<63; a++)  //Загрузка 8 свободных знакомест =21
;		{ if (a%7 == 0) lcd_dat(0x1F);      //В строке 5 точек =22
;	   else lcd_dat(0x00);       //Пустая строка, нет точек =23
;		}       //Окончание загрузки 62 байтов знакогенератора =24
;		lcd_dat(0x00); //Последний (64-й) байт знакогенератора =25
;		for (lcd_com(0xC0), a=0; a<16; a++) lcd_dat(t[a]);  // =26
;		while (1)                 //Бесконечный цикл измерений =27
;		{ ADMUX &=0xF5; ADMUX |=0x05;     //Канал-5, РАЗВЕРТКА =28
;		  for (a=5; a>0; a--) for (d=60000; d>0; d--);	//Пауза =29
;				scan = (ADCH <= 5)? 1 : (ADCH - 4); //Развертка, мкс =30
;				ADMUX &=0xF4; ADMUX |=0x04; //Канал-4, УРОВЕНЬ СИНХР =31
;				lcd_com(0xC2);               //Установка курсора ЖКИ =32
;				for (k=13*scan, d=10000, b=5; b > 0; b--, d=d/10) // =33
;    { lcd_dat(((k / d)%10) + 0x30); //Вывод текущ. цифры =34
;    }  //Окончание вывода 5 цифр времени развертки в мкс =35
;				ur = (ADCH <= 10)? 0 : ADCH; //Уровень синхрониз., В =36
;		  ADMUX &= 0xF3; ADMUX |= 0x03; //Канал-3, ВХОД осцил. =37
;				for(lcd_com(0x80), a=0; a<32; a++)   //32 замера АЦП =38
;				{ for (izm=0, b=scan; b > 0; b--)  //Время развертки =39
;						{ while (!(ADCSRA & 0x10)){};   //Проверка измерения =40
;		      ADCSRA |= 0x10;   //Разрешение следующего замера =41
;        izm += ADCH;             //Накопление результата =42
;						}                //Окончание очередного замера АЦП =43
;						osc[a] = izm;        //Заполнение массива амплитуд =44
;				}              	//Окончание 32 замеров амплитуды АЦП =45
;				lcd_com(0x0D);               //Включение курсора ЖКИ =46
;				if (!ur)	for (a=0; a<16; a++) lcd_dat((osc[a]/scan)/32);
;				else  //Если синхронизация или остановка изображения =48
;				{	if (ur < 0xF0)    //Если нет остановки изображения =49
;				  { for (a=b=c=h=0; a<16; a++) //Поиск синхронизации =50
;        { if (bit_is_set(PINB,PB0)) c=1; //Кнопка SB1(+) =51
;								  else b=1;   //Иначе синхронизация от <+> к <-> =52
;								  if((osc[a+b]/scan<(ur-3))&&(osc[a+c]/scan>(ur+3)))
;								  { h=a; a=32;       //Досрочный выход из поиска =54
;										}            //Синхронизация выполнена успешно =55
;						  }     //Окончание процедуры поиска синхронизации =56
;						  for (a=h; a<(h+16); a++) lcd_dat((osc[a]/scan)/32);
;						}  //Окончание прорисовки графика с синхронизацией =58
;						else lcd_com(0x0C);  //Выкл. курсора при остановке =59
;				}        //Завершение процедуры поиска синхронизации =60
;		}               //Переход к новому циклу измерений АЦП =61
;}               //WinAVR-20050214, длина кода 882 байтов =62
;
;
;
;//Запоминающий осциллограф,=AVR. Ступень 10=, РА №11-2005 =1
;//Make:avr101,atmega8,Level=2,VMLab,SRC=$(TARGET).c lcd.c =2
;//Фьюзы: SUT0=CKSEL3=CKSEL2=CKSEL1="0" (Генератор 1 МГц)  =3
;#include <avr/io.h>             //Библиотека ввода-вывода =4
;extern void lcd_com(unsigned char p);   //Ввод команд ЖКИ =5
;extern void lcd_dat(unsigned char p);   //Ввод данных ЖКИ =6
;extern void lcd_init(void);           //Инициализация ЖКИ =7
;#define TIME 30 //Условная длительность одного замера АЦП =8
;unsigned char t[]="Cїapї ё·јepeЅё№";     //Текст заставки =9
;//================ОСНОВНАЯ ПРОГРАММА==================== =10
;int main(void)               //Начало основной программы =11
;{ unsigned char u1[450], u2[450]; //Массивы данных осцил.=12
;		unsigned int a, b, c, d, h=0;        //Счетчики данных =13
;  PORTB = DDRD = 0xFF; //В=входы с резисторами, D=выходы =14
;  PORTC = 0xC2; DDRC = 0x05;   //PC0, PC2 выходы с лог.0 =15
;		ADMUX &= 0x7F; ADMUX |= 0x20 | 0x40;  //8-10 бит, AVCC =16
;//Регистр ADCSRA: включить АЦП, однократно, Fацп=125 кГц =17
;		ADCSRA &= 0xDF & 0xFB; ADCSRA |= 0x80 | 0x40 | 0x03; //=18
;		lcd_init();          //Инициализация ЖКИ (4 бит, 16х2) =19
;		lcd_com(0x40); lcd_dat(0x00); //Начало знакогенератора =20
;		for (a=1; a<63; a++)  //Загрузка 8 свободных знакомест =21
;		{ if (a%7 == 0) lcd_dat(0x1F);      //В строке 5 точек =22
;	   else lcd_dat(0x00);       //Пустая строка, нет точек =23
;		}       //Окончание загрузки 62 байтов знакогенератора =24
;		lcd_dat(0x00); //Последний (64-й) байт знакогенератора =25
;		for(lcd_com(0x80),a=0; a<15; a++) lcd_dat(t[a]); //ЖКИ =26
;		do  //Цикл проверки снижения напряжения Uзап менее 4 В =27
;		{ ADMUX &=0xF3; ADMUX |=0x03; ADCSRA |=0x40; //Канал-3 =28
;		  while (ADCSRA & 0x40){};   //Проверка окончания замера =29
;		} while (ADCH > 0xCC){}; //Проверять, пока уровень > 4 В =30
;		lcd_com(0x0C); //Выключение курсора при начале замеров =31
;		for (a=0; a<450; a++) //Цикл заполнения массива данных =32
;		{ for (c=d=0, b=TIME; b>0; b--)   //Усреднение замеров =33
;		  { ADMUX &=0xF4; ADMUX |=0x04; ADCSRA |=0x40; //Кан.4 =34
;		    while (ADCSRA & 0x40){}; //Проверка окончания замера =35
;		    c += ADCH;  //Накопление амплитуды АЦП по каналу-4 =36
;				  ADMUX &=0xF5; ADMUX |=0x05; ADCSRA |=0x40; //Кан.5 =37
;		    while (ADCSRA & 0x40){}; //Проверка окончания замера =38
;		    d += ADCH;  //Накопление амплитуды АЦП по каналу-5 =39
;				}         //Окончание цикла замеров с каналов-4 и -5 =40
;				u1[a] = c/(TIME*32);  //Усредненный текущий замер U1 =41
;				u2[a] = d/(TIME*32);  //Усредненный текущий замер U2 =42
;		}         //Окончание заполнения массива данных U1, U2 =43
;  while (1) //Бесконечный цикл индикации, повтор - сброс =44
;		{ lcd_com(0x80);  //Установка курсора в верхней строке =45
;		  for(a=h; a < h+15; a++) lcd_dat(u1[a]);  //График U1 =46
;				lcd_com(0xC0);   //Установка курсора в нижней строке =47
;				for(a=h; a < h+15; a++) lcd_dat(u2[a]);  //График U2 =48
;				lcd_dat(0x30 + h/15);  //Условный номер блока данных =49
;				if (bit_is_clear(PINB,PB0))     //Нажатие кнопки SB1 =50
;    { if ((h += 15) > 435) h=0;  //Следующий блок данных =51
;      for (c=65000; c>0; c--);  //Длительность индикации =52
;				}         //Окончание увеличения номера блока данных =53
;				if (bit_is_clear(PINB,PB1))     //Нажатие кнопки SB2 =54
;    { h = (h < 15)? 435 : (h-15); //Предыдущий блок дан. =55
;      for (c=65000; c>0; c--);  //Длительность индикации =56
;				}         //Окончание уменьшения номера блока данных =57
;		}               //Переход к прорисовке графиков данных =58
;}               //WinAVR-20050214, длина кода 752 байтов =59
;
;*/
;/**** A V R  A P P L I C A T I O N  NOTE 1 3 4 **************************
; *
; * Title:           Real Time Clock
; * Version:         2.00
; * Last Updated:    24.09.2013
; * Target:          ATmega128 (All AVR Devices with secondary external oscillator)
; *
; * Support E-mail:  avr@atmel.com
; *
; * Description
; * This application note shows how to implement a Real Time Clock utilizing a secondary
; * external oscilator. Included a test program that performs this function, which keeps
; * track of time, date, month, and year with auto leap-year configuration. 8 LEDs are used
; * to display the RTC. The 1st LED flashes every second, the next six represents the
; * minute, and the 8th LED represents the hour.
; *
; ******************************************************************************************/
;
;#ifdef _GCC_
;#include <avr/io.h>
;#include <avr/interrupt.h>
;#include <avr/sleep.h>
;#else
;
;#endif
;
;#include "RTC.h"
;
;	time_t rtc;
;
;/*
;int main(void)
;{
;    rtc_init();	//Initialize registers and configure RTC.
;
;	while(1)
;	{
;		sleep_mode();										//Enter sleep mode. (Will wake up from timer overflow interrupt)
;		TCCR0=(1<<CS00)|(1<<CS02);							//Write dummy value to control register
;		while(ASSR&((1<<TCN0UB)|(1<<OCR0UB)|(1<<TCR0UB)));	//Wait until TC0 is updated
;	}
;}
;*/
;inline void RTC_init(void)
;{
_RTC_init:
;   	TIMSK &= ~((1<<TOIE0)|(1<<OCIE0));						//Make sure all TC0 interrupts are disabled
	IN   R30,0x37
	ANDI R30,LOW(0xFC)
	OUT  0x37,R30
;	ASSR |= (1<<AS0);										//set Timer/counter0 to be asynchronous from the CPU clock
	IN   R30,0x30
	ORI  R30,8
	OUT  0x30,R30
;															//with a second external clock (32,768kHz)driving it.
;	TCNT0 =0;												//Reset timer
	LDI  R30,LOW(0)
	OUT  0x32,R30
;	TCCR0 =(1<<CS00)|(1<<CS02);								//Prescale the timer to be clock source/128 to make it
	LDI  R30,LOW(5)
	OUT  0x33,R30
;															//exactly 1 second for every overflow to occur
;	while (ASSR & ((1<<TCN0UB)|(1<<OCR0UB)|(1<<TCR0UB))){ }	//Wait until TC0 is updated
_0x15B:
	IN   R30,0x30
	ANDI R30,LOW(0x7)
	BRNE _0x15B
;	TIMSK |= (1<<TOIE0);									//Set 8-bit Timer/Counter0 Overflow Interrupt Enable
	IN   R30,0x37
	ORI  R30,1
	OUT  0x37,R30
;#asm("sei")													//Set the Global Interrupt Enable Bit
	sei
;}
	RET
;
;interrupt [TIM0_OVF] void timer0_ovf_isr(void)
;{
_timer0_ovf_isr:
	CALL SUBOPT_0x1B
;	if (++rtc.second==60)        //keep track of time, date, month, and year
	LDI  R26,LOW(_rtc)
	LDI  R27,HIGH(_rtc)
	LDI  R24,0
	CALL SUBOPT_0x1C
	BREQ PC+3
	JMP _0x15E
;	{
;		rtc.second=0;
	LDS  R30,_rtc
	ANDI R30,LOW(0xC0)
	STS  _rtc,R30
;		if (++rtc.minute==60)
	LDI  R26,LOW(_rtc)
	LDI  R27,HIGH(_rtc)
	LDI  R24,6
	CALL SUBOPT_0x1C
	BREQ PC+3
	JMP _0x15F
;		{
;			rtc.minute=0;
	LDS  R30,_rtc
	LDS  R31,_rtc+1
	ANDI R30,LOW(0xF03F)
	ANDI R31,HIGH(0xF03F)
	STS  _rtc,R30
	STS  _rtc+1,R31
;			if (++rtc.hour==24)
	LDI  R26,LOW(_rtc)
	LDI  R27,HIGH(_rtc)
	LDI  R24,12
	CALL SUBOPT_0x1D
	__CPD1N 0x18
	BREQ PC+3
	JMP _0x160
;			{
;				rtc.hour=0;
	LDI  R26,LOW(_rtc)
	LDI  R27,HIGH(_rtc)
	CALL __GETD1P_INC
	__ANDD1N 0xFFFE0FFF
	CALL __PUTDP1_DEC
;				if (++rtc.date==32)
	LDI  R26,LOW(_rtc)
	LDI  R27,HIGH(_rtc)
	LDI  R24,17
	CALL SUBOPT_0x1D
	__CPD1N 0x20
	BREQ _0x28D
;				{
;					rtc.month++;
;					rtc.date=1;
;				}
;				else if (rtc.date==31)
	CALL SUBOPT_0x1E
	CPI  R30,LOW(0x1F)
	BRNE _0x163
;				{
;					if ((rtc.month==4) || (rtc.month==6) || (rtc.month==9) || (rtc.month==11))
	CALL SUBOPT_0x1F
	CPI  R30,LOW(0x4)
	BREQ _0x165
	CALL SUBOPT_0x1F
	CPI  R30,LOW(0x6)
	BREQ _0x165
	CALL SUBOPT_0x1F
	CPI  R30,LOW(0x9)
	BREQ _0x165
	CALL SUBOPT_0x1F
	CPI  R30,LOW(0xB)
	BRNE _0x164
_0x165:
;					{
;						rtc.month++;
	CALL SUBOPT_0x20
;						rtc.date=1;
;					}
;				}
_0x164:
;				else if (rtc.date==30)
	RJMP _0x167
_0x163:
	CALL SUBOPT_0x1E
	CPI  R30,LOW(0x1E)
	BRNE _0x168
;				{
;					if(rtc.month==2)
	CALL SUBOPT_0x1F
	CPI  R30,LOW(0x2)
	BRNE _0x169
;					{
;						rtc.month++;
	CALL SUBOPT_0x20
;						rtc.date=1;
;					}
;				}
_0x169:
;				else if (rtc.date==29)
	RJMP _0x16A
_0x168:
	CALL SUBOPT_0x1E
	CPI  R30,LOW(0x1D)
	BRNE _0x16B
;				{
;					if((rtc.month==2) && (not_leap()))
	CALL SUBOPT_0x1F
	CPI  R30,LOW(0x2)
	BRNE _0x16D
	RCALL _not_leap_G000
	CPI  R30,0
	BRNE _0x16E
_0x16D:
	RJMP _0x16C
_0x16E:
;					{
;						rtc.month++;
_0x28D:
	LDI  R26,LOW(_rtc)
	LDI  R27,HIGH(_rtc)
	LDI  R24,22
	__GETD1N 0xF
	CALL __POSTINC_BITFD
;						rtc.date=1;
	__GETB1MN _rtc,2
	ANDI R30,LOW(0xC1)
	ORI  R30,2
	__PUTB1MN _rtc,2
;					}
;				}
_0x16C:
;				if (rtc.month==13)
_0x16B:
_0x16A:
_0x167:
	CALL SUBOPT_0x1F
	CPI  R30,LOW(0xD)
	BRNE _0x16F
;				{
;					rtc.month=1;
	__GETW1MN _rtc,2
	ANDI R30,LOW(0xFC3F)
	ANDI R31,HIGH(0xFC3F)
	ORI  R30,0x40
	__PUTW1MN _rtc,2
;					rtc.year++;    // HAPPY NEW YEAR !  :)
	LDI  R26,LOW(_rtc)
	LDI  R27,HIGH(_rtc)
	LDI  R24,26
	__GETD1N 0x3F
	CALL __POSTINC_BITFD
;				}
;			}
_0x16F:
;		}
_0x160:
;	}
_0x15F:
;	//PORTB=~(((t.second&0x01)|t.minute<<1)|t.hour<<7);
;}
_0x15E:
	RJMP _0x2A1
;
;static char not_leap(void)      //check for leap year
;{
_not_leap_G000:
;	if (!(rtc.year%100))
	CALL SUBOPT_0x21
	CALL SUBOPT_0x22
	BRNE _0x170
;	{
;		return (char)(rtc.year%400);
	CALL SUBOPT_0x21
	__GETD1N 0x190
	CALL __MODD21U
	RET
;	}
;	else
_0x170:
;	{
;		return (char)(rtc.year%4);
	LDS  R30,_rtc+3
	LSR  R30
	LSR  R30
	__ANDD1N 0x3
	RET
;	}
;}
	RET
;
;//**************************************************************
;// read RTC function
;void getRTC(time_t* stm)
; {
;  __disable_interrupts();     // evite erronated read because RTC is called from interrupt
;	*stm -> Y+0
;  memcpy(stm,&rtc,sizeof(time_t));
;  __restore_interrupts();
; }
;//**************************************************************
;// set RTC function
;/*
;void setRTC(u16 year, u08 mon, u08 day, u08 hour, u08 min, u08 sec)
; {
;  __disable_interrupts();
;  rtc.year=year;
;  rtc.month=mon;
;  rtc.date=day;
;  rtc.hour=hour;
;  rtc.minute=min;
;  rtc.second=sec;
;  __restore_interrupts();
; }*/
;
; void setRTC(time_t* rtc_p, u16 year, u08 mon, u08 day, u08 hour, u08 min, u08 sec)
; {
;  __disable_interrupts();
;	*rtc_p -> Y+7
;	year -> Y+5
;	mon -> Y+4
;	day -> Y+3
;	hour -> Y+2
;	min -> Y+1
;	sec -> Y+0
;  rtc_p->year=year;
;  rtc_p->month=mon;
;  rtc_p->date=day;
;  rtc_p->hour=hour;
;  rtc_p->minute=min;
;  rtc_p->second=sec;
;  __restore_interrupts();
; }
;#include "D_IIC_ultimate/IIC_ultimate.h"
;
;
;void DoNothing(void);
;
;uint8_t i2c_Do;								// Переменная состояния передатчика IIC
;uint8_t i2c_InBuff[i2c_MasterBytesRX];		// Буфер прием при работе как Slave
;uint8_t i2c_OutBuff[i2c_MasterBytesTX];		// Буфер передачи при работе как Slave
;uint8_t i2c_SlaveIndex;						// Индекс буфера Slave
;
;
;uint8_t i2c_Buffer[i2c_MaxBuffer];			// Буфер для данных работы в режиме Master
;uint8_t i2c_index;							// Индекс этого буфера
;uint8_t i2c_ByteCount;						// Число байт передаваемых
;
;uint8_t i2c_SlaveAddress;						// Адрес подчиненного
;
;uint8_t i2c_PageAddress[i2c_MaxPageAddrLgth];	// Буфер адреса страниц (для режима с sawsarp)
;uint8_t i2c_PageAddrIndex;						// Индекс буфера адреса страниц
;uint8_t i2c_PageAddrCount;						// Число байт в адресе страницы для текущего Slave
;
;											// Указатели выхода из автомата:
;IIC_F MasterOutFunc = &DoNothing;			//  в Master режиме

	.DSEG
;IIC_F SlaveOutFunc 	= &DoNothing;			//  в режиме Slave
;IIC_F ErrorOutFunc 	= &DoNothing;			//  в результате ошибки в режиме Master
;
;/*
;uint8_t 	WorkLog[100];						// Лог пишем сюда
;uint8_t		WorkIndex=0;						// Индекс лога
;*/
;
;// Two Wire bus interrupt service routine
;interrupt [TWI] void twi_isr(void)								// Прерывание TWI Тут наше все.
;{

	.CSEG
_twi_isr:
	CALL SUBOPT_0x1B
;#ifdef DEBUG
;//PORTB ^= 0x01;								// Дрыгаем ногой порта, для синхронизации логического анализатора и отметок вызова TWI
;// Отладочный кусок. Вывод лога работы конечного автомата в буфер памяти, а потом.
;//По окончании работы через UART на волю
;if (LogIndex <LogBufSize)							// Если лог не переполнен
	CALL SUBOPT_0x0
	BRSH _0x17B
;{
;	if (TWSR)								// Статус нулевой?
	LDS  R30,113
	CPI  R30,0
	BREQ _0x17C
;		{
;		WorkLog[LogIndex]= TWSR;			// Пишем статус в лог
	LDS  R26,_LogIndex_G000
	LDS  R27,_LogIndex_G000+1
	SUBI R26,LOW(-_WorkLog_G000)
	SBCI R27,HIGH(-_WorkLog_G000)
	LDS  R30,113
	ST   X,R30
;		LogIndex++;
	RJMP _0x28E
;		}
;	else
_0x17C:
;		{
;		WorkLog[LogIndex]= 0xFF;			// Если статус нулевой то вписываем FF
	CALL SUBOPT_0x1
	LDI  R26,LOW(255)
	STD  Z+0,R26
;		LogIndex++;
_0x28E:
	LDI  R26,LOW(_LogIndex_G000)
	LDI  R27,HIGH(_LogIndex_G000)
	CALL SUBOPT_0x15
;		}
;}
;#endif
;
;switch(TWSR & 0xF8)						// Отсекаем биты прескалера
_0x17B:
	LDS  R30,113
	ANDI R30,LOW(0xF8)
;	{
;	case 0x00:	// Bus Fail (автобус сломался)
	CPI  R30,0
	BRNE _0x181
;			{
;			i2c_Do |= i2c_ERR_BF;
	LDS  R30,_i2c_Do
	ORI  R30,1
	CALL SUBOPT_0x23
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  	// Go!
;			MACRO_i2c_WhatDo_ErrorOut
;			break;
	RJMP _0x180
;			}
;
;	case 0x08:	// Старт был, а затем мы:
_0x181:
	CPI  R30,LOW(0x8)
	BRNE _0x182
;			{
;			if( (i2c_Do & i2c_type_msk)== i2c_sarp)							// В зависимости от режима
	LDS  R30,_i2c_Do
	ANDI R30,LOW(0xC)
	BRNE _0x183
;				{
;				i2c_SlaveAddress |= 0x01;									// Шлем Addr+R
	LDS  R30,_i2c_SlaveAddress
	ORI  R30,1
	RJMP _0x28F
;				}
;			else															// Или
_0x183:
;				{
;				i2c_SlaveAddress &= 0xFE;									// Шлем Addr+W
	LDS  R30,_i2c_SlaveAddress
	ANDI R30,0xFE
_0x28F:
	STS  _i2c_SlaveAddress,R30
;				}
;
;			TWDR = i2c_SlaveAddress;													// Адрес слейва
	CALL SUBOPT_0x24
;			TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  	// Go!
;			break;
	RJMP _0x180
;			}
;
;	case 0x10:	// Повторный старт был, а затем мы
_0x182:
	CPI  R30,LOW(0x10)
	BRNE _0x185
;			{
;			if( (i2c_Do & i2c_type_msk) == i2c_sawsarp)						// В зависимости от режима
	CALL SUBOPT_0x25
	BRNE _0x186
;				{
;				i2c_SlaveAddress |= 0x01;									// Шлем Addr+R
	LDS  R30,_i2c_SlaveAddress
	ORI  R30,1
	RJMP _0x290
;				}
;			else
_0x186:
;				{
;				i2c_SlaveAddress &= 0xFE;									// Шлем Addr+W
	LDS  R30,_i2c_SlaveAddress
	ANDI R30,0xFE
_0x290:
	STS  _i2c_SlaveAddress,R30
;				}
;
;			// To Do: Добавить сюда обработку ошибок
;
;			TWDR = i2c_SlaveAddress;													// Адрес слейва
	CALL SUBOPT_0x24
;			TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  	// Go!
;			break;
	RJMP _0x180
;			}
;
;	case 0x18:	// Был послан SLA+W получили ACK, а затем:
_0x185:
	CPI  R30,LOW(0x18)
	BRNE _0x188
;			{
;			if( (i2c_Do & i2c_type_msk) == i2c_sawp)						// В зависимости от режима
	LDS  R30,_i2c_Do
	ANDI R30,LOW(0xC)
	CPI  R30,LOW(0x4)
	BRNE _0x189
;				{
;				TWDR = i2c_Buffer[i2c_index];								// Шлем байт данных
	CALL SUBOPT_0x26
;				i2c_index++;												// Увеличиваем указатель буфера
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  // Go!
;  				}
;
;			if( (i2c_Do & i2c_type_msk) == i2c_sawsarp)
_0x189:
	CALL SUBOPT_0x25
	BRNE _0x18A
;				{
;				TWDR = i2c_PageAddress[i2c_PageAddrIndex];					// Или шлем адрес странцы (по сути тоже байт данных)
	CALL SUBOPT_0x27
;				i2c_PageAddrIndex++;										// Увеличиваем указатель буфера страницы
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;	// Go!
	STS  116,R30
;				}
;			}
_0x18A:
;			break;
	RJMP _0x180
;
;	case 0x20:	// Был послан SLA+W получили NACK - слейв либо занят, либо его нет дома.
_0x188:
	CPI  R30,LOW(0x20)
	BRNE _0x18B
;			{
;			i2c_Do |= i2c_ERR_NA;															// Код ошибки
	LDS  R30,_i2c_Do
	ORI  R30,0x10
	CALL SUBOPT_0x23
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;			// Шлем шине Stop
;
;			MACRO_i2c_WhatDo_ErrorOut 														// Обрабатываем событие ошибки;
;			break;
	RJMP _0x180
;			}
;
;	case 0x28: 	// Байт данных послали, получили ACK!  (если sawp - это был байт данных. если sawsarp - байт адреса страницы)
_0x18B:
	CPI  R30,LOW(0x28)
	BRNE _0x18C
;			{	// А дальше:
;			if( (i2c_Do & i2c_type_msk) == i2c_sawp)							// В зависимости от режима
	LDS  R30,_i2c_Do
	ANDI R30,LOW(0xC)
	CPI  R30,LOW(0x4)
	BRNE _0x18D
;				{
;				if (i2c_index == i2c_ByteCount)												// Если был байт данных последний
	LDS  R30,_i2c_ByteCount
	LDS  R26,_i2c_index
	CP   R30,R26
	BRNE _0x18E
;					{
;					TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;	// Шлем Stop
	CALL SUBOPT_0x28
;
;					MACRO_i2c_WhatDo_MasterOut												// И выходим в обработку стопа
;
;					}
;				else
	RJMP _0x18F
_0x18E:
;					{
;					TWDR = i2c_Buffer[i2c_index];												// Либо шлем еще один байт
	CALL SUBOPT_0x26
;					i2c_index++;
;					TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;  	// Go!
;					}
_0x18F:
;				}
;
;			if( (i2c_Do & i2c_type_msk) == i2c_sawsarp)						// В другом режиме мы
_0x18D:
	CALL SUBOPT_0x25
	BRNE _0x190
;				{
;				if(i2c_PageAddrIndex == i2c_PageAddrCount)					// Если последний байт адреса страницы
	LDS  R30,_i2c_PageAddrCount
	LDS  R26,_i2c_PageAddrIndex
	CP   R30,R26
	BRNE _0x191
;					{
;					TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;		// Запускаем Повторный старт!
	LDI  R30,LOW(229)
	RJMP _0x291
;					}
;				else
_0x191:
;					{														// Иначе
;					TWDR = i2c_PageAddress[i2c_PageAddrIndex];				// шлем еще один адрес страницы
	CALL SUBOPT_0x27
;					i2c_PageAddrIndex++;									// Увеличиваем индекс счетчика адреса страниц
;					TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;		// Go!
_0x291:
	STS  116,R30
;					}
;				}
;			}
_0x190:
;			break;
	RJMP _0x180
;
;	case 0x30:	//Байт ушел, но получили NACK причин две. 1я передача оборвана слейвом и так надо. 2я слейв сглючил.
_0x18C:
	CPI  R30,LOW(0x30)
	BRNE _0x193
;			{
;			i2c_Do |= i2c_ERR_NK;				// Запишем статус ошибки. Хотя это не факт, что ошибка.
	LDS  R30,_i2c_Do
	ORI  R30,2
	STS  _i2c_Do,R30
;
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;		// Шлем Stop
	CALL SUBOPT_0x28
;
;			MACRO_i2c_WhatDo_MasterOut													// Отрабатываем событие выхода
;
;			break;
	RJMP _0x180
;			}
;
;	case 0x38:	//  Коллизия на шине. Нашелся кто то поглавней
_0x193:
	CPI  R30,LOW(0x38)
	BRNE _0x194
;			{
;			i2c_Do |= i2c_ERR_LP;			// Ставим ошибку потери приоритета
	LDS  R30,_i2c_Do
	ORI  R30,0x20
	CALL SUBOPT_0x29
;
;			// Настраиваем индексы заново.
;			i2c_index = 0;
;			i2c_PageAddrIndex = 0;
;
;			TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;		// Как только шина будет свободна
	LDI  R30,LOW(229)
	STS  116,R30
;			break;																		// попробуем передать снова.
	RJMP _0x180
;			}
;
;	case 0x40: // Послали SLA+R получили АСК. А теперь будем получать байты
_0x194:
	CPI  R30,LOW(0x40)
	BRNE _0x195
;			{
;			if(i2c_index+1 == i2c_ByteCount)								// Если буфер кончится на этом байте, то
	CALL SUBOPT_0x2A
	BRNE _0x196
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;	// Требуем байт, а в ответ потом пошлем NACK(Disconnect)
	LDI  R30,LOW(133)
	RJMP _0x292
;				}															// Что даст понять слейву, что мол хватит гнать. И он отпустит шину
;			else
_0x196:
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;	// Или просто примем байт и скажем потом ACK
	LDI  R30,LOW(197)
_0x292:
	STS  116,R30
;				}
;
;			break;
	RJMP _0x180
;			}
;
;	case 0x48: // Послали SLA+R, но получили NACK. Видать slave занят или его нет дома.
_0x195:
	CPI  R30,LOW(0x48)
	BRNE _0x198
;			{
;			i2c_Do |= i2c_ERR_NA;															// Код ошибки No Answer
	LDS  R30,_i2c_Do
	ORI  R30,0x10
	CALL SUBOPT_0x23
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;			// Шлем Stop
;
;			MACRO_i2c_WhatDo_ErrorOut														// Отрабатываем выходную ситуацию ошибки
;			break;
	RJMP _0x180
;			}
;
;	case 0x50: // Приняли байт.
_0x198:
	CPI  R30,LOW(0x50)
	BRNE _0x199
;			{
;			i2c_Buffer[i2c_index] = TWDR;			// Забрали его из буфера
	CALL SUBOPT_0x2B
;			i2c_index++;
	LDS  R30,_i2c_index
	SUBI R30,-LOW(1)
	STS  _i2c_index,R30
;
;			// To Do: Добавить проверку переполнения буфера. А то мало ли что юзер затребует
;
;			if (i2c_index+1 == i2c_ByteCount)		// Если остался еще один байт из тех, что мы хотели считать
	CALL SUBOPT_0x2A
	BRNE _0x19A
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;		// Затребываем его и потом пошлем NACK (Disconnect)
	LDI  R30,LOW(133)
	RJMP _0x293
;				}
;			else
_0x19A:
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;		// Если нет, то затребываем следующий байт, а в ответ скажем АСК
	LDI  R30,LOW(197)
_0x293:
	STS  116,R30
;				}
;			break;
	RJMP _0x180
;			}
;
;	case 0x58:	// Вот мы взяли последний байт, сказали NACK слейв обиделся и отпал.
_0x199:
	CPI  R30,LOW(0x58)
	BRNE _0x19C
;			{
;			i2c_Buffer[i2c_index] = TWDR;													// Взяли байт в буфер
	CALL SUBOPT_0x2B
;			TWCR = 0<<TWSTA|1<<TWSTO|1<<TWINT|i2c_i_am_slave<<TWEA|1<<TWEN|1<<TWIE;			// Передали Stop
	CALL SUBOPT_0x28
;
;			MACRO_i2c_WhatDo_MasterOut														// Отработали точку выхода
;
;			break;
	RJMP _0x180
;			}
;
;// IIC  Slave ============================================================================
;
;	case 0x68:	// RCV SLA+W Low Priority							// Словили свой адрес во время передачи мастером
_0x19C:
	CPI  R30,LOW(0x68)
	BREQ _0x19E
;	case 0x78:	// RCV SLA+W Low Priority (Broadcast)				// Или это был широковещательный пакет. Не важно
	CPI  R30,LOW(0x78)
	BRNE _0x19F
_0x19E:
;			{
;			i2c_Do |= i2c_ERR_LP | i2c_Interrupted;					// Ставим флаг ошибки Low Priority, а также флаг того, что мастера прервали
	LDS  R30,_i2c_Do
	ORI  R30,LOW(0xA0)
	CALL SUBOPT_0x29
;
;			// Restore Trans after.
;			i2c_index = 0;											// Подготовили прерваную передачу заново
;			i2c_PageAddrIndex = 0;
;			}														// И пошли дальше. Внимание!!! break тут нет, а значит идем в "case 60"
;
;	case 0x60: // RCV SLA+W  Incoming?								// Или просто получили свой адрес
	RJMP _0x1A0
_0x19F:
	CPI  R30,LOW(0x60)
	BRNE _0x1A1
_0x1A0:
;	case 0x70: // RCV SLA+W  Incoming? (Broascast)					// Или широковещательный пакет
	RJMP _0x1A2
_0x1A1:
	CPI  R30,LOW(0x70)
	BRNE _0x1A3
_0x1A2:
;			{
;
;			i2c_Do |= i2c_Busy;										// Занимаем шину. Чтобы другие не совались
	LDS  R30,_i2c_Do
	ORI  R30,0x40
	STS  _i2c_Do,R30
;			i2c_SlaveIndex = 0;										// Указатель на начало буфера слейва, Неважно какой буфер. Не ошибемся
	LDI  R30,LOW(0)
	STS  _i2c_SlaveIndex,R30
;
;			if (i2c_MasterBytesRX == 1)								// Если нам суждено принять всего один байт, то готовимся принять  его
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;			// Принять и сказать пошли все н... NACK!
	LDI  R30,LOW(133)
;				}
;			else
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// А если душа шире чем один байт, то сожрем и потребуем еще ACK!
_0x294:
	STS  116,R30
;				}
;			break;
	RJMP _0x180
;			}
;
;	case 0x80:	// RCV Data Byte									// И вот мы приняли этот байт. Наш или широковещательный. Не важно
_0x1A3:
	CPI  R30,LOW(0x80)
	BREQ _0x1A7
;	case 0x90:	// RCV Data Byte (Broadcast)
	CPI  R30,LOW(0x90)
	BRNE _0x1A8
_0x1A7:
;			{
;			i2c_InBuff[i2c_SlaveIndex] = TWDR;						// Сжираем его в буфер.
	CALL SUBOPT_0x2C
;
;			i2c_SlaveIndex++;										// Сдвигаем указатель
	CALL SUBOPT_0x2D
;
;			if (i2c_SlaveIndex == i2c_MasterBytesRX-1) 				// Свободно место всего под один байт?
	CPI  R30,0
	BRNE _0x1A9
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;			// Приянть его и сказать NACK!
	LDI  R30,LOW(133)
	RJMP _0x295
;				}
;			else
_0x1A9:
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Места еще дофига? Принять и ACK!
	LDI  R30,LOW(197)
_0x295:
	STS  116,R30
;				}
;			break;
	RJMP _0x180
;			}
;
;	case 0x88: // RCV Last Byte										// Приянли последний байт
_0x1A8:
	CPI  R30,LOW(0x88)
	BREQ _0x1AC
;	case 0x98: // RCV Last Byte (Broadcast)
	CPI  R30,LOW(0x98)
	BRNE _0x1AD
_0x1AC:
;			{
;			i2c_InBuff[i2c_SlaveIndex] = TWDR;						// Сожрали его в буфер
	CALL SUBOPT_0x2C
;
;			if (i2c_Do & i2c_Interrupted)							// Если у нас был прерываный сеанс от имени мастера
	LDS  R30,_i2c_Do
	ANDI R30,LOW(0x80)
	BREQ _0x1AE
;				{
;				TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Влепим в шину свой Start поскорей и сделаем еще одну попытку
	LDI  R30,LOW(229)
	RJMP _0x296
;				}
;			else
_0x1AE:
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Если не было такого факта, то просто отвалимся и будем ждать
	LDI  R30,LOW(197)
_0x296:
	STS  116,R30
;				}
;
;			MACRO_i2c_WhatDo_SlaveOut												// И лениво отработаем наш выходной экшн для слейва
	__CALL1MN _SlaveOutFunc,0
;			break;
	RJMP _0x180
;			}
;
;
;	case 0xA0: // Ой, мы получили Повторный старт. Но чо нам с ним делать?
_0x1AD:
	CPI  R30,LOW(0xA0)
	BRNE _0x1B0
;			{
;			// Можно, конечно, сделать вспомогательный автомат, чтобы обрабатывать еще и адреса внутренних страниц, подобно еепромке.
;			// Но я не стал заморачиваться. В этом случае делается это тут.
;
;			TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// просто разадресуемся, проигнорировав этот посыл
	LDI  R30,LOW(197)
	STS  116,R30
;			break;
	RJMP _0x180
;			}
;
;
;
;	case 0xB0:  // Поймали свой адрес на чтение во время передачи Мастером
_0x1B0:
	CPI  R30,LOW(0xB0)
	BRNE _0x1B1
;			{
;			i2c_Do |= i2c_ERR_LP | i2c_Interrupted;			// Ну чо, коды ошибки и флаг прерваной передачи.
	LDS  R30,_i2c_Do
	ORI  R30,LOW(0xA0)
	CALL SUBOPT_0x29
;
;			// Восстанавливаем индексы
;			i2c_index = 0;
;			i2c_PageAddrIndex = 0;
;			}												// Break нет! Идем дальше
;
;	case 0xA8:	// // Либо просто словили свой адрес на чтение
	RJMP _0x1B2
_0x1B1:
	CPI  R30,LOW(0xA8)
	BRNE _0x1B3
_0x1B2:
;			{
;			i2c_SlaveIndex = 0;								// Индексы слейвовых массивов на 0
	LDI  R30,LOW(0)
	STS  _i2c_SlaveIndex,R30
;
;			TWDR = i2c_OutBuff[i2c_SlaveIndex];				// Чтож, отдадим байт из тех что есть.
	CALL SUBOPT_0x2E
;
;			if(i2c_MasterBytesTX == 1)
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;	// Если он последний, мы еще на NACK в ответ надеемся
	LDI  R30,LOW(133)
;				}
;			else
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;	// А если нет, то  ACK ждем
_0x297:
	STS  116,R30
;				}
;
;			break;
	RJMP _0x180
;			}
;
;
;	case 0xB8: // Послали байт, получили ACK
_0x1B3:
	CPI  R30,LOW(0xB8)
	BRNE _0x1B6
;			{
;
;			i2c_SlaveIndex++;								// Значит продолжаем дискотеку. Берем следующий байт
	CALL SUBOPT_0x2D
;			TWDR = i2c_OutBuff[i2c_SlaveIndex];				// Даем его мастеру
	CALL SUBOPT_0x2E
;
;			if (i2c_SlaveIndex == i2c_MasterBytesTX-1)		// Если он последний был, то
	LDS  R30,_i2c_SlaveIndex
	CPI  R30,0
	BRNE _0x1B7
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;	// Шлем его и ждем NACK
	LDI  R30,LOW(133)
	RJMP _0x298
;				}
;			else
_0x1B7:
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|0<<TWEN|1<<TWIE;	// Если нет, то шлем и ждем ACK
	LDI  R30,LOW(193)
_0x298:
	STS  116,R30
;				}
;
;			break;
	RJMP _0x180
;			}
;
;	case 0xC0: // Мы выслали последний байт, больше у нас нет, получили NACK
_0x1B6:
	CPI  R30,LOW(0xC0)
	BREQ _0x1BA
;	case 0xC8: // или ACK. В данном случае нам пох. Т.к. больше байтов у нас нет.
	CPI  R30,LOW(0xC8)
	BRNE _0x1BE
_0x1BA:
;			{
;			if (i2c_Do & i2c_Interrupted)											// Если там была прерваная передача мастера
	LDS  R30,_i2c_Do
	ANDI R30,LOW(0x80)
	BREQ _0x1BC
;				{																	// То мы ему ее вернем
;				i2c_Do &= i2c_NoInterrupted;										// Снимем флаг прерваности
	LDS  R30,_i2c_Do
	ANDI R30,0x7F
	STS  _i2c_Do,R30
;				TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Сгенерим старт сразу же как получим шину.
	LDI  R30,LOW(229)
	RJMP _0x299
;				}
;			else
_0x1BC:
;				{
;				TWCR = 0<<TWSTA|0<<TWSTO|1<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;			// Если мы там одни, то просто отдадим шину
	LDI  R30,LOW(197)
_0x299:
	STS  116,R30
;				}
;
;			MACRO_i2c_WhatDo_SlaveOut												// И отработаем выход слейва. Впрочем, он тут
	__CALL1MN _SlaveOutFunc,0
;																					// Не особо то нужен. Разве что как сигнал, что мастер
;			break;																	// Нас почтил своим визитом.
;			}
;
;	default:	break;
_0x1BE:
;	}
_0x180:
;}
_0x2A1:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R25,Y+
	LD   R24,Y+
	LD   R23,Y+
	LD   R22,Y+
	LD   R15,Y+
	LD   R1,Y+
	LD   R0,Y+
	RETI
;
;void DoNothing(void)																// Функция пустышка, затыкать несуществующие ссылки
;{
_DoNothing:
;}
	RET
;
;void Init_i2c(void)							// Настройка режима мастера
;{
_Init_i2c:
;i2c_PORT |= 1<<i2c_SCL|1<<i2c_SDA;			// Включим подтяжку на ноги, вдруг юзер на резисторы пожмотился
	IN   R30,0x12
	ORI  R30,LOW(0x3)
	OUT  0x12,R30
;i2c_DDR &=~(1<<i2c_SCL|1<<i2c_SDA);
	IN   R30,0x11
	ANDI R30,LOW(0xFC)
	OUT  0x11,R30
;
;TWBR = 0xFF;         						// Настроим битрейт
	LDI  R30,LOW(255)
	STS  112,R30
;TWSR = 0x03;
	LDI  R30,LOW(3)
	STS  113,R30
;/*
;// Bit Rate: 400,000 kHz
;TWBR=0x02;
;// Two Wire Bus Slave Address: 0x0
;// General Call Recognition: Off
;TWAR=0x00;
;// Generate Acknowledge Pulse: Off
;// TWI Interrupt: On
;TWCR = (1<<TWIE)|(1<<TWEN) ;
;TWSR=0x00;*/
;}
	RET
;
;void Init_Slave_i2c(IIC_F Addr)				// Настройка режима слейва (если нужно)
;{
_Init_Slave_i2c:
;TWAR = i2c_MasterAddress;					// Внесем в регистр свой адрес, на который будем отзываться.
;	*Addr -> Y+0
	LDI  R30,LOW(50)
	STS  114,R30
;											// 1 в нулевом бите означает, что мы отзываемся на широковещательные пакеты
;SlaveOutFunc = Addr;						// Присвоим указателю выхода по слейву функцию выхода
	LD   R30,Y
	LDD  R31,Y+1
	STS  _SlaveOutFunc,R30
	STS  _SlaveOutFunc+1,R31
;
;TWCR = 0<<TWSTA|0<<TWSTO|0<<TWINT|1<<TWEA|1<<TWEN|1<<TWIE;		// Включаем агрегат и начинаем слушать шину.
	LDI  R30,LOW(69)
	STS  116,R30
;}
	JMP  _0x20C0008
;#include "D_i2c_AT24C_EEP/i2c_AT24C_EEP.h"
;
;
;#define HI(X) (X>>8)
;#define LO(X) (X & 0xFF)
;
;uint8_t i2c_eep_WriteByte(uint8_t SAddr,uint16_t Addr, uint8_t Byte, IIC_F WhatDo)
;{
;
;if (i2c_Do & i2c_Busy) return 0;
;	SAddr -> Y+5
;	Addr -> Y+3
;	Byte -> Y+2
;	*WhatDo -> Y+0
;
;i2c_index = 0;
;i2c_ByteCount = 3;
;
;i2c_SlaveAddress = SAddr;
;
;
;i2c_Buffer[0] = HI(Addr);
;i2c_Buffer[1] = LO(Addr);
;i2c_Buffer[2] = Byte;
;
;i2c_Do = i2c_sawp;
;
;MasterOutFunc = WhatDo;
;ErrorOutFunc = WhatDo;
;
;TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;
;
;i2c_Do |= i2c_Busy;
;
;return 1;
;}
;
;
;uint8_t i2c_eep_ReadByte(uint8_t SAddr, uint16_t Addr, uint8_t ByteNumber, IIC_F WhatDo)
;{
;if (i2c_Do & i2c_Busy) return 0;
;	SAddr -> Y+5
;	Addr -> Y+3
;	ByteNumber -> Y+2
;	*WhatDo -> Y+0
;
;i2c_index = 0;
;i2c_ByteCount = ByteNumber;
;
;i2c_SlaveAddress = SAddr;
;
;i2c_PageAddress[0] = HI(Addr);
;i2c_PageAddress[1] = LO(Addr);
;
;i2c_PageAddrIndex = 0;
;i2c_PageAddrCount = 2;
;
;i2c_Do = i2c_sawsarp;
;
;MasterOutFunc = WhatDo;
;ErrorOutFunc = WhatDo;
;
;TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;
;
;i2c_Do |= i2c_Busy;
;
;return 1;
;}
;#include <adapter.h>
;
;//initialize watchdog
;void WDT_Init(void)
;{
;#asm("cli")//disable interrupts
;#asm("wdr")//reset watchdog
;//set up WDT interrupt
;WDTCR = (1<<WDCE)|(1<<WDE);
;//Start watchdog timer with 2s prescaller
;WDTCR = (1<<WDP2)|(1<<WDP1)|(1<<WDP0);
;#asm("sei")//Enable global interrupts
;}
;/*
;//Watchdog timeout ISR
;ISR(WDT_vect)
;{
;    //Burst of fice 0.1Hz pulses
;    for (uint8_t i=0;i<4;i++)
;    {
;        //LED ON
;        PORTD|=(1<<PD2);
;        //~0.1s delay
;        _delay_ms(20);
;        //LED OFF
;        PORTD&=~(1<<PD2);
;        _delay_ms(80);
;    }
; */
;#warning This file`ll be destroyed!
;
;#include <adapter.h>
;
;#include "D_usart/usart.h"
;//#include "D_usart/usart.c"
;
;#include "global_variables.h"
;
;
;
;
;
;/*   //теперь исспользуется прерывание ртос!
;// Timer2 output compare interrupt service routine
;interrupt [TIM2_COMP] void timer2_comp_isr(void)
;{
;v_u32_SYS_TICK++;
;   //  if (USART_Get_rxCount(USART_0) > 0) //если в приёмном буфере что-то есть
;   //    {
;   //     symbol = USART_Get_Char(USART_0);
;   //     --Parser_req_state_cnt; //  Декримент счётчика вызова парсера
;
;            #warning not_optimized
;   //      if(Parser_req_state_cnt % 5 != 0) //Обычно просто ставится флаг..
;   //      {
;   //        _set(fl.Parser_Req);  //- опросить парсер в главном цикле,..
;   //      }
;   //      else //..но 1 раз в 5 прерываний он обрабатывается прямо сдесь..
;   //      {
;   //         PARS_Parser(symbol);//..если вдруг главный цикл завис
;   //      }
;   //    }
;}
;     */
;#include <adapter.h>
;
;#include "RTOS/EERTOS.h"
;#include "RTOS/EERTOSHAL.h"
; #include "D_Tasks/task_list.h"
;/*
;Обработчик результата парсера.(команд)
;Эта функция вызывается парсером после обработки
;последовательности, но при условии приема хотя бы
;одного слова.Вызывать эту функцию самому не нужно
;*/
;
;
;
;/*
;void red_blink(void){
;char t=4;
;    do{
;    LED_RED_ON;
;    delay_ms(100);
;    LED_RED_OFF;
;    delay_ms(200);
;    }while(--t);
;}  */
;
;
;uint8_t check_after_pow_on(void)     /*need optimisation*/
;{
;//uint8_t state = 0;
;
;/*#1 check periferie*/
;//if (PINA!=0){printf("P_A=%d\r",PINA);}
;//if (PINB!=0){printf("P_B=%d\r",PINB);}
;//if (PINC!=0){printf("P_C=%d\r",PINC);}
;//if (PIND!=0){printf("P_D=%d\r\n",PIND);}
;
;
;/*#2 check reset source*/
;/*The MCU Control and Status Register provides
;information on which reset source caused an MCU Reset*/
;if (MCUCSR & (1<<PORF))// Power-on Reset
;   {
;    Put_In_Log("porf"); //now \r\n concat in Put_In_Log
;   }
;else if (MCUCSR & (1<<EXTRF))// External Reset
;   {
;    Put_In_Log("extrf");
;   }
;else if (MCUCSR & (1<<BORF))// Brown-Out Reset
;   {
;   Put_In_Log("borf");
;   }
;else if (MCUCSR & (1<<WDRF))// Watchdog Reset
;   {
;    Put_In_Log("wdrf");
;   }
;else if (MCUCSR & (1<<JTRF))// JTAG Reset
;   {
;    Put_In_Log("JTRF");
;   }
;
;MCUCSR&=~((1<<JTRF) | (1<<WDRF) | (1<<BORF) | (1<<EXTRF) | (1<<PORF));//clear register
;return 0;
;}

	.DSEG
_0x1C2:
	.BYTE 0x1A
;
;
;void TIM2_ON(void){

	.CSEG
;//TCCR2 |= (1<<CS21)|(1<<CS20);
;TCCR2 |= (1<<CS22)|(1<<CS21)|(1<<CS20);
;
;}
;
;void TIM2_OFF(void){
;//TCCR2 &= ~((1<<CS21)|(1<<CS20));
;TCCR2 &= ~((1<<CS22)|(1<<CS21)|(1<<CS20));
;}
;
;void Sys_timer_init(void){ //USED BY RTOS (DONT TOUCH!)
;//Settings for Timer2
;OCR2 = 125; //125000 /125 = 1000 compare interruptes per second
;TCCR2 |= (1<<CS21)|(1<<CS20);//START timer (8Mhz div 64 = 125000)   //Upd-5 теперь 16МГц
;TIMSK |= (1<<OCIE2); //compare interrupt EN
;}
;
;
;void print_help(void){
;StopRTOS();
;USART_Send_StrFl(SYSTEM_USART, help_mess_0);
;USART_Send_StrFl(SYSTEM_USART, help_mess_1);
;USART_Send_StrFl(SYSTEM_USART, help_mess_2);
;USART_Send_StrFl(SYSTEM_USART, help_mess_3);
;USART_Send_StrFl(SYSTEM_USART, help_mess_4);
;
;USART_Send_StrFl(SYSTEM_USART,help_Uart_0);
;USART_Send_StrFl(SYSTEM_USART,help_Uart_1);
;USART_Send_StrFl(SYSTEM_USART,help_Spi_0);
;USART_Send_StrFl(SYSTEM_USART,help_Spi_1);
;RunRTOS();
;}
;
;void print_settings_ram(void){
;uint8_t i = 0;
;char str[10];
;
;USART_Send_Str(SYSTEM_USART,"\r<RAM>");
;	i -> R17
;	str -> Y+1
;USART_Send_Str(SYSTEM_USART,"\rUART_SETTINGS\r");
;  for(i=0;i<COUNT_OF_UARTS;i++)
;    {
;    USART_Send_Str(SYSTEM_USART,"UART ");
;    itoa(i,str);
;    USART_Send_Str(SYSTEM_USART,str); //convert dec to str
;
;    USART_Send_Str(SYSTEM_USART,"\r Mode ");
;    itoa(RAM_settings.MODE_of_Uart[i],str);
;    USART_Send_Str(USART_0,str); //convert dec to str
;
;    USART_Send_Str(SYSTEM_USART,"\r Speed ");
;    itoa(RAM_settings.baud_of_Uart[i],str);
;    USART_Send_Str(SYSTEM_USART,str); //convert dec to str
;
;    USART_Send_Str(SYSTEM_USART,"\r--------\r");
;    }
;
;USART_Send_Str(SYSTEM_USART,"\rSPI_SETTINGS\r");
;  for(i=0;i<COUNT_OF_SPI;i++)
;    {
;    USART_Send_Str(SYSTEM_USART,"SPI ");
;    itoa(i,str);
;    USART_Send_Str(SYSTEM_USART,str); //convert dec to str
;
;    USART_Send_Str(SYSTEM_USART,"\r Mode ");
;    itoa(RAM_settings.MODE_of_Spi[i],str);
;    USART_Send_Str(SYSTEM_USART,str); //convert dec to str
;
;    USART_Send_Str(SYSTEM_USART,"\r Prescaller ");
;    itoa(RAM_settings.prescaller_of_Spi[i],str);
;    USART_Send_Str(SYSTEM_USART,str); //convert dec to str
;
;    USART_Send_Str(SYSTEM_USART,"\r--------\r");
;    }
;//USART_FlushTxBuf(USART_0);
;}

	.DSEG
_0x1CB:
	.BYTE 0x6E
;
;void print_settings_eeprom(void){

	.CSEG
;uint8_t i = 0;
;char str[10];
;
;USART_Send_Str(USART_0,"\r<EEPROM>");
;	i -> R17
;	str -> Y+1
;USART_Send_Str(USART_0,"\rUART_SETTINGS\r");
;  for(i=0;i<COUNT_OF_UARTS;i++)
;    {
;    USART_Send_Str(USART_0,"UART ");
;    itoa(i,str);
;    USART_Send_Str(USART_0,str); //convert dec to str
;
;    USART_Send_Str(USART_0,"\r Mode ");
;    itoa(EE_settings.MODE_of_Uart[i],str);
;    USART_Send_Str(USART_0,str); //convert dec to str
;
;    USART_Send_Str(USART_0,"\r Speed ");
;    itoa(EE_settings.baud_of_Uart[i],str);
;    USART_Send_Str(USART_0,str); //convert dec to str
;
;    USART_Send_Str(USART_0,"\r--------\r");
;    }
;
;USART_Send_Str(USART_0,"\rSPI_SETTINGS\r");
;  for(i=0;i<COUNT_OF_SPI;i++)
;    {
;    USART_Send_Str(USART_0,"SPI ");
;    itoa(i,str);
;    USART_Send_Str(USART_0,str); //convert dec to str
;
;    USART_Send_Str(USART_0,"\r Mode ");
;    itoa(EE_settings.MODE_of_Spi[i],str);
;    USART_Send_Str(USART_0,str); //convert dec to str
;
;    USART_Send_Str(USART_0,"\r Prescaller ");
;    itoa(EE_settings.prescaller_of_Spi[i],str);
;    USART_Send_Str(USART_0,str); //convert dec to str
;
;    USART_Send_Str(USART_0,"\r--------\r");
;    }
;//USART_FlushTxBuf(USART_0);
;}

	.DSEG
_0x1D2:
	.BYTE 0x71
;
;
;void print_sys(void)
;{

	.CSEG
;char str[5];
;USART_Send_Str(SYSTEM_USART,"\rButes_RX ");
;	str -> Y+0
;itoa(v_u32_RX_CNT,str);
;USART_Send_Str(SYSTEM_USART,str); //convert dec to str
;
;USART_Send_Str(SYSTEM_USART,"\rButes_TX ");
;itoa(v_u32_TX_CNT,str);
;USART_Send_Str(SYSTEM_USART,str); //convert dec to str
;}

	.DSEG
_0x1D9:
	.BYTE 0x16
;
;
;void RingBuff_TX(void)
;{

	.CSEG
_RingBuff_TX:
;  UCSR0B |= (1 << UDRIE0); // TX int - on
	SBI  0xA,5
;}
	RET
;
;#warning TODO
;uint8_t get_curr_cpu_freq (void) //возвращает значение текущей частоты работы мк
;{
;uint8_t freq = 0;
;  //TODO
;return freq;
;	freq -> R17
;}
;
;#warning отладить!
;void cust_delay_ms(uint16_t delay){ //умная задержка
;uint32_t timecnt = v_u32_SYS_TICK + delay;
;while (v_u32_SYS_TICK < timecnt){}
;	delay -> Y+4
;	timecnt -> Y+0
;}
;
;
;
;
;//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;//RLE_array pack/unpack funktions
;
;int RLE_pack (unsigned char* src,unsigned char* dst, uint16_t src_size)
;{
;uint8_t tmp_symb = src[0];
;uint16_t tmp_cnt = 1;
;uint16_t k = 0;
;uint16_t i = 1;
;
; for(i = 1; i<src_size+1; i++)
;	*src -> Y+12
;	*dst -> Y+10
;	src_size -> Y+8
;	tmp_symb -> R17
;	tmp_cnt -> R18,R19
;	k -> R20,R21
;	i -> Y+6
;    {
;       if(src[i] == tmp_symb){tmp_cnt++;}
;       else
;        {
;            dst[k] = tmp_cnt; k++;
;            dst[k] = tmp_symb; k++;
;
;            tmp_symb = src[i];
;            tmp_cnt = 1;
;       }
;    }
; return k;   //return new_sise
;}
;
;int RLE_unpack (flash unsigned char* src, unsigned char* dst, uint16_t src_size)
;{
;uint8_t tmp_symb = 0;
;uint8_t tmp_cnt = 0;
;uint16_t i;
;uint16_t j;
;uint16_t k=0;
;
; for(i = 0; i<src_size; i+=2)
;	*src -> Y+12
;	*dst -> Y+10
;	src_size -> Y+8
;	tmp_symb -> R17
;	tmp_cnt -> R16
;	i -> R18,R19
;	j -> R20,R21
;	k -> Y+6
;    {
;        tmp_cnt = src[i];
;        tmp_symb = src[i+1];
;        for(j = 0; j < tmp_cnt; j++)
;        {
;            dst[k++] = tmp_symb;
;        }
;    }
; return src_size+k;   //new_sise
;}
;//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;
;/**
;void cust_ltoa(long int n, char *str;)
;{
;unsigned long i;
;unsigned char j,p;
;i=1000000000L;
;p=0;
;if (n<0)
;   {
;   n=-n;
;   *str++='-';
;   };
;do
;  {
;  j=(unsigned char) (n/i);
;  if (j || p || (i==1))
;     {
;     *str++=j+'0';
;     p=1;
;     }
;  n%=i;
;  i/=10L;
;  } while (i!=0);
;   *str = 0;
;}
;*/
;
;void SheikerSort(uint8_t *a, int n)  // 114words - 50elem=5ms; 100elem=20ms
;{
;           int8_t l, r, i, k;
;           int tmp;
;           k = l = 0;
;	*a -> Y+8
;	n -> Y+6
;	l -> R17
;	r -> R16
;	i -> R19
;	k -> R18
;	tmp -> R20,R21
;           r = n - 2;
;
;           while(l <= r)
;           {
;              for(i = l; i <= r; ++i)
;              {
;                 if (a[i] > a[i+1])
;                 {
;                 tmp = a[i];
;                 a[i] = a[i+1];
;                 a[i+1] = tmp;
;                   /* a[i] ^= a[i+1]; //More memory and time!
;                    a[i+1] ^= a[i];
;                    a[i] ^= a[i+1]; */
;                    k = i;
;                 }
;              }
;              r = k - 1;
;
;              for(i = r; i >= l; --i)
;               {
;                 if (a[i] > a[i+1])
;                 {
;                 tmp = a[i];
;                 a[i] = a[i+1];
;                 a[i+1] = tmp;
;                    /*a[i] ^= a[i+1]; //More memory and time!
;                    a[i+1] ^= a[i];
;                    a[i] ^= a[i+1];*/
;                    k = i;
;                 }
;               }
;              l = k + 1;
;           }
;}
;
;void BubbleSort(uint8_t *arr, int n) //89words - 50elem=6,4ms; 100elem=26ms
;{
;      bit swapped = true;
;      int i = 0;
;      int j = 0;
;      int tmp;
;
;      while (swapped)
;	*arr -> Y+8
;	n -> Y+6
;	swapped -> R15.0
;	i -> R16,R17
;	j -> R18,R19
;	tmp -> R20,R21
;      {
;            swapped = false;
;            j++;
;            for (i = 0; i < n - j; i++)
;            {
;                  if (arr[i] > arr[i + 1])
;                  {
;                        tmp = arr[i];
;                        arr[i] = arr[i + 1];
;                        arr[i + 1] = tmp;
;                        swapped = true;
;                  }
;
;            }
;
;      }
;}
;//Определение всех задач для RTOS
;
;#include "task_list.h"
;//============================================================================
;//Область задач
;//============================================================================
;
;
;DECLARE_TASK(Task_Initial) //стартует первым, запускает все задачи
;{
_Task_Initial:
;//SetTimerTask(Task_t_props_out,10);
;
;
;SetTimerTask(Task_Start,700,10);     //blink led
	LDI  R30,LOW(_Task_Start)
	LDI  R31,HIGH(_Task_Start)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(700)
	LDI  R31,HIGH(700)
	CALL SUBOPT_0x2F
;SetTimerTask(Task_LoadTest, 900, 500); //запуск тестового таска для проверки загрузки цп
	LDI  R30,LOW(_Task_LoadTest)
	LDI  R31,HIGH(_Task_LoadTest)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(900)
	LDI  R31,HIGH(900)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(500)
	LDI  R31,HIGH(500)
	CALL SUBOPT_0x30
;///-----------------Upd-7-----------------------------
;// первичный запуск всех задач
;//SetTimerTask(Task_pars_cmd,5,100); //Upd-6
;
;#ifdef DEBUG                    //Upd-6
;SetTimerTask(Task_LogOut, 50, 50);
	LDI  R30,LOW(_Task_LogOut)
	LDI  R31,HIGH(_Task_LogOut)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(50)
	LDI  R31,HIGH(50)
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x30
;SetTask(Task_LcdGreetImage);    //Upd-4
	LDI  R30,LOW(_Task_LcdGreetImage)
	LDI  R31,HIGH(_Task_LcdGreetImage)
	CALL SUBOPT_0x31
;//SetTimerTask(Task_ADC_test,5000);   //Upd-6
;//SetTimerTask(Task_AdcOnLcd, 6000);
;//SetTimerTask(Task_BuffOut,5);
;#endif
;///---------------------------------------------------
; SetTimerTask(Task_1ms, 55, 10);
	LDI  R30,LOW(_Task_1ms)
	LDI  R31,HIGH(_Task_1ms)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(55)
	LDI  R31,HIGH(55)
	CALL SUBOPT_0x2F
; SetTimerTask(Task3_1ms, 250, 250);
	LDI  R30,LOW(_Task3_1ms)
	LDI  R31,HIGH(_Task3_1ms)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(250)
	LDI  R31,HIGH(250)
	ST   -Y,R31
	ST   -Y,R30
	CALL SUBOPT_0x30
;
;
; SetTimerTask(Task_ADC_test, 200, 440);
	LDI  R30,LOW(_Task_ADC_test)
	LDI  R31,HIGH(_Task_ADC_test)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(200)
	LDI  R31,HIGH(200)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(440)
	LDI  R31,HIGH(440)
	CALL SUBOPT_0x30
; //SetTimerTask(Task_AdcOnLcd, 230, 77); //загрузка 100%!!
; SetTimerTask(Task_BuffOut, 180,  333);
	LDI  R30,LOW(_Task_BuffOut)
	LDI  R31,HIGH(_Task_BuffOut)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(180)
	LDI  R31,HIGH(180)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(333)
	LDI  R31,HIGH(333)
	CALL SUBOPT_0x30
;
; SetTimerTask(Task_t_props_out,1000,42);
	LDI  R30,LOW(_Task_t_props_out)
	LDI  R31,HIGH(_Task_t_props_out)
	CALL SUBOPT_0x32
	LDI  R30,LOW(42)
	LDI  R31,HIGH(42)
	RJMP _0x20C000A
;}
;
;DECLARE_TASK(Sorting)
;{
;KERNEL_Sort_TaskQueue(); //sorting task list
;//Put_In_Log("SH\r\n");
;}
;
;DECLARE_TASK(Task_ClearTS)//clr task test
;{
;ClearTimerTask(Task_Initial);
;ClearTimerTask(Task_LoadTest);
;ClearTimerTask(Task_LogOut);
;ClearTimerTask(Task_1ms);
;ClearTimerTask(Task3_1ms);
;ClearTimerTask(Task_ClearTS);
; SetTimerTask(Task_Initial, 1700, 1700);
;}
;
;DECLARE_TASK(Task_1ms)
;{
_Task_1ms:
;delay_ms(8);
	LDI  R30,LOW(8)
	LDI  R31,HIGH(8)
	CALL SUBOPT_0x8
;
;//LED_PORT.LED2^=1;
;//Put_In_Log("Task_10ms\r\n");
;//LED_PORT |= (1<<LED2);
;//SetTimerTask(Task_1ms,5,5); //запуск мигалки-антизависалки
;//LED_PORT  &= ~(1<<LED2);
;}
	RET
;
;DECLARE_TASK(Task2_1ms)
;{
;//LED_PORT.LED2^=1;
;LED_PORT |= (1<<LED3);
;//SetTimerTask(Task2_1ms,5); //запуск мигалки-антизависалки
;LED_PORT  &= ~(1<<LED3);
;}
;DECLARE_TASK(Task3_1ms)   //на 4800 бод - 15символов перед за 50мс
;{
_Task3_1ms:
;//Put_In_Log("Task3_250ms\r\n");
;//SetTimerTask(Task3_1ms,500, 500); //при таких данных почти безлаговая предача при разнесении во времени на 5мс
;}
	RET
;
;
;
;DECLARE_TASK(Task_LoadTest)    //8ms!
;{
_Task_LoadTest:
; int Tick =0;
; Tick = v_u32_SYS_TICK;
	CALL SUBOPT_0x7
;	Tick -> R16,R17
	__GETWRMN 16,17,0,_v_u32_SYS_TICK
;
;//Put_In_Log("T_L_T\r\n");
;
;  //LcdClear();
;_LCD_SHOWVAL(Tick); // = sprintf (lcd_buf, "Tick=%i",v_u32_SYS_TICK);  // 500us
	LDI  R30,LOW(_lcd_buf)
	LDI  R31,HIGH(_lcd_buf)
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1FN _0x0,149
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R16
	CALL __CWD1
	CALL __PUTPARD1
	LDI  R24,4
	CALL _sprintf
	ADIW R28,8
; LcdString(1,2);
	LDI  R30,LOW(1)
	ST   -Y,R30
	LDI  R30,LOW(2)
	ST   -Y,R30
	CALL _LcdString
;_LCD_STRINBUF("Ololo=)");
	LDI  R30,LOW(_lcd_buf)
	LDI  R31,HIGH(_lcd_buf)
	ST   -Y,R31
	ST   -Y,R30
	__POINTW1MN _0x1FA,0
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(15)
	ST   -Y,R30
	CALL _strncpy
; LcdString(1,4);
	LDI  R30,LOW(1)
	ST   -Y,R30
	LDI  R30,LOW(4)
	ST   -Y,R30
	CALL _LcdString
; LcdUpdate();
	CALL _LcdUpdate
;//SetTimerTask(Task_LoadTest, 1000, 1000);; //запуск тестового таска для проверки загрузки цп
;
;}
	RJMP _0x20C0009

	.DSEG
_0x1FA:
	.BYTE 0x8
;
;DECLARE_TASK(Task_Start)
;{

	.CSEG
_Task_Start:
;LED_PORT.LED2^=1; //запуск мигалки-антизависалки
	LDI  R26,0
	SBIC 0x12,7
	LDI  R26,1
	LDI  R30,LOW(1)
	EOR  R30,R26
	BRNE _0x1FB
	CBI  0x12,7
	RJMP _0x1FC
_0x1FB:
	SBI  0x12,7
_0x1FC:
;}
	RET
;
;DECLARE_TASK (Task_LedOff)
;{
;//SetTimerTask(Task_LedOn, 900, 900);
;LED_PORT  &= ~(1<<LED2);
;}
;
;DECLARE_TASK (Task_LedOn)
;{
;//SetTimerTask(Task_LedOff,100,100);
;LED_PORT  |= (1<<LED2);
;}
;
;/*
;DECLARE_TASK (Task_t_props_out)
;{
;uint8_t index = 0;
;char tmp_str[10];
;
; FullStopRTOS();
;    // LED_PORT  &=~(1<<LED2);
;  for(index=0;index!=timers_cnt_tail;++index)	// ищем таймер
;	{          //отладить ниже
;     Put_In_Log("\r\n<");
;     itoa((int)TTask[index].hndl , tmp_str);
;     Put_In_Log(tmp_str); Put_In_Log(",");
;     itoa((int)TTask[index].TaskDelay , tmp_str);
;     Put_In_Log(tmp_str); Put_In_Log(",");
;     itoa((int)TTask[index].TaskPeriod , tmp_str);
;     Put_In_Log(tmp_str); Put_In_Log(",");
;     itoa((int)TTask[index].sys_tick_time , tmp_str);   TTask[index].sys_tick_time = 0;
;     Put_In_Log(tmp_str); Put_In_Log(",");
;     itoa((int)TTask[index].exec_time , tmp_str);       TTask[index].exec_time = 0;
;     Put_In_Log(tmp_str); Put_In_Log(",");
;     itoa((int)TTask[index].TaskStatus , tmp_str);            TTask[index].flag = 0;
;     Put_In_Log(tmp_str);
;     Put_In_Log(">");
;  }
; // LED_PORT  |=(1<<LED2);
; Put_In_Log("\r\n");
; Task_LogOut();
; RunRTOS();
;}
;*/
;
;DECLARE_TASK (Task_ADC_test) //Upd-6     //для проверки освещённоси помещения
; {
_Task_ADC_test:
; #warning no Lcd_out// sprintf (lcd_buf, "DummyADC=%d ",volt);      // вывод на экран результата
; LcdString(1,1);   LcdUpdate();
	LDI  R30,LOW(1)
	ST   -Y,R30
	ST   -Y,R30
	CALL _LcdString
	CALL _LcdUpdate
; //SetTimerTask(Task_ADC_test,5000, 5000);
; }
	RET
;
;
;void Task_LcdGreetImage (void) //Greeting image on start    //Upd-4
;{
_Task_LcdGreetImage:
;//SetTask(LcdClear);
;//SetTask(Task_LcdLines);
;
;#warning RLE_unpack doesn`t work
;//unsigned char tmp_unpk_buf[504];
;//unsigned char tmp_src_buf[504];
;//memcpy(tmp_unpk_buf,(void*)rad2Image,504);
;//RLE_unpack(rad1Image, LcdCache, 230);
;//LcdImageRam(tmp_unpk_buf);  SetTimerTask(LcdClear,1000,0);
;LcdImage(rad2Image);  SetTimerTask(LcdClear,1000,0);
	LDI  R30,LOW(_rad2Image*2)
	LDI  R31,HIGH(_rad2Image*2)
	ST   -Y,R31
	ST   -Y,R30
	CALL _LcdImage
	LDI  R30,LOW(_LcdClear)
	LDI  R31,HIGH(_LcdClear)
	CALL SUBOPT_0x32
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	CALL SUBOPT_0x30
; /*
; //sprintf (lcd_buf, "  Interface   ");
; strncpy (lcd_buf, "  Interface   ", 15);
; LcdStringBig(1,1);
;  strncpy(lcd_buf, " Monitor v2.1 ", 15);
; LcdString(1,3);
; strncpy (lcd_buf, " Хмелевськой  ", 15);
; LcdString(1,4);
; strncpy (lcd_buf, "  Владислав   ", 15);
; LcdString(1,5);
; strncpy (lcd_buf, "  АЕ - 104    ", 15);
; LcdString(1,6);  */
;LcdUpdate();
	CALL _LcdUpdate
;SetTimerTask(LcdClear,2000,0);
	LDI  R30,LOW(_LcdClear)
	LDI  R31,HIGH(_LcdClear)
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(2000)
	LDI  R31,HIGH(2000)
	CALL SUBOPT_0x33
_0x20C000A:
	ST   -Y,R31
	ST   -Y,R30
	CALL _SetTimerTask
;
;// sprintf (lcd_buf, "Wait comand...");      //не работает
;// LcdStringBig(1,3);
;// SetTimerTask(LcdUpdate,8000);
;}
	RET
;
;void Task_LcdLines (void)      //Upd-4       //сильно грузит!
;{
;    	for (i=0; i<84; i++)
;        {
;		LcdLine ( 0, 47, i, 0, 1);
;        LcdLine ( 84, 47, 84-i, 0, 1);
;		LcdUpdate();
;		}
;}
;
;void Task_AdcOnLcd (void)
;{
;//SetTask(LcdClear);
; /*sprintf (lcd_buf, "vref=%d ",vref);      // вывод на экран результата
; LcdString(1,1);
;  sprintf (lcd_buf, "d=%d ",d);      // вывод на экран результата
; LcdString(1,2);
;  sprintf (lcd_buf, "delta=%d ",delta);      // вывод на экран результата
; LcdString(1,3);
;  sprintf (lcd_buf, "volt=%d ",volt);      // вывод на экран результата
; LcdString(1,4);  */
; LcdClear();
; ADC_use();
;#warning disabled sprintf (lcd_buf, "Напряжение на");
; LcdString(1,2);
;#warning disabled sprintf (lcd_buf, "  канале 0");
; LcdString(1,3);
;#warning disabled sprintf (lcd_buf, "= %d мВ",adc_result);
; LcdString(1,4);
;
; LcdUpdate();
;}
;
;//#error Проверить!
;DECLARE_TASK (Task_pars_cmd)         //300us? empty buff
;{
;char scan_interval = 100;
;  if (USART_Get_rxCount(SYSTEM_USART) > 0) //если в приёмном буфере что-то есть
;	scan_interval -> R17
;       {
;        symbol = USART_Get_Char(SYSTEM_USART);
;        PARS_Parser(symbol);
;        //SetTask(Task_pars_cmd);  //Проверить!
;        scan_interval = 5;
;       }
;// else{scan_interval = 100;};
;SetTimerTask(Task_pars_cmd, 0, scan_interval); //25   //Проверить!
;}
;
;
;DECLARE_TASK (Task_FlagsHandler)
;{
_Task_FlagsHandler:
;char tmp_str[5];
;  switch(g_tcf)
	SBIW R28,5
;	tmp_str -> Y+0
	CALL SUBOPT_0x4
;  {
;    case ERR_UNDEF_FLAG:
	SBIW R30,0
	BRNE _0x204
;                        Put_In_Log("\r ERR_UNDEF_FLAG ");
	__POINTW1MN _0x205,0
	CALL SUBOPT_0x34
;                        itoa(g_tcf,tmp_str);Put_In_Log(tmp_str);
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,2
	CALL SUBOPT_0x35
	MOVW R30,R28
	CALL SUBOPT_0x34
;                        FLAG_CLR(g_tcf,ERR_UNDEF_FLAG);
	ANDI R30,LOW(0xFFFE)
	CALL SUBOPT_0x5
;    //break;
;   case S_SPI_BUF_CLR: SetTask(Task_SPI_ClrBuf); FLAG_CLR(g_tcf,S_SPI_BUF_CLR);
	RJMP _0x206
_0x204:
	CPI  R30,LOW(0x1)
	LDI  R26,HIGH(0x1)
	CPC  R31,R26
	BRNE _0x207
_0x206:
	LDI  R30,LOW(_Task_SPI_ClrBuf)
	LDI  R31,HIGH(_Task_SPI_ClrBuf)
	CALL SUBOPT_0x31
	CALL SUBOPT_0x4
	ANDI R30,LOW(0xFFFD)
	CALL SUBOPT_0x5
;    //break;
;   case FLUSH_WORKLOG: SetTask(Task_Flush_WorkLog);FLAG_CLR(g_tcf,FLUSH_WORKLOG);
	RJMP _0x208
_0x207:
	CPI  R30,LOW(0x2)
	LDI  R26,HIGH(0x2)
	CPC  R31,R26
	BRNE _0x20A
_0x208:
	LDI  R30,LOW(_Task_Flush_WorkLog)
	LDI  R31,HIGH(_Task_Flush_WorkLog)
	CALL SUBOPT_0x31
	CALL SUBOPT_0x4
	ANDI R30,LOW(0xFFFB)
	CALL SUBOPT_0x5
;    //break;
;    default:
_0x20A:
;    FLAG_SET(g_tcf, ERR_UNDEF_FLAG);
	CALL SUBOPT_0x4
	ORI  R30,1
	CALL SUBOPT_0x5
;    break;
;    }
;}
	JMP  _0x20C0002

	.DSEG
_0x205:
	.BYTE 0x12
;
;
;DECLARE_TASK (Task_LogOut)           //500us ?
;{

	.CSEG
_Task_LogOut:
;//SetTimerTask(Task_LogOut,50,50);
;if(LogIndex){LogOut();} //если что-то есть в лог буфере - вывести
	LDS  R30,_LogIndex_G000
	LDS  R31,_LogIndex_G000+1
	SBIW R30,0
	BREQ _0x20B
	CALL _LogOut
;}
_0x20B:
	RET
;
;
;void Task_Flush_WorkLog(void) //очистка лог буффера
;{
_Task_Flush_WorkLog:
;uint16_t i = 0;
;//LED_PORT |= (1<<LED2);
;while(i<512){WorkLog[i] = 0; i++;};
	CALL SUBOPT_0x7
;	i -> R16,R17
_0x20C:
	__CPWRN 16,17,512
	BRSH _0x20E
	LDI  R26,LOW(_WorkLog_G000)
	LDI  R27,HIGH(_WorkLog_G000)
	ADD  R26,R16
	ADC  R27,R17
	LDI  R30,LOW(0)
	ST   X,R30
	__ADDWRN 16,17,1
	RJMP _0x20C
_0x20E:
;//LED_PORT &=~(1<<LED2);
;}
_0x20C0009:
	LD   R16,Y+
	LD   R17,Y+
	RET
;
;
;void Task_SPI_ClrBuf (void){ //очистка rx/tx буфферов SPI
_Task_SPI_ClrBuf:
;uint8_t i;
;for(i=0;i<64;i++)
	ST   -Y,R17
;	i -> R17
	LDI  R17,LOW(0)
_0x210:
	CPI  R17,64
	BRSH _0x211
; {
;Spi0_RX_buf[i] = 0;
	CALL SUBOPT_0xA
	SUBI R30,LOW(-_Spi0_RX_buf_G000)
	SBCI R31,HIGH(-_Spi0_RX_buf_G000)
	LDI  R26,LOW(0)
	STD  Z+0,R26
;Spi0_TX_buf[i] = 0;
	CALL SUBOPT_0xA
	SUBI R30,LOW(-_Spi0_TX_buf_G000)
	SBCI R31,HIGH(-_Spi0_TX_buf_G000)
	LDI  R26,LOW(0)
	STD  Z+0,R26
;  //if(i<=SIZE_SPI_BUF_TX){Spi0_TX_buf[i] = 0;}
; }
	SUBI R17,-1
	RJMP _0x210
_0x211:
;}
	JMP  _0x20C0007
;
; void Task_BuffOut  (void)  //выдача принятых по Юарт1 днн сразу в прерывании
; {
_Task_BuffOut:
;  //SetTimerTask(Task_BuffOut,50,50);
;  RingBuff_TX();
	RCALL _RingBuff_TX
; }
	RET
;
;//=================================================
;//////////////////////////I2C//////////////////////
;
;//============================================================================
;//Область задач
;//============================================================================
;
;// Записываем в ЕЕПРОМ байт.
;void EEP_StartWrite(void)
;{
;if (!i2c_eep_WriteByte(0xA0,0x00FF,/*(char)Usart0_RX_buf[15]*/ 9,&EEP_Writed))    // Если байт незаписался
;    {
;    SetTimerTask(EEP_StartWrite,50,50);                        // Повторить попытку через 50мс
;    }
;}
;
;// Точка выхода из автомата по записи в ЕЕПРОМ
;void EEP_Writed(void)
;{
;i2c_Do &= i2c_Free;                                            // Освобождаем шину
;
;if(i2c_Do & (i2c_ERR_NA|i2c_ERR_BF))                        // Если запись не удалась
;    {
;    SetTimerTask(EEP_StartWrite,20,20);                        // повторяем попытку
;    }
;else
;    {
;    SetTask(IIC_Send_Addr_ToSlave);        		// Если все ок, то идем на следующий
;	}											// Пункт задания - передача данных слейву 2
;}
;
;// Обращение к SLAVE контроллеру
;void IIC_Send_Addr_ToSlave(void)
;{
;if (i2c_Do & i2c_Busy)						// Если передатчик занят
;		{
;		SetTimerTask(IIC_Send_Addr_ToSlave,100,100);	// То повторить через 100мс
;		}
;
;i2c_index = 0;								// Сброс индекса
;i2c_ByteCount = 2;							// Шлем два байта
;
;i2c_SlaveAddress = 0xB0;					// Адрес контроллера 0xB0
;
;i2c_Buffer[0] = 0x00;						// Те самые два байта, что мы шлем подчиненному
;i2c_Buffer[1] = 0xFF;
;
;i2c_Do = i2c_sawp;							// Режим = простая запись, адрес+два байта данных
;
;MasterOutFunc = &IIC_SendeD_Addr_ToSlave;			// Точка выхода из автомата если все хорошо
;ErrorOutFunc = &IIC_SendeD_Addr_ToSlave;			// И если все плохо.
;
;TWCR = 1<<TWSTA|0<<TWSTO|1<<TWINT|0<<TWEA|1<<TWEN|1<<TWIE;		// Поехали!
;i2c_Do |= i2c_Busy;												// Шина занята!
;}
;
;
;// Выход из автомата IIC
;void IIC_SendeD_Addr_ToSlave(void)
;{
;i2c_Do &= i2c_Free;							// Освобождаем шину
;
;if(i2c_Do & (i2c_ERR_NA|i2c_ERR_BF))		// Если адресат нас не услышал или был сбой на линии
;	{
;	SetTimerTask(IIC_Send_Addr_ToSlave,20,20);		// Повторить попытку
;	}
;}
;
;
;// Если словили свой адрес и приняли данные
;void SlaveControl(void)
;{
_SlaveControl:
;i2c_Do &= i2c_Free;				// Освобождаем шину
	LDS  R30,_i2c_Do
	ANDI R30,0xBF
	STS  _i2c_Do,R30
;UDR0 = i2c_InBuff[0];			// Выгружаем принятый байт
	LDS  R30,_i2c_InBuff
	OUT  0xC,R30
;}
	RET
;
;//==============================================================================
;#include "init.c"
;#include <adapter.h>
;
;inline void GPIO_init(void){
; 0000 0010 inline void GPIO_init(void){
_GPIO_init:
;PORTA=0x00; DDRA=0x00;
	LDI  R30,LOW(0)
	OUT  0x1B,R30
	OUT  0x1A,R30
;PORTB=0x00; DDRB=0x07;
	OUT  0x18,R30
	LDI  R30,LOW(7)
	OUT  0x17,R30
;PORTC=0x00; DDRC=0x00;
	LDI  R30,LOW(0)
	OUT  0x15,R30
	OUT  0x14,R30
;PORTD=0x00; DDRD=0x00;
	OUT  0x12,R30
	OUT  0x11,R30
;PORTE=0x00; DDRE=0x00;
	OUT  0x3,R30
	OUT  0x2,R30
;PORTF=0x00; DDRF=0x00;
	CALL SUBOPT_0x18
;PORTG=0x00; DDRG=0x00;
	LDI  R30,LOW(0)
	STS  101,R30
	STS  100,R30
;}
	RET
;
;
;inline void TIM_0_init(void){// Timer/Counter 0 initialization
_TIM_0_init:
;// Clock source: System Clock
;// Clock value: Timer 0 Stopped
;// Mode: Normal top=0xFF
;// OC0 output: Disconnected
;ASSR=0x00;
	LDI  R30,LOW(0)
	OUT  0x30,R30
;TCCR0=0x00;
	OUT  0x33,R30
;TCNT0=0x00;
	OUT  0x32,R30
;OCR0=0x00;
	OUT  0x31,R30
;}
	RET
;
;inline void TIM_1_init(void){// Timer/Counter 1 initialization
_TIM_1_init:
;TCCR1A=0x00;    TCCR1B=0x00;
	LDI  R30,LOW(0)
	OUT  0x2F,R30
	OUT  0x2E,R30
;TCNT1H=0x00;    TCNT1L=0x00;
	OUT  0x2D,R30
	OUT  0x2C,R30
;ICR1H=0x00;     ICR1L=0x00;
	OUT  0x27,R30
	OUT  0x26,R30
;OCR1AH=0x00;    OCR1AL=0x00;
	OUT  0x2B,R30
	OUT  0x2A,R30
;OCR1BH=0x00;    OCR1BL=0x00;
	OUT  0x29,R30
	OUT  0x28,R30
;OCR1CH=0x00;    OCR1CL=0x00;
	STS  121,R30
	STS  120,R30
;}
	RET
;
;inline void TIM_2_init(void){// Timer/Counter 2 initialization
_TIM_2_init:
;TCCR2=0x00;
	LDI  R30,LOW(0)
	OUT  0x25,R30
;TCNT2=0x00;
	OUT  0x24,R30
;OCR2=0x00;
	OUT  0x23,R30
;}
	RET
;
;inline void TIM_3_init(void){ // Timer/Counter 3 initialization
_TIM_3_init:
;TCCR3A=0x00;    TCCR3B=0x00;
	LDI  R30,LOW(0)
	STS  139,R30
	STS  138,R30
;TCNT3H=0x00;    TCNT3L=0x00;
	STS  137,R30
	STS  136,R30
;ICR3H=0x00;     ICR3L=0x00;
	STS  129,R30
	STS  128,R30
;OCR3AH=0x00;    OCR3AL=0x00;
	STS  135,R30
	STS  134,R30
;OCR3BH=0x00;    OCR3BL=0x00;
	STS  133,R30
	STS  132,R30
;OCR3CH=0x00;    OCR3CL=0x00;
	STS  131,R30
	STS  130,R30
;}
	RET
;
;inline void INT_init(void){// External Interrupt(s) initialization
_INT_init:
;// INTx: Off
;EICRA=0x00;
	LDI  R30,LOW(0)
	STS  106,R30
;EICRB=0x00;
	OUT  0x3A,R30
;EIMSK=0x00;
	OUT  0x39,R30
;
;// Timer(s)/Counter(s) Interrupt(s) initialization
;TIMSK=0x00;
	OUT  0x37,R30
;ETIMSK=0x00;
	STS  125,R30
;}
	RET
;
;
;inline void USART_0_init(void){// USART0 initialization
_USART_0_init:
;// Communication Parameters: 8 Data, 1 Stop, No Parity
;// USART0 Receiver: On
;// USART0 Transmitter: On
;// USART0 Mode: Asynchronous
;// USART0 Baud Rate: 9600
;UCSR0A=0x00;
	LDI  R30,LOW(0)
	OUT  0xB,R30
;UCSR0B=0xD8;
	LDI  R30,LOW(216)
	OUT  0xA,R30
;UCSR0C=0x06;
	LDI  R30,LOW(6)
	STS  149,R30
;UBRR0H=0x00;
	LDI  R30,LOW(0)
	STS  144,R30
;UBRR0L=0x33;
	LDI  R30,LOW(51)
	OUT  0x9,R30
;}
	RET
;
;inline void USART_1_init(void){// USART1 initialization
_USART_1_init:
;// Communication Parameters: 8 Data, 1 Stop, No Parity
;// USART1 Receiver: On
;// USART1 Transmitter: On
;// USART1 Mode: Asynchronous
;// USART1 Baud Rate: 115200 (Double Speed Mode)
;UCSR1A=0x02;
	LDI  R30,LOW(2)
	STS  155,R30
;UCSR1B=0xD8;
	LDI  R30,LOW(216)
	STS  154,R30
;UCSR1C=0x06;
	LDI  R30,LOW(6)
	STS  157,R30
;UBRR1H=0x00;
	LDI  R30,LOW(0)
	STS  152,R30
;UBRR1L=0x08;
	LDI  R30,LOW(8)
	STS  153,R30
;}
	RET
;
;/*
;void SPI_init(void){// SPI initialization
;// SPI Type: Master
;// SPI Clock Rate: 2000,000 kHz
;// SPI Clock Phase: Cycle Start
;// SPI Clock Polarity: Low
;// SPI Data Order: MSB First
;SPCR=0xD0;
;SPSR=0x00;
;// Clear the SPI interrupt flag
;#asm
;    in   r30,spsr
;    in   r30,spdr
;#endasm
;}*/
;
;inline void TWI_init(void){// TWI initialization
;// Bit Rate: 400,000 kHz
;TWBR=0x02;
;// Two Wire Bus Slave Address: 0x0
;// General Call Recognition: Off
;TWAR=0x00;
;// Generate Acknowledge Pulse: Off
;// TWI Interrupt: On
;TWCR=0x05;
;TWSR=0x00;
;}
;
;void settings_EE_cpy_R(void){ // settings transfer from eeprom to ram
_settings_EE_cpy_R:
;uint8_t i = 0;
;  for(i=0;i<COUNT_OF_UARTS;i++)
	ST   -Y,R17
;	i -> R17
	LDI  R17,0
	LDI  R17,LOW(0)
_0x218:
	CPI  R17,2
	BRSH _0x219
;    {
;        RAM_settings.MODE_of_Uart[i] = EE_settings.MODE_of_Uart[i];
	__POINTW2MN _RAM_settings,4
	CALL SUBOPT_0xA
	ADD  R30,R26
	ADC  R31,R27
	MOVW R0,R30
	CALL SUBOPT_0x36
	CALL SUBOPT_0x37
;        RAM_settings.baud_of_Uart[i] = EE_settings.baud_of_Uart[i];
	MOV  R30,R17
	LDI  R26,LOW(_RAM_settings)
	LDI  R27,HIGH(_RAM_settings)
	LDI  R31,0
	LSL  R30
	ROL  R31
	ADD  R30,R26
	ADC  R31,R27
	MOVW R0,R30
	__POINTW2MN _EE_settings,2
	CALL SUBOPT_0xA
	LSL  R30
	ROL  R31
	ADD  R26,R30
	ADC  R27,R31
	CALL __EEPROMRDW
	MOVW R26,R0
	ST   X+,R30
	ST   X,R31
;    }
	SUBI R17,-1
	RJMP _0x218
_0x219:
;  for(i=0;i<COUNT_OF_SPI;i++)
	LDI  R17,LOW(0)
_0x21B:
	CPI  R17,2
	BRSH _0x21C
;    {
;        RAM_settings.MODE_of_Spi[i] = EE_settings.MODE_of_Spi[i];
	__POINTW2MN _RAM_settings,6
	CALL SUBOPT_0xA
	ADD  R30,R26
	ADC  R31,R27
	MOVW R0,R30
	__POINTW2MN _EE_settings,6
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	CALL SUBOPT_0x37
;        RAM_settings.prescaller_of_Spi[i] =  EE_settings.prescaller_of_Spi[i];
	__POINTW2MN _RAM_settings,10
	CALL SUBOPT_0xA
	ADD  R30,R26
	ADC  R31,R27
	MOVW R0,R30
	__POINTW2MN _EE_settings,10
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	CALL SUBOPT_0x37
;    }
	SUBI R17,-1
	RJMP _0x21B
_0x21C:
;}
	JMP  _0x20C0007
;
;inline void First_EE_init(void){ // settings transfer from eeprom to ram
_First_EE_init:
;uint8_t i = 0;
;  for(i=0;i<COUNT_OF_UARTS;i++)
	ST   -Y,R17
;	i -> R17
	LDI  R17,0
	LDI  R17,LOW(0)
_0x21E:
	CPI  R17,2
	BRSH _0x21F
;    {
;EE_settings.MODE_of_Uart[i] = USART_NORMAL;
	CALL SUBOPT_0x36
	LDI  R30,LOW(0)
	CALL __EEPROMWRB
;    }
	SUBI R17,-1
	RJMP _0x21E
_0x21F:
;    EE_settings.baud_of_Uart[0] = 576; //57600baud
	__POINTW2MN _EE_settings,2
	LDI  R30,LOW(576)
	LDI  R31,HIGH(576)
	CALL __EEPROMWRW
;    EE_settings.baud_of_Uart[1] = 288; //28800baud
	__POINTW2MN _EE_settings,4
	LDI  R30,LOW(288)
	LDI  R31,HIGH(288)
	CALL __EEPROMWRW
;  for(i=0;i<COUNT_OF_SPI;i++)
	LDI  R17,LOW(0)
_0x221:
	CPI  R17,2
	BRSH _0x222
;    {
;EE_settings.MODE_of_Spi[i] = 0;
	__POINTW2MN _EE_settings,6
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	CALL __EEPROMWRB
;EE_settings.prescaller_of_Spi[i] = 16;
	__POINTW2MN _EE_settings,10
	CLR  R30
	ADD  R26,R17
	ADC  R27,R30
	LDI  R30,LOW(16)
	CALL __EEPROMWRB
;    }
	SUBI R17,-1
	RJMP _0x221
_0x222:
;}
	JMP  _0x20C0007
;
;
;void HARDWARE_init(void)
;{
_HARDWARE_init:
; GPIO_init();
	RCALL _GPIO_init
; ADC_init(); //Upd-6
	RCALL _ADC_init
; ADC_calibrate(); //Upd-7
	RCALL _ADC_calibrate
; TIM_0_init();
	RCALL _TIM_0_init
; TIM_1_init();
	RCALL _TIM_1_init
; TIM_2_init();
	RCALL _TIM_2_init
; TIM_3_init();
	RCALL _TIM_3_init
; INT_init();
	RCALL _INT_init
; USART_0_init();
	RCALL _USART_0_init
; USART_1_init();
	RCALL _USART_1_init
; Hard_SPI_Master_Init_default();
	CALL _Hard_SPI_Master_Init_default
;//TWI_init();
; RTC_init(); //Timer 0 used
	RCALL _RTC_init
;
;//i2c_init(); // I2C Bus initialization
;//w1_init(); // 1 Wire Bus initialization
;// 1 Wire Data port: PORTA
;// 1 Wire Data bit: 2
;// Note: 1 Wire port settings must be specified in the
;// Project|Configure|C Compiler|Libraries|1 Wire IDE menu.
;}
	RET
;
;void SOFTWARE_init (void)
;{
_SOFTWARE_init:
;//#ifdef EEPROM_REINIT  //Upd-5
;if(null_ee != 0x42)	// если первое включение - инициализируем переменные ЕЕПРОМ
	LDI  R26,LOW(_null_ee)
	LDI  R27,HIGH(_null_ee)
	CALL __EEPROMRDB
	CPI  R30,LOW(0x42)
	BREQ _0x223
;   {
;    First_EE_init();  //начальная инициализация еепром (выполняется 1 раз)
	RCALL _First_EE_init
;    null_ee = 0x42;
	LDI  R26,LOW(_null_ee)
	LDI  R27,HIGH(_null_ee)
	LDI  R30,LOW(66)
	CALL __EEPROMWRB
;   }
;//#endif
;settings_EE_cpy_R(); //загрузка настроек из еепром
_0x223:
	RCALL _settings_EE_cpy_R
;
;// check_after_pow_on();
;// flags_init();
;
;//WDT_Init();//Watchdog
;
;USART_Init(USART_0, RAM_settings.MODE_of_Uart[USART_0], RAM_settings.baud_of_Uart[USART_0]);
	LDI  R30,LOW(0)
	ST   -Y,R30
	__GETB1MN _RAM_settings,4
	ST   -Y,R30
	LDS  R30,_RAM_settings
	LDS  R31,_RAM_settings+1
	CALL SUBOPT_0x38
;USART_Init(USART_1, RAM_settings.MODE_of_Uart[USART_1], RAM_settings.baud_of_Uart[USART_1]);
	LDI  R30,LOW(1)
	ST   -Y,R30
	__GETB1MN _RAM_settings,5
	ST   -Y,R30
	__GETW1MN _RAM_settings,2
	CALL SUBOPT_0x38
;
;#ifdef DEBUG
;USART_Init(USART_0, 1, 576);
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	LDI  R30,LOW(576)
	LDI  R31,HIGH(576)
	CALL SUBOPT_0x38
;#endif
;
;//Soft_SPI_Master_Init();
;//Hard_SPI_Master_Init_default();
;#warning грузить из еепром!
;SPI_init(SPI_0, SPI_MASTER, 1, 0, 16);
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R30,LOW(1)
	ST   -Y,R30
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	LDI  R30,LOW(16)
	ST   -Y,R30
	CALL _SPI_init
;LcdInit();//Upd-3 //soft spi on portA
	CALL _LcdInit
;
;//cust_I2C_init(I2C_0);
;
;//======
;Init_i2c();						// Запускаем и конфигурируем i2c
	RCALL _Init_i2c
;Init_Slave_i2c(&SlaveControl);	// Настраиваем событие выхода при сработке как Slave
	LDI  R30,LOW(_SlaveControl)
	LDI  R31,HIGH(_SlaveControl)
	ST   -Y,R31
	ST   -Y,R30
	RCALL _Init_Slave_i2c
;//======
;
;// Clear the SPI interrupt flag   //Upd-4
;#asm
    in   r30,spsr
    in   r30,spdr
;
;
;PARSER_Init();
	CALL _PARSER_Init
;
;
;
;#ifdef DEBUG
;LogIndex=0;					// Лог с начала
	LDI  R30,LOW(0)
	STS  _LogIndex_G000,R30
	STS  _LogIndex_G000+1,R30
;WorkLog[LogIndex]=1;		// Записываем метку старта
	CALL SUBOPT_0x1
	LDI  R26,LOW(1)
	CALL SUBOPT_0x2
;LogIndex++;
;#endif
;}
	RET
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;#include "D_Globals/global_variables.h"
;#include "D_Globals/global_defines.h"
;#include "PARSER/pars_hndl.c"           //Upd-8 in folder
;//собственно парсер команд
;
;#include <adapter.h>
;
;//#include "RTOS/HAL.h"
;//#include "RTOS/EERTOS.c"
;#include "RTOS/EERTOSHAL.h"
;
;void PARS_Handler(uint8_t argc, char *argv[])
; 0000 0013 {
;char __flash *response = error;
; // uint8_t value = 0;
; // uint8_t mode = 0;
;  uint8_t i = 0;
;
; uint8_t Interface_Num = 0;
; uint32_t tmp = 0;
; bool Tmp_param_1 = 0;
; bool Tmp_param_2 = 0;
;
;char str [6];
;
;#ifdef DEBUG
;//StopRTOS();
;#endif
;/////////////////////SET_COMAND////////////////////////////////
;/////////////////////////////////////////////////////////////////
;if (!strcmpf(argv[0], Set))
;	argc -> Y+18
;	argv -> Y+16
;	*response -> R16,R17
;	i -> R19
;	Interface_Num -> R18
;	tmp -> Y+12
;	Tmp_param_1 -> R21
;	Tmp_param_2 -> R20
;	str -> Y+6
; {
;#ifdef DEBUG
; Put_In_Log("\r Set");
;#endif
;   if (argc > 1)
;  {
;//////////////////////////////////////////////////////////////////
;/////////////////////UART_SET_START///////////////////////////////
;      if (!strcmpf(argv[1], Uart))
;     {
;#ifdef DEBUG
;   Put_In_Log("\r Uart");
;#endif
;
;       if (argc > 2)
;        {
;          tmp = PARS_StrToUint(argv[2]);//Get number of interface
;          if (tmp <= COUNT_OF_UARTS){Interface_Num = tmp; response = ok;
;#ifdef DEBUG
;  Put_In_Log("\r Num");
;#endif
;          }
;          else{response = largeValue; goto exit;}
;
;         if (argc > 3)    //Mode
;        {
;             if (!strcmpf(argv[3], Mode))
;             {
;               tmp = PARS_StrToUchar(argv[4]); //Get uart mode
;              if (tmp==1 || tmp==0){RAM_settings.MODE_of_Uart[Interface_Num] = tmp; response = ok;
;#ifdef DEBUG
;  Put_In_Log("\r Mode");
;#endif
;               i = 2; //go to next param "speed"
;               }
;              else{response = largeValue;
;#ifdef DEBUG
; //USART_Send_Str(SYSTEM_USART,"\rM EXIT");
; Put_In_Log("\rM EXIT");
;#endif
;            goto exit;}
;             }
;
;             if (!strcmpf(argv[3+i], Speed)) //may be 3 or 5th param
;             {
;              tmp = PARS_StrToUint(argv[4+i]); //get Baud Rate
;              if (tmp <= MAX_BAUD_RATE)
;              {
;              RAM_settings.baud_of_Uart[Interface_Num] = tmp;
;              response = ok; i = 0;
;#ifdef DEBUG
;  Put_In_Log("\r ");
;  Put_In_LogFl(Speed);
;#endif
;              }
;              else{response = largeValue;
;#ifdef DEBUG
; Put_In_Log("\rM EXIT");
;#endif
;             goto exit;}
;        }
;
;     USART_Init(Interface_Num, RAM_settings.MODE_of_Uart[Interface_Num], RAM_settings.baud_of_Uart[Interface_Num]);
;     Interface_Num = 0;
;
;     StopRTOS();
;     EE_settings.MODE_of_Uart[Interface_Num] = RAM_settings.MODE_of_Uart[Interface_Num];  //save to eeprom
;     EE_settings.baud_of_Uart[Interface_Num] = RAM_settings.baud_of_Uart[Interface_Num];
;     RunRTOS();
;#ifdef DEBUG          //не переносятся настройки!!!
; Put_In_Log("\r Uart_init");
; //print_settings_ram();
;#endif
;      }
;     }
;#ifdef DEBUG
;       USART_FlushTxBuf(USART_0);
;#endif
;    }
;/////////////////////UART_SET_END////////////////////////////////
;/////////////////////////////////////////////////////////////////
;
;//////////////////////////////////////////////////////////////////
;/////////////////////SPI_SET_START////////////////////////////////
;     if (!strcmpf(argv[1], Spi))
;     {
;#ifdef DEBUG
;    Put_In_Log("\r Spi");
;#endif
;       if (argc > 2)
;        {
;#ifdef DEBUG
;  Put_In_Log("\rS Num");
;#endif
;          tmp = PARS_StrToUchar(argv[2]);//Get number of interface
;          if (tmp <= COUNT_OF_SPI){Interface_Num = tmp; response = ok;}
;          else{response = largeValue; goto exit;}
;
;      if (argc > 3)    //Mode
;      {
;         if (!strcmpf(argv[3], Mode))
;         {
;            tmp = PARS_StrToUchar(argv[4]); //Get spi mode
;            if (tmp==1 || tmp==0){RAM_settings.MODE_of_Spi[Interface_Num] = tmp;
;            i = 2; //go to next param "speed"
;            response = ok;
; #ifdef DEBUG
;Put_In_Log("\rS Mode-");
;#endif
;            }
;            else{response = largeValue; goto exit;}
;        }
;
;          if (!strcmpf(argv[3+i], Prescaller)) //Prescaller, may be 3 or 5th param
;         {
;            tmp = PARS_StrToUchar(argv[4+i]); //get SPI prescaller Rate
;            if (tmp <= MAX_SPI_PRESCALLER){RAM_settings.prescaller_of_Spi[Interface_Num] = tmp;
;            i += 2;
;            response = ok;
;#ifdef DEBUG
;Put_In_Log("\rS Presc-");
;#endif
;            }
;            else{response = largeValue; goto exit;}
;        }
;
;          if (!strcmpf(argv[3+i], PhaPol)) //may be 3 or 5 or 7th  param
;         {
;            tmp = PARS_StrToUchar(argv[4+i]);//get phase/polarity mode (0-3)
;           if (tmp>=0 && tmp <= 3)
;           {
;            switch(tmp){  //phase/polarity select
;             case 0:
;              Tmp_param_1 = 0; Tmp_param_2 = 0;
;             break;
;             case 1:
;              Tmp_param_1 = 0; Tmp_param_2 = 1;
;             break;
;             case 2:
;              Tmp_param_1 = 1; Tmp_param_2 = 0;
;             break;
;             case 3:
;              Tmp_param_1 = 1; Tmp_param_2 = 1;
;             break;
;             default:
;              Tmp_param_1 = 0; Tmp_param_2 = 0;
;             break;
;            } response = ok;
;#ifdef DEBUG
; Put_In_Log("\rS PhaPol-");
;#endif
;            RAM_settings.PhaPol_of_Spi[Interface_Num] = tmp; //Upd - 1
;           }
;           else{response = wrongValue; goto exit;}
;         }
;     SPI_init(Interface_Num, RAM_settings.MODE_of_Spi[Interface_Num], Tmp_param_2 ,Tmp_param_1, RAM_settings.prescaller_of_Spi[Interface_Num]);
;     i = 0; Tmp_param_1=0; Tmp_param_2=0;
;
;      EE_settings.MODE_of_Spi[Interface_Num] = RAM_settings.MODE_of_Spi[Interface_Num];
;      EE_settings.PhaPol_of_Spi[Interface_Num] = RAM_settings.PhaPol_of_Spi[Interface_Num];//Upd - 1
;     // Tmp_param_2 ,Tmp_param_1,
;      EE_settings.prescaller_of_Spi[Interface_Num] = RAM_settings.prescaller_of_Spi[Interface_Num];
;
;
;#ifdef DEBUG
; Put_In_Log("\rS SpiInit");
;#endif
;      }
;     }
;    }
;/////////////////////SPI_SET_END//////////////////////////////////
;//////////////////////////////////////////////////////////////////
;
;//////////////////////////////////////////////////////////////////
;/////////////////////I2C_SET_START///////////////////////////////
;      if (!strcmpf(argv[1], I2c))
;     {
;#ifdef DEBUG
;   Put_In_Log("\r I2c");
;#endif
;
;       if (argc > 2)
;        {
;          tmp = PARS_StrToUint(argv[2]);//Get number of interface
;          if (tmp <= COUNT_OF_UARTS){Interface_Num = tmp; response = ok;
;#ifdef DEBUG
;  Put_In_Log("\r Num");
;#endif
;          }
;          else{response = largeValue; goto exit;}
;
;         if (argc > 3)    //Mode
;        {
;             if (!strcmpf(argv[3], Mode))
;             {
;               tmp = PARS_StrToUchar(argv[4]); //Get uart mode
;              if (tmp==1 || tmp==0){RAM_settings.MODE_of_Uart[Interface_Num] = tmp; response = ok;
;#ifdef DEBUG
;  Put_In_Log("\r Mode");
;#endif
;               i = 2; //go to next param "speed"
;               }
;              else{response = largeValue;
;#ifdef DEBUG
; //USART_Send_Str(SYSTEM_USART,"\rM EXIT");
; Put_In_Log("\rM EXIT");
;#endif
;            goto exit;}
;             }
;
;             if (!strcmpf(argv[3+i], Speed)) //may be 3 or 5th param
;             {
;              tmp = PARS_StrToUint(argv[4+i]); //get Baud Rate
;              if (tmp <= MAX_BAUD_RATE)
;              {
;              RAM_settings.baud_of_Uart[Interface_Num] = tmp;
;              response = ok; i = 0;
;#ifdef DEBUG
;  Put_In_Log("\r ");
;  Put_In_LogFl(Speed);
;#endif
;              }
;              else{response = largeValue;
;#ifdef DEBUG
; Put_In_Log("\rM EXIT");
;#endif
;             goto exit;}
;        }
;
;     USART_Init(Interface_Num, RAM_settings.MODE_of_Uart[Interface_Num], RAM_settings.baud_of_Uart[Interface_Num]);
;     Interface_Num = 0; //?
;
;     EE_settings.MODE_of_Uart[Interface_Num] = RAM_settings.MODE_of_Uart[Interface_Num];  //save to eeprom
;     EE_settings.baud_of_Uart[Interface_Num] = RAM_settings.baud_of_Uart[Interface_Num];
;#ifdef DEBUG          //не переносятся настройки!!!
; Put_In_Log("\r I2c_init");
; //print_settings_ram();
;#endif
;      }
;     }
;#ifdef DEBUG
;       USART_FlushTxBuf(USART_0);
;#endif
;    }
;/////////////////////I2C_SET_END////////////////////////////////
;/////////////////////////////////////////////////////////////////
;  }
; }
;
;/////////////////////WRITE_COMAND////////////////////////////////
;/////////////////////////////////////////////////////////////////
;if (!strcmpf(argv[0], W)) //Write
; {
; #ifdef DEBUG
; Put_In_Log("\r W");
;#endif
;  if (argc > 1)
;  {
;///////////////////////////////////////////////////////////////////
;/////////////////////UART_WRITE_START//////////////////////////////
;      if (!strcmpf(argv[1], Uart))
;     {
;       if (argc > 2)
;        {
;          tmp = PARS_StrToUchar(argv[2]);//Get number of interface to write
;          if (tmp <= COUNT_OF_UARTS){Interface_Num = tmp; response = ok;}
;          else{response = largeValue;}
;      if (argc > 3)    //Data
;      {
;      StopRTOS; //так как передача по UART-у может быть медленной,RTOS на время замедляется (Ибо внешний интерфейс приоритетнее)
;        USART_Send_Str(Interface_Num, argv[3]); //TODO проверить реальную задержку
;      RunRTOS;
;      #ifdef DEBUG
;Put_In_Log("\r U D>TX ");
;  itoa(PARS_StrToUint(argv[3]),str);
;Put_In_Log(str); //convert dec to str
;     #endif
;      }
;     }
;    }
;/////////////////////UART_WRITE_END////////////////////////////////
;///////////////////////////////////////////////////////////////////
;
;///////////////////////////////////////////////////////////////////
;/////////////////////SPI_WRITE-READ_START//////////////////////////
;    if (!strcmpf(argv[1], Spi))
;     {
; #ifdef DEBUG
; //USART_Send_Str(SYSTEM_USART,"\r SPI ");
; #endif
;       if (argc > 2)
;        {
;          tmp = PARS_StrToUchar(argv[2]);//Get number of interface to write
;          if (tmp <= COUNT_OF_SPI){Interface_Num = tmp; response = ok;
; #ifdef DEBUG
; //USART_Send_Str(SYSTEM_USART,"\r SPI num w ");
; #endif
;          }
;          else{response = largeValue;}
;
;      if (argc > 3)    //Data
;      {
;#ifdef DEBUG
;
;Put_In_Log("\r S D>TX ");
; itoa(PARS_StrToUint(argv[3]),str);  //возможно вывести не > 65535
;Put_In_Log(str); //convert dec to str
; #endif
;
; SPI_RW_Buf(10/*array_size(argv[3])*/, argv[3], Spi0_RX_buf); //TODO определять кол-во автоматически
;
; #ifdef DEBUG
;Put_In_Log("\r S D<RX ");
;Put_In_Log(Spi0_RX_buf);
;
;#warning ставим не задачу, а только флаг того, что надо установить задачу очитски буффера
;         //флаг проверяется в фоновой задаче и в соответствии происходит запуск или удаление задач
;FLAG_SET(g_tcf,S_SPI_BUF_CLR);//  = SetTask(Task_SPI_ClrBuf);
;//SetTimerTask(Task_SPI_ClrBuf, 10);
; // USART_Send_Str(SYSTEM_USART, Spi0_RX_buf);
;  #endif
;      }
;     }
;    }
;/////////////////////SPI_WRITE-READ_END////////////////////////////
;///////////////////////////////////////////////////////////////////
;
;///////////////////////////////////////////////////////////////////
;/////////////////////I2C_WRITE_START//////////////////////////////
;    if (!strcmpf(argv[1], I2c))
;     {
; #ifdef DEBUG
; //USART_Send_Str(SYSTEM_USART,"\r I2c ");
; #endif
;       if (argc > 2)
;        {
;          tmp = PARS_StrToUchar(argv[2]);//Get number of interface to write
;          if (tmp <= COUNT_OF_I2C){Interface_Num = tmp; response = ok;
; #ifdef DEBUG
; //USART_Send_Str(SYSTEM_USART,"\r I2C num w ");
; #endif
;          }
;          else{response = largeValue;}
;
;      if (argc > 3)    //Data
;      {
;#ifdef DEBUG
;
;Put_In_Log("\r I2C D>TX ");
; itoa(PARS_StrToUint(argv[3]),str);  //возможно вывести не > 65535
; USART_Send_Str(SYSTEM_USART,str); //convert dec to str
; #endif
;
; //I2C_RW_Buf(10/*array_size(argv[3])*/, argv[3], Spi0_RX_buf); //TODO определять кол-во автоматически
; //I2C_write(argv[3]);
;
;
; #ifdef DEBUG
;Put_In_Log("\r I2C D<RX ");
;  USART_Send_Str(SYSTEM_USART, Spi0_RX_buf);
;  #endif
;      }
;     }
;    }
;/////////////////////I2C_WRITE_END/////////////////////////////////
;///////////////////////////////////////////////////////////////////
;
;///////////////////////////////////////////////////////////////////
;/////////////////////READ_COMAND_START//////////////////////////////
;
;
;
;/////////////////////READ_COMAND_END//////////////////////////////
;///////////////////////////////////////////////////////////////////
;   }
; }
;
; /*
; Проверить  приём с uart1,
; дописать настройки spi (в 1 переменную!!).
; дописать сохранение в еепром,
;
; сделать и2с,
; добавить опцию автопередачи с/на выбраный интерфейс.
; */
;
;if (!strcmpf(argv[0], "y")){  SetTask(Task_BuffOut);  U1_in_buf_flag = 1; response = ok;}
;if (!strcmpf(argv[0], "n")){  ClearTimerTask(Task_BuffOut);  U1_in_buf_flag = 0; response = ok;}
;if (!strcmpf(argv[0], "a")){  SetTask(Task_AdcOnLcd);  response = ok;}
;
;    if (!strcmpf(argv[0], Help)){ print_help(); response = ok; }
;    if (!strcmpf(argv[0], boot)){response = ok;#asm("call 0x1E00");}//Boot_reset "Goto bootloader"
;    if (!strcmpf(argv[0], reset)){response = ok;#asm("jmp 0x0000");} //reset
;    // dbg не успевает вывестись из-за прерывания ртос(вунужден временно останавливать, а с help всё ок.)
;    if (!strcmpf(argv[0], dbg)){StopRTOS(); print_settings_eeprom(); print_settings_ram(); print_sys(); response = ok; RunRTOS();}//stop=15kbt
;    if (!strcmpf(argv[0], "s")){ print_sys(); response = ok;}
;    if (!strcmpf(argv[0], "E")){SetTask(EEP_StartWrite); response = ok;}  // Запускаем процесс записи в ЕЕПРОМ.
;
; //EE_settings = RAM_settings; //rewrite settings to EEPROM
;
;exit:
;  //USART_FlushTxBuf(SYSTEM_USART);
;  USART_Send_StrFl(SYSTEM_USART,response);
;#ifdef DEBUG
; // RunRTOS();
;#endif
;}

	.DSEG
_0x225:
	.BYTE 0xDA
;
;
;// G_vars are here
;volatile uint16_t tmp = 0;
;
;inline void ProcessMessages(void);//Обработчик флагов и сообщений задач
;
;//TODO переписать парсер команд в конечный автомат как в http://habrahabr.ru/post/241941/
; //Предусмотреть убийство задачи, если войдёт в бесконечный цикл! (2-й таймер)
;  //Добавить вытесняемость!
; //Отладить прерывание SPI!
; //Добавить сортировку задач по периоду выполнения (наиболее частые - ближе к началу очереди!)
;
;//===================================================================================
;//===================================================================================
;//START MAIN
;
;
;
;void main(void)
; 0000 0027 {

	.CSEG
_main:
; 0000 0028 #ifdef DEBUG   //синхронизация с протеусом
; 0000 0029     DDRD.LED2=1;LED_PORT |= (1<<LED2);  //Led VD2
	SBI  0x11,7
	SBI  0x12,7
; 0000 002A     delay_ms(15);
	LDI  R30,LOW(15)
	LDI  R31,HIGH(15)
	CALL SUBOPT_0x8
; 0000 002B     DDRD.LED2=0;LED_PORT  &= ~(1<<LED2); //Led VD2
	CBI  0x11,7
	CBI  0x12,7
; 0000 002C #endif
; 0000 002D 
; 0000 002E HARDWARE_init();
	RCALL _HARDWARE_init
; 0000 002F SOFTWARE_init();
	RCALL _SOFTWARE_init
; 0000 0030 DeadTimerInit();
	CALL _DeadTimerInit
; 0000 0031 InitRTOS();
	RCALL _InitRTOS
; 0000 0032 
; 0000 0033 #ifdef DEBUG
; 0000 0034     DDRD.LED2=1;//PORTD.7=1;  //Led VD2
	SBI  0x11,7
; 0000 0035     DDRD.LED1=1;//PORTD.6=1;    //Led VD1
	SBI  0x11,6
; 0000 0036     DDRD.LED3=1;//PORTD.6=1;    //Led LED3
	SBI  0x11,5
; 0000 0037     USART_Send_StrFl(USART_1,start);
	LDI  R30,LOW(1)
	CALL SUBOPT_0x39
; 0000 0038     USART_Send_StrFl(SYSTEM_USART,start);
	LDI  R30,LOW(0)
	CALL SUBOPT_0x39
; 0000 0039 #endif
; 0000 003A 
; 0000 003B //RunRTOS();			// Старт ядра.
; 0000 003C 
; 0000 003D // Запуск фоновых задач.
; 0000 003E SetTask(Task_Initial);
	LDI  R30,LOW(_Task_Initial)
	LDI  R31,HIGH(_Task_Initial)
	CALL SUBOPT_0x31
; 0000 003F 
; 0000 0040 RunRTOS();			// Старт ядра.
	CALL _RunRTOS
; 0000 0041 
; 0000 0042 while (1)
_0x280:
; 0000 0043  {
; 0000 0044 //wdt_reset();	// Сброс собачьего таймера
; 0000 0045 TaskManager();	// Вызов диспетчера
	RCALL _TaskManager
; 0000 0046 ProcessMessages();//Обработка различных флагов и сообщений от задач
	RCALL _ProcessMessages
; 0000 0047  }
	RJMP _0x280
; 0000 0048 } //END MAIN
_0x283:
	RJMP _0x283
;//===================================================================================
;//===================================================================================
;
;
;
;
;
;
;inline void ProcessMessages(void)
; 0000 0052 {
_ProcessMessages:
; 0000 0053 Task_FlagsHandler();
	RCALL _Task_FlagsHandler
; 0000 0054 }
	RET
;
;
;
;// Timer2 interrupt service routine
;interrupt [RTOS_ISR] void timer2_comp_isr(void)//RTOS Interrupt 1mS
; 0000 005A {
_timer2_comp_isr:
	CALL SUBOPT_0x1B
; 0000 005B //static uint16_t tmp_tick;
; 0000 005C 
; 0000 005D  v_u32_SYS_TICK++;
	LDI  R26,LOW(_v_u32_SYS_TICK)
	LDI  R27,HIGH(_v_u32_SYS_TICK)
	CALL SUBOPT_0x13
; 0000 005E // if(v_u32_SYS_TICK%10 == 0)
; 0000 005F // {
; 0000 0060   TimerService();
	RCALL _TimerService
; 0000 0061 // }
; 0000 0062 
; 0000 0063   CorpseService(); //очистка от зависших задач
	CALL _CorpseService
; 0000 0064 
; 0000 0065 }
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	LD   R25,Y+
	LD   R24,Y+
	LD   R23,Y+
	LD   R22,Y+
	LD   R15,Y+
	LD   R1,Y+
	LD   R0,Y+
	RETI
;
;
;
;
;interrupt [DEAD_TIME_ISR] void timer0_comp_isr(void)//DEAD_TIME_ISR Interrupt
; 0000 006B {
_timer0_comp_isr:
	ST   -Y,R26
	ST   -Y,R30
	IN   R30,SREG
	ST   -Y,R30
; 0000 006C   LED_PORT.LED3^=1;
	LDI  R26,0
	SBIC 0x12,5
	LDI  R26,1
	LDI  R30,LOW(1)
	EOR  R30,R26
	BRNE _0x284
	CBI  0x12,5
	RJMP _0x285
_0x284:
	SBI  0x12,5
_0x285:
; 0000 006D }
	LD   R30,Y+
	OUT  SREG,R30
	LD   R30,Y+
	LD   R26,Y+
	RETI
;
;
;
;
;
;
;
;// Timer1 overflow interrupt service routine
;interrupt [TIM1_OVF] void timer1_ovf_isr(void)
; 0000 0077 {
_timer1_ovf_isr:
	CALL SUBOPT_0x16
; 0000 0078 v_u16_TIM_1_OVR_FLAG++;
	LDI  R26,LOW(_v_u16_TIM_1_OVR_FLAG)
	LDI  R27,HIGH(_v_u16_TIM_1_OVR_FLAG)
	CALL SUBOPT_0x15
; 0000 0079 }
	CALL SUBOPT_0x17
	RETI
;
;
;//sprintf(lcd_buf, "Z=%d", v_u32_SYS_TICK); ;LcdString(1,3); LcdUpdate();
;#include "RTOS/EERTOS.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x20
	.EQU __sm_mask=0x1C
	.EQU __sm_powerdown=0x10
	.EQU __sm_powersave=0x18
	.EQU __sm_standby=0x14
	.EQU __sm_ext_standby=0x1C
	.EQU __sm_adc_noise_red=0x08
	.SET power_ctrl_reg=mcucr
	#endif
;#include "RTOS/EERTOSHAL.h"
;
;
;//#undef DEBUG
;/*
;-Насколько хорошо это будет работать, если таймер установить на 50-100мкс при 16МГц?
;
;DI HALT: 9 Апрель 2012 в 21:08
;Плохо будет работать. Там довольно многое можно оптимизировать,
;среднее выполнение блока таймерной службы сейчас около 600 тактов.
;Ну или около того. Столько же в среднем занимает перебор очереди,
;установка таймера порядка 700 тактов, установка задачи около 400 тактов.
;//=150uS - время на предподготовку задачи (примерное из предыдущ. днн^)
;Реально тайминг снизить до 500мкс ,но делать очень короткие задачи, иначе таймер лажать будет.
;*/
;
;
;/*
;  UPDATE - Избавился от очереди задач TaskQueue, вместо этого в диспетчере задач
;  выполняются задачи из очереди TTask, которые уже "выщелкали",
;  соответственно количество кода очень уменьшилось.
;  MEMORY -58 WORDS
;*/
;
;  //постановка задачи в очередь - 290мкс
;  // SetTimerTask + TaskManager для 30 задач = 312мкс (по замерам в протеусе)
;
;// Очереди задач, таймеров.
;// Тип данных - указатель на функцию
;//volatile static TPTR	TaskQueue[TaskQueueSize+1];			// очередь указателей
;//update
;
;enum TASK_STATUS {WAIT, RDY, IN_PROC, DONE, DEAD};
;
;enum SetTimerTask_Status {QUEUE_FULL, TASK_REWRITTEN, TASK_ADDED, DEAD_TASK};
;
;#warning оптимизировать передачей указателя или ссылки на структуру
;typedef  struct
;{
;                        TPTR GoToTask; 					// Указатель перехода
;                        uint16_t TaskDelay;				// Выдержка в мс перед старотом задачи
;                        uint16_t TaskPeriod;			// Выдержка в мс перед следующим запуском
;                        uint8_t TaskStatus;
;						//TODO добавить параметр и отладить
; #ifdef DEBUG
;  uint32_t sys_tick_time;  // Значение системного таймера на момент запуска задачи в тиках
;  uint8_t exec_time;       // Реально замеряное время выполнения задачи
;  uint8_t  flag;           // Различные флаги (переполнение таймера, ошибка,..)
; #endif
;}TASK_STRUCT;// Структура программного таймера-задачи
;
; volatile static TASK_STRUCT  TTask[MainTimerQueueSize+1];	// Очередь таймеров
; volatile static uint8_t timers_cnt_tail = 1;

	.DSEG
; volatile static uint16_t DeadTaskTimeout = 1000;
; volatile bit InfiniteLoopFlag = 1; //Если задача зависнет - то в прерывании об этом узнают и прибьют по таймауту!
;
;//+++++++++++++PRIVATE RTOS SERVICES++++++++++++++++++++++++++++++
;  void clear_duplicates (void); //not tested
;  inline void dbg_out (char index);
;  void SheikerSort(uint8_t *a, int n);
;//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;
;
; //===================================================================
;
;  void  Idle(void)  //Пустая процедура - простой ядра.
; 0001 0044 {

	.CSEG
_Idle:
; 0001 0045 #ifdef DEBUG
; 0001 0046 LED_PORT  &=~(1<<LED1);   //Для отслеживания загрузки системы
	CBI  0x12,6
; 0001 0047 #endif
; 0001 0048 if(v_u32_SYS_TICK % QUEUE_SORTING_PERIOD == 0){KERNEL_Sort_TaskQueue();}; //Периодическое упорядочевание задач по длительости переиода
	CALL SUBOPT_0x3A
	CALL SUBOPT_0x22
	BRNE _0x20005
	RCALL _KERNEL_Sort_TaskQueue
_0x20005:
; 0001 0049 }
	RET
;
;  void InitRTOS(void) // RTOS Подготовка. Очистка очередей
; 0001 004C {
_InitRTOS:
; 0001 004D uint8_t	index;
; 0001 004E RTOS_timer_init(); //Hardware!
	ST   -Y,R17
;	index -> R17
	CALL _RTOS_timer_init
; 0001 004F       for(index=0;index!=MainTimerQueueSize+1;index++) // Обнуляем все таймеры.
	LDI  R17,LOW(0)
_0x20007:
	CPI  R17,21
	BREQ _0x20008
; 0001 0050     {
; 0001 0051 	    TTask[index].GoToTask = Idle;
	CALL SUBOPT_0x3B
	CALL SUBOPT_0x3C
; 0001 0052 	    TTask[index].TaskDelay = 0; //Считаю, что достаточно занулить указатель
	CALL SUBOPT_0x3D
	CALL SUBOPT_0x3E
; 0001 0053 	 }
	SUBI R17,-1
	RJMP _0x20007
_0x20008:
; 0001 0054 }
	RJMP _0x20C0007
;
; void SetTask(TPTR TS)  // Поставить задачу в очередь для немедленного выполнения
; 0001 0057 {
_SetTask:
; 0001 0058  SetTimerTask(TS,0,0);
;	*TS -> Y+0
	LD   R30,Y
	LDD  R31,Y+1
	CALL SUBOPT_0x33
	CALL SUBOPT_0x33
	CALL SUBOPT_0x30
; 0001 0059 }
_0x20C0008:
	ADIW R28,2
	RET
;
;
;//Функция установки задачи по таймеру. Передаваемые параметры - указатель на функцию,
;// Время выдержки в тиках системного таймера. Возвращет код ошибки.
;
;uint8_t SetTimerTask(TPTR TS, unsigned int NewTime, unsigned int NewPeriod)    //1 task ~12words
; 0001 0060 {
_SetTimerTask:
	PUSH R15
; 0001 0061 bit		nointerrupted = 0;
; 0001 0062 uint8_t		index=0;
; 0001 0063 uint8_t		result = QUEUE_FULL;
; 0001 0064 
; 0001 0065 if (STATUS_REG & (1<<Interrupt_Flag)){_disable_interrupts();nointerrupted = 1;}	// Проверка запрета прерывания
	ST   -Y,R17
	ST   -Y,R16
;	*TS -> Y+6
;	NewTime -> Y+4
;	NewPeriod -> Y+2
;	nointerrupted -> R15.0
;	index -> R17
;	result -> R16
	CLR  R15
	LDI  R17,0
	LDI  R16,0
	IN   R30,0x3F
	SBRS R30,7
	RJMP _0x20009
	cli
	SET
	BLD  R15,0
; 0001 0066 
; 0001 0067   for(index=0;index!=timers_cnt_tail;++index)
_0x20009:
	LDI  R17,LOW(0)
_0x2000B:
	LDS  R30,_timers_cnt_tail
	CP   R30,R17
	BRNE PC+3
	JMP _0x2000C
; 0001 0068   {
; 0001 0069 	  if(TTask[index].TaskStatus != DEAD)
	CALL SUBOPT_0x3F
	LD   R26,Z
	CPI  R26,LOW(0x4)
	BREQ _0x2000D
; 0001 006A 	  {
; 0001 006B 			if (TTask[index].GoToTask == TS)			// ищем заданый таймер
	CALL SUBOPT_0x3B
	MOVW R26,R30
	CALL __GETW1P
	MOVW R26,R30
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x2000E
; 0001 006C 		{
; 0001 006D 			TTask[index].TaskDelay = NewTime;		    // И поле выдержки времени
	CALL SUBOPT_0x3D
	CALL SUBOPT_0x40
; 0001 006E 			TTask[index].TaskPeriod = NewPeriod;	    // И поле периода запуска
; 0001 006F 			TTask[index].TaskStatus = WAIT;             // Флаг - ожидает выполнения!
	LDI  R26,LOW(0)
	STD  Z+0,R26
; 0001 0070 			if (nointerrupted) {_enable_interrupts();}	// Разрешаем прерывания
	SBRS R15,0
	RJMP _0x2000F
	sei
; 0001 0071 			result = TASK_REWRITTEN; goto exit;			// Выход.
_0x2000F:
	LDI  R16,LOW(1)
	RJMP _0x20010
; 0001 0072 		}												// Если не находим - значит он новый
; 0001 0073 		if (TTask[index].GoToTask == Idle)				// ищем любой пустой таймер
_0x2000E:
	CALL SUBOPT_0x3B
	MOVW R26,R30
	CALL __GETW1P
	MOVW R26,R30
	LDI  R30,LOW(_Idle)
	LDI  R31,HIGH(_Idle)
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x20011
; 0001 0074 		{
; 0001 0075 			TTask[index].GoToTask = TS;			        // Заполняем поле перехода задачи
	CALL SUBOPT_0x3B
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	STD  Z+0,R26
	STD  Z+1,R27
; 0001 0076 			TTask[index].TaskDelay = NewTime;		    // И поле выдержки времени
	CALL SUBOPT_0x3D
	CALL SUBOPT_0x40
; 0001 0077 			TTask[index].TaskPeriod = NewPeriod;	    // И поле периода запуска
; 0001 0078 			TTask[index].TaskStatus = WAIT;             // Флаг - ожидает выполнения!
	LDI  R26,LOW(0)
	STD  Z+0,R26
; 0001 0079 			timers_cnt_tail++;                          // Увеличиваем кол-во (новых) таймеров
	LDS  R30,_timers_cnt_tail
	SUBI R30,-LOW(1)
	STS  _timers_cnt_tail,R30
; 0001 007A 			if (nointerrupted) {_enable_interrupts();}	// Разрешаем прерывания
	SBRS R15,0
	RJMP _0x20012
	sei
; 0001 007B 			result = TASK_ADDED; goto exit;			    // Выход.
_0x20012:
	LDI  R16,LOW(2)
	RJMP _0x20010
; 0001 007C 		}
; 0001 007D 	  }
_0x20011:
; 0001 007E 	  else{result = DEAD_TASK; goto exit;	}
	RJMP _0x20013
_0x2000D:
	LDI  R16,LOW(3)
	RJMP _0x20010
_0x20013:
; 0001 007F   }
	SUBI R17,-LOW(1)
	RJMP _0x2000B
_0x2000C:
; 0001 0080 exit:
_0x20010:
; 0001 0081   return result; // return c кодом ошибки - нет свободных таймеров, таймер перезаписан или добавлен как новый
	MOV  R30,R16
	LDD  R17,Y+1
	LDD  R16,Y+0
	ADIW R28,8
	POP  R15
	RET
; 0001 0082 }
;
;/*
;Служба таймеров ядра. Должна вызываться из прерывания раз в 1мс. Хотя время можно варьировать в зависимости от задачи
;
;To DO: Привести к возможности загружать произвольную очередь таймеров. Тогда можно будет создавать их целую прорву.
;А также использовать эту функцию произвольным образом.
;В этом случае не забыть добавить проверку прерывания.
;*/
;inline void TimerService(void)
; 0001 008C {
_TimerService:
; 0001 008D uint8_t index;
; 0001 008E 
; 0001 008F for(index=0;index!=timers_cnt_tail;index++)		// Прочесываем очередь таймеров
	ST   -Y,R17
;	index -> R17
	LDI  R17,LOW(0)
_0x20015:
	LDS  R30,_timers_cnt_tail
	CP   R30,R17
	BREQ _0x20016
; 0001 0090 	{
; 0001 0091          if((TTask[index].TaskStatus == WAIT) || (TTask[index].TaskStatus == DONE))// Если не выполнилась и
	CALL SUBOPT_0x3F
	LD   R26,Z
	CPI  R26,LOW(0x0)
	BREQ _0x20018
	CPI  R26,LOW(0x3)
	BRNE _0x20017
_0x20018:
; 0001 0092            {
; 0001 0093              if(TTask[index].TaskDelay > 0)  // таймер не выщелкал, то
	CALL SUBOPT_0x3D
	MOVW R26,R30
	CALL __GETW1P
	MOVW R26,R30
	CALL __CPW02
	BRSH _0x2001A
; 0001 0094               {
; 0001 0095                 TTask[index].TaskDelay--;	// щелкаем еще раз.
	CALL SUBOPT_0x3D
	MOVW R26,R30
	LD   R30,X+
	LD   R31,X+
	SBIW R30,1
	ST   -X,R31
	ST   -X,R30
; 0001 0096               }
; 0001 0097               else                         //Ставим флаг готовности к выполнению
	RJMP _0x2001B
_0x2001A:
; 0001 0098               {
; 0001 0099                TTask[index].TaskStatus = RDY;
	CALL SUBOPT_0x3F
	LDI  R26,LOW(1)
	STD  Z+0,R26
; 0001 009A               }
_0x2001B:
; 0001 009B 		};
_0x20017:
; 0001 009C 	}
	SUBI R17,-1
	RJMP _0x20015
_0x20016:
; 0001 009D }
_0x20C0007:
	LD   R17,Y+
	RET
;
;
;//=================================================================================
;//Диспетчер задач ОС. Выбирает из очереди задачи и отправляет на выполнение
;//===================================================================================
;
;inline void TaskManager(void)
; 0001 00A5 {
_TaskManager:
	PUSH R15
; 0001 00A6 uint8_t		index=0;
; 0001 00A7 char tmp_str[10];
; 0001 00A8 bit task_exist = 1;// существует ли задача всё ещё
; 0001 00A9 TPTR CurrentTask;                 //TODO сделать глобальными регистровыми!
; 0001 00AA 
; 0001 00AB //DEAD_TASK_DETECTED:
; 0001 00AC 
; 0001 00AD   for(index=0;index!=timers_cnt_tail;++index)   // Прочесываем очередь задач
	SBIW R28,10
	CALL __SAVELOCR4
;	index -> R17
;	tmp_str -> Y+4
;	task_exist -> R15.0
;	*CurrentTask -> R18,R19
	LDI  R30,LOW(1)
	MOV  R15,R30
	LDI  R17,0
	LDI  R17,LOW(0)
_0x2001D:
	LDS  R30,_timers_cnt_tail
	CP   R30,R17
	BRNE PC+3
	JMP _0x2001E
; 0001 00AE 	{
; 0001 00AF       if ((TTask[index].TaskStatus == RDY)) // пропускаем пустые задачи и те, время которых еще не подошло
	CALL SUBOPT_0x3F
	LD   R26,Z
	CPI  R26,LOW(0x1)
	BREQ PC+3
	JMP _0x2001F
; 0001 00B0 		{
; 0001 00B1           LED_PORT |= (1<<LED1);   //Для отслеживания загрузки системы
	SBI  0x12,6
; 0001 00B2           CurrentTask=TTask[index].GoToTask;  // запомним задачу т.к. во время выполнения может измениться индекс
	CALL SUBOPT_0x3B
	LD   R18,Z
	LDD  R19,Z+1
; 0001 00B3 
; 0001 00B4 
; 0001 00B5           if(TTask[index].TaskPeriod == 0) //если период 0 - удаляем задачу из списка
	CALL SUBOPT_0x41
	MOVW R26,R30
	CALL __GETW1P
	SBIW R30,0
	BRNE _0x20020
; 0001 00B6            {
; 0001 00B7                 ClearTimerTask(CurrentTask);  task_exist = 0;// задачи больше не существует
	ST   -Y,R19
	ST   -Y,R18
	RCALL _ClearTimerTask
	CLT
	BLD  R15,0
; 0001 00B8            }
; 0001 00B9            else
	RJMP _0x20021
_0x20020:
; 0001 00BA            {
; 0001 00BB                 TTask[index].TaskDelay = TTask[index].TaskPeriod; //перезапись задержки
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	MOVW R26,R30
	__ADDW1MN _TTask_G001,2
	MOVW R22,R30
	__ADDW2MN _TTask_G001,4
	CALL __GETW1P
	MOVW R26,R22
	ST   X+,R30
	ST   X,R31
; 0001 00BC                 TTask[index].TaskStatus = IN_PROC;  //Задача в процессе выполнения
	CALL SUBOPT_0x3F
	LDI  R26,LOW(2)
	STD  Z+0,R26
; 0001 00BD #ifdef DEBUG                                            //запись св-ств задачи для лога
; 0001 00BE                 TTask[index].sys_tick_time = v_u32_SYS_TICK; //время начала выполнения
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,7
	CALL SUBOPT_0x3A
	CALL __PUTDZ20
; 0001 00BF #endif
; 0001 00C0            }
_0x20021:
; 0001 00C1              //Дальше идём на выполнение задачи
; 0001 00C2  //----------------------------------------------------------------------------------------------------
; 0001 00C3             v_u8_SYS_TICK_TMP1 = (uint8_t)v_u32_SYS_TICK; //засекаем время выполнения задачи
	LDS  R30,_v_u32_SYS_TICK
	STS  _v_u8_SYS_TICK_TMP1,R30
; 0001 00C4             _enable_interrupts();						// Разрешаем прерывания
	sei
; 0001 00C5             (CurrentTask)();					        // ПЕРЕХОД К ЗАДАЧЕ!
	MOVW R30,R18
	ICALL
; 0001 00C6 
; 0001 00C7 InfiniteLoopFlag = 0; //Если задача зависнет - то в прерывании об этом узнают и прибьют по таймауту!
	CLT
	BLD  R2,0
; 0001 00C8  //----------------------------------------------------------------------------------------------------
; 0001 00C9 
; 0001 00CA             if(task_exist)//если задача ранее не удалилась
	SBRS R15,0
	RJMP _0x20022
; 0001 00CB 			{
; 0001 00CC 			    TTask[index].TaskStatus = DONE;         //меняем статус - задача не повисла, а благополучно выполнилась!
	CALL SUBOPT_0x3F
	LDI  R26,LOW(3)
	STD  Z+0,R26
; 0001 00CD 				v_u8_SYS_TICK_TMP1 = (uint8_t)v_u32_SYS_TICK - v_u8_SYS_TICK_TMP1;
	LDS  R26,_v_u8_SYS_TICK_TMP1
	LDS  R30,_v_u32_SYS_TICK
	SUB  R30,R26
	STS  _v_u8_SYS_TICK_TMP1,R30
; 0001 00CE                 TTask[index].exec_time = v_u8_SYS_TICK_TMP1;//то запишем время её выполнения
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,11
	LDS  R26,_v_u8_SYS_TICK_TMP1
	STD  Z+0,R26
; 0001 00CF #ifdef DEBUG
; 0001 00D0 				 if(v_u8_SYS_TICK_TMP1 >= 1)
	LDS  R26,_v_u8_SYS_TICK_TMP1
	CPI  R26,LOW(0x1)
	BRLO _0x20023
; 0001 00D1 				 {
; 0001 00D2 					itoa(v_u8_SYS_TICK_TMP1,tmp_str);
	LDS  R30,_v_u8_SYS_TICK_TMP1
	LDI  R31,0
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,6
	CALL SUBOPT_0x35
; 0001 00D3 					Put_In_Log(tmp_str);Put_In_Log("%\r");
	MOVW R30,R28
	ADIW R30,4
	CALL SUBOPT_0x42
	__POINTW1MN _0x20024,0
	CALL SUBOPT_0x42
; 0001 00D4 				 }
; 0001 00D5 #endif
; 0001 00D6              }
_0x20023:
; 0001 00D7 
; 0001 00D8             //всё стопорится на єтой строке если не return!!!
; 0001 00D9             return;                                     // выход до следующего цикла
_0x20022:
	RJMP _0x20C0006
; 0001 00DA 		}
; 0001 00DB 	}
_0x2001F:
	SUBI R17,-LOW(1)
	RJMP _0x2001D
_0x2001E:
; 0001 00DC     _enable_interrupts();							// Разрешаем прерывания
	sei
; 0001 00DD 	Idle();                                     // обошли задачи, нужных нет - простой
	RCALL _Idle
; 0001 00DE }
_0x20C0006:
	CALL __LOADLOCR4
	ADIW R28,14
	POP  R15
	RET

	.DSEG
_0x20024:
	.BYTE 0x3
;
;
;void ClearTimerTask(TPTR TS)  //обнуление таймера
; 0001 00E2 {

	.CSEG
_ClearTimerTask:
	PUSH R15
; 0001 00E3 uint8_t	 index=0;
; 0001 00E4 bit nointerrupted = 0;
; 0001 00E5 if (STATUS_REG & (1<<Interrupt_Flag)){_disable_interrupts(); nointerrupted = 1;}
	ST   -Y,R17
;	*TS -> Y+1
;	index -> R17
;	nointerrupted -> R15.0
	CLR  R15
	LDI  R17,0
	IN   R30,0x3F
	SBRS R30,7
	RJMP _0x20025
	cli
	SET
	BLD  R15,0
; 0001 00E6 
; 0001 00E7     for(index=0; index<timers_cnt_tail; ++index)
_0x20025:
	LDI  R17,LOW(0)
_0x20027:
	LDS  R30,_timers_cnt_tail
	CP   R17,R30
	BRLO PC+3
	JMP _0x20028
; 0001 00E8     {
; 0001 00E9       if(TTask[index].GoToTask == TS)
	CALL SUBOPT_0x3B
	MOVW R26,R30
	CALL __GETW1P
	MOVW R26,R30
	LDD  R30,Y+1
	LDD  R31,Y+1+1
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x20029
; 0001 00EA       {
; 0001 00EB            if(index != (timers_cnt_tail - 1))         // переносим последнюю задачу
	LDS  R30,_timers_cnt_tail
	SUBI R30,LOW(1)
	CP   R30,R17
	BREQ _0x2002A
; 0001 00EC          {                                            // на место удаляемой
; 0001 00ED             TTask[index] = TTask[timers_cnt_tail - 1];
	CALL SUBOPT_0x3B
	MOVW R22,R30
	CALL SUBOPT_0x43
	CALL SUBOPT_0x44
; 0001 00EE                          //зануление последней задачи
; 0001 00EF             TTask[timers_cnt_tail - 1].GoToTask = Idle;
	CALL SUBOPT_0x43
	CALL SUBOPT_0x3C
; 0001 00F0             TTask[timers_cnt_tail - 1].TaskDelay = 0; // Обнуляем время
	CALL SUBOPT_0x45
	__ADDW1MN _TTask_G001,2
	CALL SUBOPT_0x3E
; 0001 00F1             TTask[timers_cnt_tail - 1].TaskPeriod = 0; // Обнуляем время
	CALL SUBOPT_0x45
	__ADDW1MN _TTask_G001,4
	CALL SUBOPT_0x3E
; 0001 00F2             TTask[timers_cnt_tail - 1].TaskStatus = DONE; // Обнуляем status
	CALL SUBOPT_0x45
	RJMP _0x20057
; 0001 00F3          }
; 0001 00F4            else
_0x2002A:
; 0001 00F5          {
; 0001 00F6              //Если задача последняя в очереди
; 0001 00F7             TTask[index].GoToTask = Idle;
	CALL SUBOPT_0x3B
	CALL SUBOPT_0x3C
; 0001 00F8             TTask[index].TaskDelay = 0; // Обнуляем время
	CALL SUBOPT_0x3D
	CALL SUBOPT_0x3E
; 0001 00F9             TTask[index].TaskPeriod = 0; // Обнуляем время
	CALL SUBOPT_0x41
	CALL SUBOPT_0x3E
; 0001 00FA             TTask[index].TaskStatus = DONE; // Обнуляем status
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
_0x20057:
	__ADDW1MN _TTask_G001,6
	LDI  R26,LOW(3)
	STD  Z+0,R26
; 0001 00FB          }
; 0001 00FC 
; 0001 00FD         --timers_cnt_tail;  //уменьшаем кол-во задач
	LDS  R30,_timers_cnt_tail
	SUBI R30,LOW(1)
	STS  _timers_cnt_tail,R30
; 0001 00FE         if (nointerrupted){ _enable_interrupts();}
	SBRS R15,0
	RJMP _0x2002C
	sei
; 0001 00FF         return;
_0x2002C:
	RJMP _0x20C0005
; 0001 0100       }
; 0001 0101     }
_0x20029:
	SUBI R17,-LOW(1)
	RJMP _0x20027
_0x20028:
; 0001 0102 }
_0x20C0005:
	LDD  R17,Y+0
	ADIW R28,3
	POP  R15
	RET
;
;
;  void KERNEL_Sort_TaskQueue (void) //сортировкa задач по периоду выполнения (наиболее частые - ближе к началу очереди!)
; 0001 0106  {
_KERNEL_Sort_TaskQueue:
	PUSH R15
; 0001 0107   bit		nointerrupted = 0;
; 0001 0108   int8_t l, r, k, index;
; 0001 0109   TASK_STRUCT tmp;
; 0001 010A  if (STATUS_REG & (1<<Interrupt_Flag)){_disable_interrupts();nointerrupted = 1;}	// Проверка запрета прерывания
	SBIW R28,13
	CALL __SAVELOCR4
;	nointerrupted -> R15.0
;	l -> R17
;	r -> R16
;	k -> R19
;	index -> R18
;	tmp -> Y+4
	CLR  R15
	IN   R30,0x3F
	SBRS R30,7
	RJMP _0x2002D
	cli
	SET
	BLD  R15,0
; 0001 010B 
; 0001 010C   //+++++++++++++
; 0001 010D            k = l = 0;
_0x2002D:
	LDI  R30,LOW(0)
	MOV  R17,R30
	MOV  R19,R30
; 0001 010E            r = timers_cnt_tail - 2; //In original = 2!
	LDS  R30,_timers_cnt_tail
	SUBI R30,LOW(2)
	MOV  R16,R30
; 0001 010F            while(l <= r)
_0x2002E:
	CP   R16,R17
	BRLT _0x20030
; 0001 0110            {
; 0001 0111               for(index = l; index <= r; index++)
	MOV  R18,R17
_0x20032:
	CP   R16,R18
	BRLT _0x20033
; 0001 0112               {
; 0001 0113                  if (TTask[index].TaskPeriod > TTask[index+1].TaskPeriod)
	CALL SUBOPT_0x46
	BRSH _0x20034
; 0001 0114                  {
; 0001 0115                  tmp = TTask[index];
	CALL SUBOPT_0x47
	CALL SUBOPT_0x48
; 0001 0116                  TTask[index] = TTask[index+1];
	CALL SUBOPT_0x49
; 0001 0117                  TTask[index+1] = tmp;
	CALL SUBOPT_0x4A
; 0001 0118                     k = index;
; 0001 0119                  }
; 0001 011A               }
_0x20034:
	SUBI R18,-1
	RJMP _0x20032
_0x20033:
; 0001 011B               r = k - 1;
	MOV  R30,R19
	SUBI R30,LOW(1)
	MOV  R16,R30
; 0001 011C 
; 0001 011D               for(index = r; index >= l; index--)
	MOV  R18,R16
_0x20036:
	CP   R18,R17
	BRLT _0x20037
; 0001 011E                {
; 0001 011F                  if (TTask[index].TaskPeriod > TTask[index+1].TaskPeriod)
	CALL SUBOPT_0x46
	BRSH _0x20038
; 0001 0120                  {
; 0001 0121                  tmp = TTask[index];
	CALL SUBOPT_0x47
	CALL SUBOPT_0x48
; 0001 0122                  TTask[index] = TTask[index+1];
	CALL SUBOPT_0x49
; 0001 0123                  TTask[index+1] = tmp;
	CALL SUBOPT_0x4A
; 0001 0124                     k = index;
; 0001 0125                  }
; 0001 0126                }
_0x20038:
	SUBI R18,1
	RJMP _0x20036
_0x20037:
; 0001 0127               l = k + 1;
	MOV  R30,R19
	SUBI R30,-LOW(1)
	MOV  R17,R30
; 0001 0128            }
	RJMP _0x2002E
_0x20030:
; 0001 0129  //-------------
; 0001 012A   if (nointerrupted){_enable_interrupts();}	// Разрешаем прерывания
	SBRS R15,0
	RJMP _0x20039
	sei
; 0001 012B  }
_0x20039:
	CALL __LOADLOCR4
	ADIW R28,17
	POP  R15
	RET
;
;
; inline void CorpseService(void)
; 0001 012F {
_CorpseService:
	PUSH R15
; 0001 0130  uint8_t		index = 0;
; 0001 0131   static uint8_t coins = 0; //совпадения
; 0001 0132   static bit suspect_flag = 0;
; 0001 0133   //static  TASK_STRUCT DeadTask;
; 0001 0134   static TPTR DeadTask_prev, DeadTask_curr;
; 0001 0135   bit		nointerrupted = 0;
; 0001 0136   static uint16_t Timeout_delay = 0;
; 0001 0137 
; 0001 0138   if(InfiniteLoopFlag == 0) //диспетчер сбросил флаг, значит задача завершилась
	ST   -Y,R17
;	index -> R17
;	nointerrupted -> R15.0
	CLR  R15
	LDI  R17,0
	SBRC R2,0
	RJMP _0x2003A
; 0001 0139   {
; 0001 013A 	InfiniteLoopFlag = 1; //Установка до след. интерации и выход
	SET
	BLD  R2,0
; 0001 013B 	suspect_flag = 0;
	CLT
	BLD  R2,3
; 0001 013C   }
; 0001 013D   else  //флаг не сброшен - выполняется какая-то задача! возможно уже долго
	RJMP _0x2003B
_0x2003A:
; 0001 013E   {
; 0001 013F 	if (STATUS_REG & (1<<Interrupt_Flag)){_disable_interrupts();nointerrupted = 1;}	// Проверка запрета прерывания
	IN   R30,0x3F
	SBRS R30,7
	RJMP _0x2003C
	cli
	SET
	BLD  R15,0
; 0001 0140 
; 0001 0141 	for(index=0; index<timers_cnt_tail; ++index)	//поиск мертвеца (пока ещё просто возможного!)
_0x2003C:
	LDI  R17,LOW(0)
_0x2003E:
	LDS  R30,_timers_cnt_tail
	CP   R17,R30
	BRLO PC+3
	JMP _0x2003F
; 0001 0142 			 {
; 0001 0143 				if(TTask[index].TaskStatus == IN_PROC)
	CALL SUBOPT_0x3F
	LD   R26,Z
	CPI  R26,LOW(0x2)
	BREQ PC+3
	JMP _0x20040
; 0001 0144 				{
; 0001 0145 					if(suspect_flag == 0)//при первом заходе
	SBRC R2,3
	RJMP _0x20041
; 0001 0146 					{
; 0001 0147 						DeadTask_prev = TTask[index].GoToTask;
	CALL SUBOPT_0x3B
	MOVW R26,R30
	CALL __GETW1P
	CALL SUBOPT_0x4B
; 0001 0148 						suspect_flag = 1; //начинаем подозревать
	SET
	BLD  R2,3
; 0001 0149 						Timeout_delay = (uint16_t)v_u32_SYS_TICK; //засекли таймаут
	LDS  R30,_v_u32_SYS_TICK
	LDS  R31,_v_u32_SYS_TICK+1
	STS  _Timeout_delay_S0010008000,R30
	STS  _Timeout_delay_S0010008000+1,R31
; 0001 014A 						return;
	RJMP _0x20C0004
; 0001 014B 					}
; 0001 014C 					else //при втором заходе
_0x20041:
; 0001 014D 					{
; 0001 014E 						DeadTask_curr = TTask[index].GoToTask;
	CALL SUBOPT_0x3B
	MOVW R26,R30
	CALL __GETW1P
	CALL SUBOPT_0x4C
; 0001 014F 						if(DeadTask_curr == DeadTask_prev)	//подозревания подтвердились
	LDS  R30,_DeadTask_prev_S0010008000
	LDS  R31,_DeadTask_prev_S0010008000+1
	LDS  R26,_DeadTask_curr_S0010008000
	LDS  R27,_DeadTask_curr_S0010008000+1
	CP   R30,R26
	CPC  R31,R27
	BRNE _0x20043
; 0001 0150 							{
; 0001 0151 							    coins++;
	LDS  R30,_coins_S0010008000
	SUBI R30,-LOW(1)
	STS  _coins_S0010008000,R30
; 0001 0152 								if((v_u32_SYS_TICK - Timeout_delay >= DEAD_TIMEOUT)&&(coins>=4))
	LDS  R30,_Timeout_delay_S0010008000
	LDS  R31,_Timeout_delay_S0010008000+1
	CALL SUBOPT_0x3A
	CLR  R22
	CLR  R23
	CALL __SUBD21
	__CPD2N 0x7
	BRLO _0x20045
	LDS  R26,_coins_S0010008000
	CPI  R26,LOW(0x4)
	BRSH _0x20046
_0x20045:
	RJMP _0x20044
_0x20046:
; 0001 0153 								{
; 0001 0154                                    //TTask[index].TaskStatus = DEAD;
; 0001 0155 								  ClearTimerTask(DeadTask_curr);	//выпилить из очереди!
	LDS  R30,_DeadTask_curr_S0010008000
	LDS  R31,_DeadTask_curr_S0010008000+1
	ST   -Y,R31
	ST   -Y,R30
	RCALL _ClearTimerTask
; 0001 0156 							      suspect_flag = 0;Timeout_delay = 0;
	CALL SUBOPT_0x4D
; 0001 0157 							      DeadTask_curr = DeadTask_prev = 0; coins = 0;
; 0001 0158                                   //TODO Теперь надо передать управление системе
; 0001 0159                                   //TaskManager();
; 0001 015A                                   //#asm("JMP 0x0000");
; 0001 015B                                  // #asm("call TaskManager");
; 0001 015C 								  //goto DEAD_TASK_DETECTED;
; 0001 015D 								}
; 0001 015E 							}
_0x20044:
; 0001 015F 							else
	RJMP _0x20047
_0x20043:
; 0001 0160 							{
; 0001 0161 								suspect_flag = 0;Timeout_delay = 0;
	CALL SUBOPT_0x4D
; 0001 0162 							    DeadTask_curr = DeadTask_prev = 0; coins = 0;
; 0001 0163 							}
_0x20047:
; 0001 0164 
; 0001 0165 					}
; 0001 0166 				}
; 0001 0167 			 }
_0x20040:
	SUBI R17,-LOW(1)
	RJMP _0x2003E
_0x2003F:
; 0001 0168   }
_0x2003B:
; 0001 0169  if (nointerrupted){_enable_interrupts();}	// Разрешаем прерывания
	SBRS R15,0
	RJMP _0x20048
	sei
; 0001 016A }
_0x20048:
_0x20C0004:
	LD   R17,Y+
	POP  R15
	RET
;
;
; inline uint8_t DeadTask_Shutter(void)
; 0001 016E  {   uint8_t		index=0;
; 0001 016F 
; 0001 0170 
; 0001 0171  return index; //возврат индекса зависщей задачи
;	index -> R17
; 0001 0172  }
;
;  //TODO look at http://we.easyelectronics.ru/Soft/minimalistichnaya-ochered-zadach-na-c.html
; //TODO look at http://we.easyelectronics.ru/Soft/dispetcher-snova-dispetcher.html
;
; void clear_duplicates (void) //not tested
; 0001 0178  {
; 0001 0179   uint8_t		index=0;
; 0001 017A   bit		nointerrupted = 0;
; 0001 017B   TPTR task_src;
; 0001 017C if (STATUS_REG & (1<<Interrupt_Flag)){_disable_interrupts();nointerrupted = 1;}	// Проверка запрета прерывания
;	index -> R17
;	nointerrupted -> R15.0
;	*task_src -> R18,R19
; 0001 017D   for(index=0;index!=timers_cnt_tail;++index)
; 0001 017E   {
; 0001 017F      task_src = TTask[index].GoToTask;
; 0001 0180     for(index+1;index!=timers_cnt_tail;++index)
; 0001 0181       {
; 0001 0182        if (TTask[index].GoToTask == task_src) {TTask[index].GoToTask = Idle;}
; 0001 0183       }
; 0001 0184   }
; 0001 0185   if (nointerrupted){_enable_interrupts();}	// Разрешаем прерывания
; 0001 0186  }
;
;
;void Task_t_props_out (void)
; 0001 018A {
_Task_t_props_out:
; 0001 018B uint8_t index = 0;
; 0001 018C char tmp_str[10];
; 0001 018D 
; 0001 018E  FullStopRTOS();
	SBIW R28,10
	ST   -Y,R17
;	index -> R17
;	tmp_str -> Y+1
	LDI  R17,0
	RCALL _FullStopRTOS
; 0001 018F     // LED_PORT  &=~(1<<LED2);
; 0001 0190   for(index=0;index!=timers_cnt_tail;++index)	// ищем таймер
	LDI  R17,LOW(0)
_0x20053:
	LDS  R30,_timers_cnt_tail
	CP   R30,R17
	BRNE PC+3
	JMP _0x20054
; 0001 0191 	{
; 0001 0192      Put_In_Log("\r\n<");
	__POINTW1MN _0x20055,0
	CALL SUBOPT_0x42
; 0001 0193      itoa((int)TTask[index].GoToTask , tmp_str);
	CALL SUBOPT_0x3B
	CALL SUBOPT_0x4E
; 0001 0194      Put_In_Log(tmp_str); Put_In_Log(",");
	CALL SUBOPT_0x4F
	__POINTW1MN _0x20055,4
	CALL SUBOPT_0x42
; 0001 0195      itoa((int)TTask[index].TaskDelay , tmp_str);
	CALL SUBOPT_0x3D
	CALL SUBOPT_0x4E
; 0001 0196      Put_In_Log(tmp_str); Put_In_Log(",");
	CALL SUBOPT_0x4F
	__POINTW1MN _0x20055,6
	CALL SUBOPT_0x42
; 0001 0197      itoa((int)TTask[index].TaskPeriod , tmp_str);
	CALL SUBOPT_0x41
	CALL SUBOPT_0x4E
; 0001 0198      Put_In_Log(tmp_str); Put_In_Log(",");
	CALL SUBOPT_0x4F
	__POINTW1MN _0x20055,8
	CALL SUBOPT_0x42
; 0001 0199      itoa((int)TTask[index].sys_tick_time , tmp_str);
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,7
	CALL SUBOPT_0x4E
; 0001 019A      Put_In_Log(tmp_str); Put_In_Log(",");
	CALL SUBOPT_0x4F
	__POINTW1MN _0x20055,10
	CALL SUBOPT_0x42
; 0001 019B      itoa((int)TTask[index].exec_time , tmp_str);
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,11
	CALL SUBOPT_0xC
	MOVW R30,R28
	ADIW R30,3
	CALL SUBOPT_0x35
; 0001 019C      Put_In_Log(tmp_str);Put_In_Log(",");
	CALL SUBOPT_0x4F
	__POINTW1MN _0x20055,12
	CALL SUBOPT_0x42
; 0001 019D      itoa((int)TTask[index].TaskStatus , tmp_str);
	CALL SUBOPT_0x3F
	CALL SUBOPT_0xC
	MOVW R30,R28
	ADIW R30,3
	CALL SUBOPT_0x35
; 0001 019E      Put_In_Log(tmp_str);
	CALL SUBOPT_0x4F
; 0001 019F      Put_In_Log(">");
	__POINTW1MN _0x20055,14
	CALL SUBOPT_0x42
; 0001 01A0   }
	SUBI R17,-LOW(1)
	RJMP _0x20053
_0x20054:
; 0001 01A1  // LED_PORT  |=(1<<LED2);
; 0001 01A2  Put_In_Log("\r\n");
	__POINTW1MN _0x20055,16
	CALL SUBOPT_0x42
; 0001 01A3  #asm("sei");
	sei
; 0001 01A4  Task_LogOut();
	CALL _Task_LogOut
; 0001 01A5  //RunRTOS();
; 0001 01A6 }
	LDD  R17,Y+0
	ADIW R28,11
	RET

	.DSEG
_0x20055:
	.BYTE 0x13
;
;inline void dbg_out (char index)
; 0001 01A9 {

	.CSEG
; 0001 01AA char tmp_str[10];
; 0001 01AB  Put_In_Log("\r\n<");
;	index -> Y+10
;	tmp_str -> Y+0
; 0001 01AC      itoa((int)TTask[index].GoToTask , tmp_str);
; 0001 01AD      Put_In_Log(tmp_str); Put_In_Log(",");
; 0001 01AE      itoa((int)TTask[index].TaskDelay , tmp_str);
; 0001 01AF      Put_In_Log(tmp_str); Put_In_Log(",");
; 0001 01B0      itoa((int)TTask[index].TaskPeriod , tmp_str);
; 0001 01B1      Put_In_Log(tmp_str); Put_In_Log(",");
; 0001 01B2      itoa((int)TTask[index].sys_tick_time , tmp_str);
; 0001 01B3      Put_In_Log(tmp_str); Put_In_Log(",");
; 0001 01B4      itoa((int)TTask[index].exec_time , tmp_str);
; 0001 01B5      Put_In_Log(tmp_str);Put_In_Log(",");
; 0001 01B6      itoa((int)TTask[index].TaskStatus , tmp_str);
; 0001 01B7      Put_In_Log(tmp_str);
; 0001 01B8      Put_In_Log(">\r\n");
; 0001 01B9 }

	.DSEG
_0x20056:
	.BYTE 0x12
;
;/*
;TPTR GoToTask; 					// Указатель перехода
;uint16_t TaskDelay;				// Выдержка в мс перед старотом задачи
;uint16_t TaskPeriod;			// Выдержка в мс перед следующим запуском
;uint8_t TaskStatus;
;  uint32_t sys_tick_time; // Значение системного таймера на момент выполнения задачи в тиках
;  uint8_t exec_time;       // Реально замеряное время выполнения задачи
;  uint8_t hndl;
;*/
;
;//TPTR> Delay> Period> tick> exec Status>
;
;/*2400
;<3720,8,10,2404,0,0>
;<4295,0,0,0,0,3>
;<3759,0,33,0,0,1>
;<3674,107,500,2013,46,0>
;<3835,48,50,2404,1,0>
;<3882,33,333,2106,0,0>
;<3666,0,10,2363,0,1>
;<3673,0,250,2148,1,1>
;<3663,97,0,0,0,0>
;<3727,0,3,2363,41,1>
;+ */
;
;/*2700
;<4295,0,0,0,0,3>
;<3674,298,500,2533,44,0>
;<3727,0,3,2698,37,1>
;<3720,0,10,2578,0,1>
;<3666,0,10,2580,0,1>
;<3759,0,33,0,0,1>
;<3835,0,50,2578,1,1>
;<3673,0,250,2406,0,1>
;<3882,47,333,2449,0,0>
;+*/
;/*
;<4295,0,0,0,0,3>
;<3674,294,500,2534,45,0>
;<3727,0,3,2703,37,1>
;<3720,0,10,2624,0,1>
;<3666,0,10,2624,0,1>
;<3759,0,33,0,0,1>
;<3835,0,50,2580,1,1>
;<3673,0,250,2406,0,1>
;<3882,42,333,2449,0,0>
;+*/
;#include "RTOS/EERTOSHAL.h"
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x20
	.EQU __sm_mask=0x1C
	.EQU __sm_powerdown=0x10
	.EQU __sm_powersave=0x18
	.EQU __sm_standby=0x14
	.EQU __sm_ext_standby=0x1C
	.EQU __sm_adc_noise_red=0x08
	.SET power_ctrl_reg=mcucr
	#endif
;
;//RTOS Запуск системного таймера
;void RTOS_timer_init (void)
; 0002 0005 {

	.CSEG
_RTOS_timer_init:
; 0002 0006 TCNT2 = 0;                                // Установить начальное значение счётчиков
	LDI  R30,LOW(0)
	OUT  0x24,R30
; 0002 0007 OCR2  = LO(RtosTimerDivider);         		// Установить значение в регистр сравнения
	LDI  R30,LOW(62)
	OUT  0x23,R30
; 0002 0008 TIMSK = (0<<TOIE2)|(1<<OCIE2);
	LDI  R30,LOW(128)
	RJMP _0x20C0003
; 0002 0009 }
;
;  void RunRTOS (void)
; 0002 000C {
_RunRTOS:
; 0002 000D #asm("cli");      //Upd-11
	cli
; 0002 000E TCCR2 = (1<<WGM21)|(1<<CS22)|(0<<CS20)|(0<<CS21); // Freq = CK/256 - Установить режим и предделитель
	LDI  R30,LOW(12)
	OUT  0x25,R30
; 0002 000F 										         // Автосброс после достижения регистра сравнения
; 0002 0010 #asm("sei");                             // Разрешаем прерывание RTOS - запуск ОС
	sei
; 0002 0011 }
	RET
;
;  #warning поэкспериментировать с переменным RtosTimerDivider в StopRTOS и в зависимости от задач(возможно их приоритета)
;//RTOS увеличение предделителя системного таймера
;  void StopRTOS (void)//Фактически снижение частоты системного таймера
; 0002 0016 {
; 0002 0017 #asm("cli");
; 0002 0018 TCCR2 = (0<<CS21)|(1<<CS22)|(1<<CS20); // Freq = CK/1024
; 0002 0019 #asm("sei");
; 0002 001A }
;
;
;//RTOS Остановка системного таймера
;  void FullStopRTOS (void)
; 0002 001F {
_FullStopRTOS:
; 0002 0020 #asm("cli");
	cli
; 0002 0021 TCCR2 = 0;                        // Сбросить режим и предделитель
	LDI  R30,LOW(0)
	OUT  0x25,R30
; 0002 0022 TIMSK = (0<<TOIE2)|(0<<OCIE2);	 // запрещаем прерывание RTOS - остановка ОС
	OUT  0x37,R30
; 0002 0023 #asm("sei");
	sei
; 0002 0024 }
	RET
;
;
;void DeadTimerInit (void)
; 0002 0028 {
_DeadTimerInit:
; 0002 0029 TCCR0 = (1<<WGM01)|(1<<CS02)|(0<<CS00)|(0<<CS01);
	LDI  R30,LOW(12)
	OUT  0x33,R30
; 0002 002A TCNT0=0x00;
	LDI  R30,LOW(0)
	OUT  0x32,R30
; 0002 002B OCR0=LO(DeadTimerDivider);
	LDI  R30,LOW(62)
	OUT  0x31,R30
; 0002 002C TIMSK = (0<<TOIE0)|(1<<OCIE0);
	LDI  R30,LOW(2)
_0x20C0003:
	OUT  0x37,R30
; 0002 002D }
	RET

	.CSEG
	#ifndef __SLEEP_DEFINED__
	#define __SLEEP_DEFINED__
	.EQU __se_bit=0x20
	.EQU __sm_mask=0x1C
	.EQU __sm_powerdown=0x10
	.EQU __sm_powersave=0x18
	.EQU __sm_standby=0x14
	.EQU __sm_ext_standby=0x1C
	.EQU __sm_adc_noise_red=0x08
	.SET power_ctrl_reg=mcucr
	#endif

	.CSEG
_put_buff_G101:
	ST   -Y,R17
	ST   -Y,R16
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,2
	CALL __GETW1P
	SBIW R30,0
	BREQ _0x2020010
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,4
	CALL __GETW1P
	MOVW R16,R30
	SBIW R30,0
	BREQ _0x2020012
	__CPWRN 16,17,2
	BRLO _0x2020013
	MOVW R30,R16
	SBIW R30,1
	MOVW R16,R30
	__PUTW1SNS 2,4
_0x2020012:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	ADIW R26,2
	CALL SUBOPT_0x15
	SBIW R30,1
	LDD  R26,Y+4
	STD  Z+0,R26
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	CALL __GETW1P
	TST  R31
	BRMI _0x2020014
	CALL SUBOPT_0x15
_0x2020014:
_0x2020013:
	RJMP _0x2020015
_0x2020010:
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	ST   X+,R30
	ST   X,R31
_0x2020015:
	LDD  R17,Y+1
	LDD  R16,Y+0
_0x20C0002:
	ADIW R28,5
	RET
__print_G101:
	SBIW R28,6
	CALL __SAVELOCR6
	LDI  R17,0
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	ST   X+,R30
	ST   X,R31
_0x2020016:
	LDD  R30,Y+18
	LDD  R31,Y+18+1
	ADIW R30,1
	STD  Y+18,R30
	STD  Y+18+1,R31
	SBIW R30,1
	LPM  R30,Z
	MOV  R18,R30
	CPI  R30,0
	BRNE PC+3
	JMP _0x2020018
	MOV  R30,R17
	CPI  R30,0
	BRNE _0x202001C
	CPI  R18,37
	BRNE _0x202001D
	LDI  R17,LOW(1)
	RJMP _0x202001E
_0x202001D:
	CALL SUBOPT_0x50
_0x202001E:
	RJMP _0x202001B
_0x202001C:
	CPI  R30,LOW(0x1)
	BRNE _0x202001F
	CPI  R18,37
	BRNE _0x2020020
	CALL SUBOPT_0x50
	RJMP _0x20200C9
_0x2020020:
	LDI  R17,LOW(2)
	LDI  R20,LOW(0)
	LDI  R16,LOW(0)
	CPI  R18,45
	BRNE _0x2020021
	LDI  R16,LOW(1)
	RJMP _0x202001B
_0x2020021:
	CPI  R18,43
	BRNE _0x2020022
	LDI  R20,LOW(43)
	RJMP _0x202001B
_0x2020022:
	CPI  R18,32
	BRNE _0x2020023
	LDI  R20,LOW(32)
	RJMP _0x202001B
_0x2020023:
	RJMP _0x2020024
_0x202001F:
	CPI  R30,LOW(0x2)
	BRNE _0x2020025
_0x2020024:
	LDI  R21,LOW(0)
	LDI  R17,LOW(3)
	CPI  R18,48
	BRNE _0x2020026
	ORI  R16,LOW(128)
	RJMP _0x202001B
_0x2020026:
	RJMP _0x2020027
_0x2020025:
	CPI  R30,LOW(0x3)
	BREQ PC+3
	JMP _0x202001B
_0x2020027:
	CPI  R18,48
	BRLO _0x202002A
	CPI  R18,58
	BRLO _0x202002B
_0x202002A:
	RJMP _0x2020029
_0x202002B:
	LDI  R26,LOW(10)
	MUL  R21,R26
	MOV  R21,R0
	MOV  R30,R18
	SUBI R30,LOW(48)
	ADD  R21,R30
	RJMP _0x202001B
_0x2020029:
	MOV  R30,R18
	CPI  R30,LOW(0x63)
	BRNE _0x202002F
	CALL SUBOPT_0x51
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	LDD  R26,Z+4
	ST   -Y,R26
	CALL SUBOPT_0x52
	RJMP _0x2020030
_0x202002F:
	CPI  R30,LOW(0x73)
	BRNE _0x2020032
	CALL SUBOPT_0x51
	CALL SUBOPT_0x53
	CALL _strlen
	MOV  R17,R30
	RJMP _0x2020033
_0x2020032:
	CPI  R30,LOW(0x70)
	BRNE _0x2020035
	CALL SUBOPT_0x51
	CALL SUBOPT_0x53
	CALL _strlenf
	MOV  R17,R30
	ORI  R16,LOW(8)
_0x2020033:
	ORI  R16,LOW(2)
	ANDI R16,LOW(127)
	LDI  R19,LOW(0)
	RJMP _0x2020036
_0x2020035:
	CPI  R30,LOW(0x64)
	BREQ _0x2020039
	CPI  R30,LOW(0x69)
	BRNE _0x202003A
_0x2020039:
	ORI  R16,LOW(4)
	RJMP _0x202003B
_0x202003A:
	CPI  R30,LOW(0x75)
	BRNE _0x202003C
_0x202003B:
	LDI  R30,LOW(_tbl10_G101*2)
	LDI  R31,HIGH(_tbl10_G101*2)
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDI  R17,LOW(5)
	RJMP _0x202003D
_0x202003C:
	CPI  R30,LOW(0x58)
	BRNE _0x202003F
	ORI  R16,LOW(8)
	RJMP _0x2020040
_0x202003F:
	CPI  R30,LOW(0x78)
	BREQ PC+3
	JMP _0x2020071
_0x2020040:
	LDI  R30,LOW(_tbl16_G101*2)
	LDI  R31,HIGH(_tbl16_G101*2)
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDI  R17,LOW(4)
_0x202003D:
	SBRS R16,2
	RJMP _0x2020042
	CALL SUBOPT_0x51
	CALL SUBOPT_0x54
	LDD  R26,Y+11
	TST  R26
	BRPL _0x2020043
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	CALL __ANEGW1
	STD  Y+10,R30
	STD  Y+10+1,R31
	LDI  R20,LOW(45)
_0x2020043:
	CPI  R20,0
	BREQ _0x2020044
	SUBI R17,-LOW(1)
	RJMP _0x2020045
_0x2020044:
	ANDI R16,LOW(251)
_0x2020045:
	RJMP _0x2020046
_0x2020042:
	CALL SUBOPT_0x51
	CALL SUBOPT_0x54
_0x2020046:
_0x2020036:
	SBRC R16,0
	RJMP _0x2020047
_0x2020048:
	CP   R17,R21
	BRSH _0x202004A
	SBRS R16,7
	RJMP _0x202004B
	SBRS R16,2
	RJMP _0x202004C
	ANDI R16,LOW(251)
	MOV  R18,R20
	SUBI R17,LOW(1)
	RJMP _0x202004D
_0x202004C:
	LDI  R18,LOW(48)
_0x202004D:
	RJMP _0x202004E
_0x202004B:
	LDI  R18,LOW(32)
_0x202004E:
	CALL SUBOPT_0x50
	SUBI R21,LOW(1)
	RJMP _0x2020048
_0x202004A:
_0x2020047:
	MOV  R19,R17
	SBRS R16,1
	RJMP _0x202004F
_0x2020050:
	CPI  R19,0
	BREQ _0x2020052
	SBRS R16,3
	RJMP _0x2020053
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	LPM  R18,Z+
	STD  Y+6,R30
	STD  Y+6+1,R31
	RJMP _0x2020054
_0x2020053:
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LD   R18,X+
	STD  Y+6,R26
	STD  Y+6+1,R27
_0x2020054:
	CALL SUBOPT_0x50
	CPI  R21,0
	BREQ _0x2020055
	SUBI R21,LOW(1)
_0x2020055:
	SUBI R19,LOW(1)
	RJMP _0x2020050
_0x2020052:
	RJMP _0x2020056
_0x202004F:
_0x2020058:
	LDI  R18,LOW(48)
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	CALL __GETW1PF
	STD  Y+8,R30
	STD  Y+8+1,R31
	LDD  R30,Y+6
	LDD  R31,Y+6+1
	ADIW R30,2
	STD  Y+6,R30
	STD  Y+6+1,R31
_0x202005A:
	LDD  R30,Y+8
	LDD  R31,Y+8+1
	LDD  R26,Y+10
	LDD  R27,Y+10+1
	CP   R26,R30
	CPC  R27,R31
	BRLO _0x202005C
	SUBI R18,-LOW(1)
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	LDD  R30,Y+10
	LDD  R31,Y+10+1
	SUB  R30,R26
	SBC  R31,R27
	STD  Y+10,R30
	STD  Y+10+1,R31
	RJMP _0x202005A
_0x202005C:
	CPI  R18,58
	BRLO _0x202005D
	SBRS R16,3
	RJMP _0x202005E
	SUBI R18,-LOW(7)
	RJMP _0x202005F
_0x202005E:
	SUBI R18,-LOW(39)
_0x202005F:
_0x202005D:
	SBRC R16,4
	RJMP _0x2020061
	CPI  R18,49
	BRSH _0x2020063
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,1
	BRNE _0x2020062
_0x2020063:
	RJMP _0x20200CA
_0x2020062:
	CP   R21,R19
	BRLO _0x2020067
	SBRS R16,0
	RJMP _0x2020068
_0x2020067:
	RJMP _0x2020066
_0x2020068:
	LDI  R18,LOW(32)
	SBRS R16,7
	RJMP _0x2020069
	LDI  R18,LOW(48)
_0x20200CA:
	ORI  R16,LOW(16)
	SBRS R16,2
	RJMP _0x202006A
	ANDI R16,LOW(251)
	ST   -Y,R20
	CALL SUBOPT_0x52
	CPI  R21,0
	BREQ _0x202006B
	SUBI R21,LOW(1)
_0x202006B:
_0x202006A:
_0x2020069:
_0x2020061:
	CALL SUBOPT_0x50
	CPI  R21,0
	BREQ _0x202006C
	SUBI R21,LOW(1)
_0x202006C:
_0x2020066:
	SUBI R19,LOW(1)
	LDD  R26,Y+8
	LDD  R27,Y+8+1
	SBIW R26,2
	BRLO _0x2020059
	RJMP _0x2020058
_0x2020059:
_0x2020056:
	SBRS R16,0
	RJMP _0x202006D
_0x202006E:
	CPI  R21,0
	BREQ _0x2020070
	SUBI R21,LOW(1)
	LDI  R30,LOW(32)
	ST   -Y,R30
	CALL SUBOPT_0x52
	RJMP _0x202006E
_0x2020070:
_0x202006D:
_0x2020071:
_0x2020030:
_0x20200C9:
	LDI  R17,LOW(0)
_0x202001B:
	RJMP _0x2020016
_0x2020018:
	LDD  R26,Y+12
	LDD  R27,Y+12+1
	CALL __GETW1P
	CALL __LOADLOCR6
	ADIW R28,20
	RET
_sprintf:
	PUSH R15
	MOV  R15,R24
	SBIW R28,6
	CALL __SAVELOCR4
	CALL SUBOPT_0x55
	SBIW R30,0
	BRNE _0x2020072
	LDI  R30,LOW(65535)
	LDI  R31,HIGH(65535)
	RJMP _0x20C0001
_0x2020072:
	MOVW R26,R28
	ADIW R26,6
	CALL __ADDW2R15
	MOVW R16,R26
	CALL SUBOPT_0x55
	STD  Y+6,R30
	STD  Y+6+1,R31
	LDI  R30,LOW(0)
	STD  Y+8,R30
	STD  Y+8+1,R30
	MOVW R26,R28
	ADIW R26,10
	CALL __ADDW2R15
	CALL __GETW1P
	ST   -Y,R31
	ST   -Y,R30
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(_put_buff_G101)
	LDI  R31,HIGH(_put_buff_G101)
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,10
	ST   -Y,R31
	ST   -Y,R30
	RCALL __print_G101
	MOVW R18,R30
	LDD  R26,Y+6
	LDD  R27,Y+6+1
	LDI  R30,LOW(0)
	ST   X,R30
	MOVW R30,R18
_0x20C0001:
	CALL __LOADLOCR4
	ADIW R28,10
	POP  R15
	RET

	.CSEG
_strlen:
    ld   r26,y+
    ld   r27,y+
    clr  r30
    clr  r31
strlen0:
    ld   r22,x+
    tst  r22
    breq strlen1
    adiw r30,1
    rjmp strlen0
strlen1:
    ret
_strlenf:
    clr  r26
    clr  r27
    ld   r30,y+
    ld   r31,y+
strlenf0:
	lpm  r0,z+
    tst  r0
    breq strlenf1
    adiw r26,1
    rjmp strlenf0
strlenf1:
    movw r30,r26
    ret
_strncpy:
    ld   r23,y+
    ld   r30,y+
    ld   r31,y+
    ld   r26,y+
    ld   r27,y+
    movw r24,r26
strncpy0:
    tst  r23
    breq strncpy1
    dec  r23
    ld   r22,z+
    st   x+,r22
    tst  r22
    brne strncpy0
strncpy2:
    tst  r23
    breq strncpy1
    dec  r23
    st   x+,r22
    rjmp strncpy2
strncpy1:
    movw r30,r24
    ret

	.CSEG
_itoa:
    ld   r26,y+
    ld   r27,y+
    ld   r30,y+
    ld   r31,y+
    adiw r30,0
    brpl __itoa0
    com  r30
    com  r31
    adiw r30,1
    ldi  r22,'-'
    st   x+,r22
__itoa0:
    clt
    ldi  r24,low(10000)
    ldi  r25,high(10000)
    rcall __itoa1
    ldi  r24,low(1000)
    ldi  r25,high(1000)
    rcall __itoa1
    ldi  r24,100
    clr  r25
    rcall __itoa1
    ldi  r24,10
    rcall __itoa1
    mov  r22,r30
    rcall __itoa5
    clr  r22
    st   x,r22
    ret

__itoa1:
    clr	 r22
__itoa2:
    cp   r30,r24
    cpc  r31,r25
    brlo __itoa3
    inc  r22
    sub  r30,r24
    sbc  r31,r25
    brne __itoa2
__itoa3:
    tst  r22
    brne __itoa4
    brts __itoa5
    ret
__itoa4:
    set
__itoa5:
    subi r22,-0x30
    st   x+,r22
    ret

	.DSEG

	.CSEG

	.CSEG

	.CSEG

	.DSEG
___ds1820_scratch_pad:
	.BYTE 0x9
_saved_state_G000:
	.BYTE 0x1
_g_tcf:
	.BYTE 0x2
_U1_in_buf_flag:
	.BYTE 0x1
_symbol:
	.BYTE 0x1
_v_u32_SYS_TICK:
	.BYTE 0x4
_v_u8_SYS_TICK_TMP1:
	.BYTE 0x1
_v_u32_TX_CNT:
	.BYTE 0x4
_v_u32_RX_CNT:
	.BYTE 0x4
_v_u16_TIM_1_OVR_FLAG:
	.BYTE 0x2

	.ESEG
_null_ee:
	.BYTE 0x1
_EE_settings:
	.BYTE 0xC

	.DSEG
_RAM_settings:
	.BYTE 0xC
_timers_cnt_tail:
	.BYTE 0x1
_WorkLog_G000:
	.BYTE 0x200
_LogIndex_G000:
	.BYTE 0x2
_lcd_buf:
	.BYTE 0xF
_temp_control:
	.BYTE 0x1
_bias:
	.BYTE 0x1
_Vop:
	.BYTE 0x1
_disp_config:
	.BYTE 0x1
_LcdCache:
	.BYTE 0x1F8
_LcdCacheIdx:
	.BYTE 0x2
_Usart0_TX_buf_G000:
	.BYTE 0x100
_Usart0_txBufTail_G000:
	.BYTE 0x2
_Usart0_txBufHead_G000:
	.BYTE 0x2
_Usart1_TX_buf_G000:
	.BYTE 0x100
_Usart1_txBufTail_G000:
	.BYTE 0x2
_Usart1_txBufHead_G000:
	.BYTE 0x2
_Usart0_RX_buf_G000:
	.BYTE 0x100
_Usart0_rxBufTail_G000:
	.BYTE 0x2
_Usart0_rxBufHead_G000:
	.BYTE 0x2
_Usart0_rxCount_G000:
	.BYTE 0x2
_Usart1_RX_buf_G000:
	.BYTE 0x100
_Usart1_rxBufTail_G000:
	.BYTE 0x2
_Usart1_rxBufHead_G000:
	.BYTE 0x2
_Usart1_rxCount_G000:
	.BYTE 0x2
_buf:
	.BYTE 0x80
_argv:
	.BYTE 0x14
_argc:
	.BYTE 0x1
_i:
	.BYTE 0x1
_devider_f:
	.BYTE 0x1
_Spi0_TX_buf_G000:
	.BYTE 0x40
_Spi0_txBufTail_G000:
	.BYTE 0x2
_Spi0_txBufHead_G000:
	.BYTE 0x2
_Spi0_RX_buf_G000:
	.BYTE 0x40
_adc_result:
	.BYTE 0x2
_vref:
	.BYTE 0x2
_volt:
	.BYTE 0x2
_delta:
	.BYTE 0x2
_adc_tmp:
	.BYTE 0x2
_d:
	.BYTE 0x2
_avcc:
	.BYTE 0x2
_adc_calib_cnt:
	.BYTE 0x2
_rtc:
	.BYTE 0x4
_MasterOutFunc:
	.BYTE 0x2
_SlaveOutFunc:
	.BYTE 0x2
_ErrorOutFunc:
	.BYTE 0x2
_i2c_Do:
	.BYTE 0x1
_i2c_InBuff:
	.BYTE 0x1
_i2c_OutBuff:
	.BYTE 0x1
_i2c_SlaveIndex:
	.BYTE 0x1
_i2c_Buffer:
	.BYTE 0x3
_i2c_index:
	.BYTE 0x1
_i2c_ByteCount:
	.BYTE 0x1
_i2c_SlaveAddress:
	.BYTE 0x1
_i2c_PageAddress:
	.BYTE 0x2
_i2c_PageAddrIndex:
	.BYTE 0x1
_i2c_PageAddrCount:
	.BYTE 0x1
_TTask_G001:
	.BYTE 0x111
_coins_S0010008000:
	.BYTE 0x1
_DeadTask_prev_S0010008000:
	.BYTE 0x2
_DeadTask_curr_S0010008000:
	.BYTE 0x2
_Timeout_delay_S0010008000:
	.BYTE 0x2
__seed_G103:
	.BYTE 0x4

	.CSEG
;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x0:
	LDS  R26,_LogIndex_G000
	LDS  R27,_LogIndex_G000+1
	CPI  R26,LOW(0x200)
	LDI  R30,HIGH(0x200)
	CPC  R27,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x1:
	LDS  R30,_LogIndex_G000
	LDS  R31,_LogIndex_G000+1
	SUBI R30,LOW(-_WorkLog_G000)
	SBCI R31,HIGH(-_WorkLog_G000)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x2:
	STD  Z+0,R26
	LDI  R26,LOW(_LogIndex_G000)
	LDI  R27,HIGH(_LogIndex_G000)
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x3:
	IN   R30,0x3F
	LDS  R26,_saved_state_G000
	OR   R30,R26
	OUT  0x3F,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x4:
	LDS  R30,_g_tcf
	LDS  R31,_g_tcf+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x5:
	STS  _g_tcf,R30
	STS  _g_tcf+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x6:
	ST   -Y,R17
	ST   -Y,R16
	LDI  R30,LOW(128)
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _LcdSend
	LDI  R30,LOW(64)
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	CALL _LcdSend
	__GETWRN 16,17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x7:
	ST   -Y,R17
	ST   -Y,R16
	__GETWRN 16,17,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x8:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _delay_ms

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:12 WORDS
SUBOPT_0x9:
	ST   -Y,R30
	LDI  R30,LOW(0)
	ST   -Y,R30
	JMP  _LcdSend

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0xA:
	MOV  R30,R17
	LDI  R31,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xB:
	LDI  R26,LOW(_LcdCacheIdx)
	LDI  R27,HIGH(_LcdCacheIdx)
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	SBIW R30,1
	SUBI R30,LOW(-_LcdCache)
	SBCI R31,HIGH(-_LcdCache)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0xC:
	LD   R30,Z
	LDI  R31,0
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xD:
	LDD  R30,Y+2
	LDD  R31,Y+2+1
	CLR  R22
	CLR  R23
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xE:
	__GETD2N 0x8
	CALL __MULD12U
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0xF:
	LDI  R30,LOW(0)
	STS  _Usart0_txBufHead_G000,R30
	STS  _Usart0_txBufHead_G000+1,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x10:
	LDI  R30,LOW(0)
	STS  _Usart1_txBufHead_G000,R30
	STS  _Usart1_txBufHead_G000+1,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x11:
	SUB  R30,R26
	SBC  R31,R27
	CPI  R30,LOW(0x101)
	LDI  R26,HIGH(0x101)
	CPC  R31,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:4 WORDS
SUBOPT_0x12:
	ST   -Y,R22
	ST   -Y,R23
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
	ST   -Y,R17
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x13:
	CALL __GETD1P_INC
	__SUBD1N -1
	CALL __PUTDP1_DEC
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x14:
	LDS  R30,_Usart1_txBufHead_G000
	LDS  R31,_Usart1_txBufHead_G000+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:24 WORDS
SUBOPT_0x15:
	LD   R30,X+
	LD   R31,X+
	ADIW R30,1
	ST   -X,R31
	ST   -X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x16:
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x17:
	LD   R30,Y+
	OUT  SREG,R30
	LD   R31,Y+
	LD   R30,Y+
	LD   R27,Y+
	LD   R26,Y+
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x18:
	LDI  R30,LOW(0)
	STS  98,R30
	STS  97,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x19:
	LDS  R26,_volt
	LDS  R27,_volt+1
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1A:
	ADD  R30,R26
	ADC  R31,R27
	STS  _volt,R30
	STS  _volt+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:19 WORDS
SUBOPT_0x1B:
	ST   -Y,R0
	ST   -Y,R1
	ST   -Y,R15
	ST   -Y,R22
	ST   -Y,R23
	ST   -Y,R24
	ST   -Y,R25
	ST   -Y,R26
	ST   -Y,R27
	ST   -Y,R30
	ST   -Y,R31
	IN   R30,SREG
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:8 WORDS
SUBOPT_0x1C:
	__GETD1N 0x3F
	CALL __PREINC_BITFD
	__CPD1N 0x3C
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x1D:
	__GETD1N 0x1F
	CALL __PREINC_BITFD
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x1E:
	LDS  R30,_rtc+2
	LDS  R31,_rtc+3
	LSR  R31
	ROR  R30
	ANDI R30,LOW(0x1F)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:33 WORDS
SUBOPT_0x1F:
	LDS  R26,_rtc+2
	LDS  R27,_rtc+3
	LDI  R30,LOW(6)
	CALL __LSRW12
	ANDI R30,LOW(0xF)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
SUBOPT_0x20:
	LDI  R26,LOW(_rtc)
	LDI  R27,HIGH(_rtc)
	LDI  R24,22
	__GETD1N 0xF
	CALL __POSTINC_BITFD
	__GETB1MN _rtc,2
	ANDI R30,LOW(0xC1)
	ORI  R30,2
	__PUTB1MN _rtc,2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x21:
	LDS  R30,_rtc+3
	LSR  R30
	LSR  R30
	__ANDD1N 0x3F
	MOVW R26,R30
	MOVW R24,R22
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x22:
	__GETD1N 0x64
	CALL __MODD21U
	CALL __CPD10
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x23:
	STS  _i2c_Do,R30
	LDI  R30,LOW(213)
	STS  116,R30
	__CALL1MN _ErrorOutFunc,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x24:
	LDS  R30,_i2c_SlaveAddress
	STS  115,R30
	LDI  R30,LOW(197)
	STS  116,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x25:
	LDS  R30,_i2c_Do
	ANDI R30,LOW(0xC)
	CPI  R30,LOW(0x8)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:13 WORDS
SUBOPT_0x26:
	LDS  R30,_i2c_index
	LDI  R31,0
	SUBI R30,LOW(-_i2c_Buffer)
	SBCI R31,HIGH(-_i2c_Buffer)
	LD   R30,Z
	STS  115,R30
	LDS  R30,_i2c_index
	SUBI R30,-LOW(1)
	STS  _i2c_index,R30
	LDI  R30,LOW(197)
	STS  116,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x27:
	LDS  R30,_i2c_PageAddrIndex
	LDI  R31,0
	SUBI R30,LOW(-_i2c_PageAddress)
	SBCI R31,HIGH(-_i2c_PageAddress)
	LD   R30,Z
	STS  115,R30
	LDS  R30,_i2c_PageAddrIndex
	SUBI R30,-LOW(1)
	STS  _i2c_PageAddrIndex,R30
	LDI  R30,LOW(197)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x28:
	LDI  R30,LOW(213)
	STS  116,R30
	__CALL1MN _MasterOutFunc,0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x29:
	STS  _i2c_Do,R30
	LDI  R30,LOW(0)
	STS  _i2c_index,R30
	STS  _i2c_PageAddrIndex,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x2A:
	LDS  R26,_i2c_index
	SUBI R26,-LOW(1)
	LDS  R30,_i2c_ByteCount
	CP   R30,R26
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x2B:
	LDS  R26,_i2c_index
	LDI  R27,0
	SUBI R26,LOW(-_i2c_Buffer)
	SBCI R27,HIGH(-_i2c_Buffer)
	LDS  R30,115
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x2C:
	LDS  R26,_i2c_SlaveIndex
	LDI  R27,0
	SUBI R26,LOW(-_i2c_InBuff)
	SBCI R27,HIGH(-_i2c_InBuff)
	LDS  R30,115
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x2D:
	LDS  R30,_i2c_SlaveIndex
	SUBI R30,-LOW(1)
	STS  _i2c_SlaveIndex,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x2E:
	LDI  R31,0
	SUBI R30,LOW(-_i2c_OutBuff)
	SBCI R31,HIGH(-_i2c_OutBuff)
	LD   R30,Z
	STS  115,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x2F:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(10)
	LDI  R31,HIGH(10)
	ST   -Y,R31
	ST   -Y,R30
	JMP  _SetTimerTask

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x30:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _SetTimerTask

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x31:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _SetTask

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x32:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(1000)
	LDI  R31,HIGH(1000)
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x33:
	ST   -Y,R31
	ST   -Y,R30
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x34:
	ST   -Y,R31
	ST   -Y,R30
	CALL _Put_In_Log
	RJMP SUBOPT_0x4

;OPTIMIZER ADDED SUBROUTINE, CALLED 8 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x35:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _itoa

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x36:
	MOV  R26,R17
	LDI  R27,0
	SUBI R26,LOW(-_EE_settings)
	SBCI R27,HIGH(-_EE_settings)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x37:
	CALL __EEPROMRDB
	MOVW R26,R0
	ST   X,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x38:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _USART_Init

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x39:
	ST   -Y,R30
	LDI  R30,LOW(_start*2)
	LDI  R31,HIGH(_start*2)
	ST   -Y,R31
	ST   -Y,R30
	JMP  _USART_Send_StrFl

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x3A:
	LDS  R26,_v_u32_SYS_TICK
	LDS  R27,_v_u32_SYS_TICK+1
	LDS  R24,_v_u32_SYS_TICK+2
	LDS  R25,_v_u32_SYS_TICK+3
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 11 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0x3B:
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	SUBI R30,LOW(-_TTask_G001)
	SBCI R31,HIGH(-_TTask_G001)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x3C:
	MOVW R26,R30
	LDI  R30,LOW(_Idle)
	LDI  R31,HIGH(_Idle)
	ST   X+,R30
	ST   X,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 7 TIMES, CODE SIZE REDUCTION:15 WORDS
SUBOPT_0x3D:
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,2
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x3E:
	LDI  R26,LOW(0)
	LDI  R27,HIGH(0)
	STD  Z+0,R26
	STD  Z+1,R27
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 10 TIMES, CODE SIZE REDUCTION:24 WORDS
SUBOPT_0x3F:
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,6
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:10 WORDS
SUBOPT_0x40:
	LDD  R26,Y+4
	LDD  R27,Y+4+1
	STD  Z+0,R26
	STD  Z+1,R27
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,4
	LDD  R26,Y+2
	LDD  R27,Y+2+1
	STD  Z+0,R26
	STD  Z+1,R27
	RJMP SUBOPT_0x3F

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x41:
	LDI  R26,LOW(13)
	MUL  R17,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,4
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 16 TIMES, CODE SIZE REDUCTION:27 WORDS
SUBOPT_0x42:
	ST   -Y,R31
	ST   -Y,R30
	JMP  _Put_In_Log

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:3 WORDS
SUBOPT_0x43:
	LDS  R30,_timers_cnt_tail
	SUBI R30,LOW(1)
	LDI  R26,LOW(13)
	MUL  R30,R26
	MOVW R30,R0
	SUBI R30,LOW(-_TTask_G001)
	SBCI R31,HIGH(-_TTask_G001)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x44:
	MOVW R26,R22
	LDI  R24,13
	CALL __COPYMML
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x45:
	LDS  R30,_timers_cnt_tail
	SUBI R30,LOW(1)
	LDI  R26,LOW(13)
	MUL  R30,R26
	MOVW R30,R0
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:14 WORDS
SUBOPT_0x46:
	LDI  R26,LOW(13)
	MUL  R18,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,4
	LD   R22,Z
	LDD  R23,Z+1
	MOV  R30,R18
	SUBI R30,-LOW(1)
	MUL  R30,R26
	MOVW R30,R0
	__ADDW1MN _TTask_G001,4
	MOVW R26,R30
	CALL __GETW1P
	CP   R30,R22
	CPC  R31,R23
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x47:
	LDI  R26,LOW(13)
	MUL  R18,R26
	MOVW R30,R0
	SUBI R30,LOW(-_TTask_G001)
	SBCI R31,HIGH(-_TTask_G001)
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x48:
	MOVW R26,R28
	ADIW R26,4
	LDI  R24,13
	CALL __COPYMML
	RJMP SUBOPT_0x47

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:5 WORDS
SUBOPT_0x49:
	MOVW R22,R30
	MOV  R30,R18
	SUBI R30,-LOW(1)
	LDI  R26,LOW(13)
	MUL  R30,R26
	MOVW R30,R0
	SUBI R30,LOW(-_TTask_G001)
	SBCI R31,HIGH(-_TTask_G001)
	RJMP SUBOPT_0x44

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x4A:
	MOV  R30,R18
	SUBI R30,-LOW(1)
	LDI  R26,LOW(13)
	MUL  R30,R26
	MOVW R30,R0
	SUBI R30,LOW(-_TTask_G001)
	SBCI R31,HIGH(-_TTask_G001)
	MOVW R26,R30
	MOVW R30,R28
	ADIW R30,4
	LDI  R24,13
	CALL __COPYMML
	MOV  R19,R18
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x4B:
	STS  _DeadTask_prev_S0010008000,R30
	STS  _DeadTask_prev_S0010008000+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x4C:
	STS  _DeadTask_curr_S0010008000,R30
	STS  _DeadTask_curr_S0010008000+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:11 WORDS
SUBOPT_0x4D:
	CLT
	BLD  R2,3
	LDI  R30,LOW(0)
	STS  _Timeout_delay_S0010008000,R30
	STS  _Timeout_delay_S0010008000+1,R30
	LDI  R30,LOW(0)
	LDI  R31,HIGH(0)
	RCALL SUBOPT_0x4B
	RCALL SUBOPT_0x4C
	LDI  R30,LOW(0)
	STS  _coins_S0010008000,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 4 TIMES, CODE SIZE REDUCTION:18 WORDS
SUBOPT_0x4E:
	MOVW R26,R30
	CALL __GETW1P
	ST   -Y,R31
	ST   -Y,R30
	MOVW R30,R28
	ADIW R30,3
	RJMP SUBOPT_0x35

;OPTIMIZER ADDED SUBROUTINE, CALLED 6 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x4F:
	MOVW R30,R28
	ADIW R30,1
	RJMP SUBOPT_0x42

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:21 WORDS
SUBOPT_0x50:
	ST   -Y,R18
	LDD  R30,Y+13
	LDD  R31,Y+13+1
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+17
	LDD  R31,Y+17+1
	ICALL
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 5 TIMES, CODE SIZE REDUCTION:9 WORDS
SUBOPT_0x51:
	LDD  R30,Y+16
	LDD  R31,Y+16+1
	SBIW R30,4
	STD  Y+16,R30
	STD  Y+16+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 3 TIMES, CODE SIZE REDUCTION:7 WORDS
SUBOPT_0x52:
	LDD  R30,Y+13
	LDD  R31,Y+13+1
	ST   -Y,R31
	ST   -Y,R30
	LDD  R30,Y+17
	LDD  R31,Y+17+1
	ICALL
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:6 WORDS
SUBOPT_0x53:
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,4
	CALL __GETW1P
	STD  Y+6,R30
	STD  Y+6+1,R31
	ST   -Y,R31
	ST   -Y,R30
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:2 WORDS
SUBOPT_0x54:
	LDD  R26,Y+16
	LDD  R27,Y+16+1
	ADIW R26,4
	CALL __GETW1P
	STD  Y+10,R30
	STD  Y+10+1,R31
	RET

;OPTIMIZER ADDED SUBROUTINE, CALLED 2 TIMES, CODE SIZE REDUCTION:1 WORDS
SUBOPT_0x55:
	MOVW R26,R28
	ADIW R26,12
	CALL __ADDW2R15
	CALL __GETW1P
	RET


	.CSEG
_delay_ms:
	ld   r30,y+
	ld   r31,y+
	adiw r30,0
	breq __delay_ms1
__delay_ms0:
	__DELAY_USW 0xFA0
	wdr
	sbiw r30,1
	brne __delay_ms0
__delay_ms1:
	ret

	.equ __w1_port=0x1B
	.equ __w1_bit=0x02

__ADDW2R15:
	CLR  R0
	ADD  R26,R15
	ADC  R27,R0
	RET

__SUBD21:
	SUB  R26,R30
	SBC  R27,R31
	SBC  R24,R22
	SBC  R25,R23
	RET

__ANEGW1:
	NEG  R31
	NEG  R30
	SBCI R31,0
	RET

__LSRW12:
	TST  R30
	MOV  R0,R30
	MOVW R30,R26
	BREQ __LSRW12R
__LSRW12L:
	LSR  R31
	ROR  R30
	DEC  R0
	BRNE __LSRW12L
__LSRW12R:
	RET

__LSRW2:
	LSR  R31
	ROR  R30
	LSR  R31
	ROR  R30
	RET

__LSLD1:
	LSL  R30
	ROL  R31
	ROL  R22
	ROL  R23
	RET

__CWD1:
	MOV  R22,R31
	ADD  R22,R22
	SBC  R22,R22
	MOV  R23,R22
	RET

__MULW12U:
	MUL  R31,R26
	MOV  R31,R0
	MUL  R30,R27
	ADD  R31,R0
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	RET

__MULD12U:
	MUL  R23,R26
	MOV  R23,R0
	MUL  R22,R27
	ADD  R23,R0
	MUL  R31,R24
	ADD  R23,R0
	MUL  R30,R25
	ADD  R23,R0
	MUL  R22,R26
	MOV  R22,R0
	ADD  R23,R1
	MUL  R31,R27
	ADD  R22,R0
	ADC  R23,R1
	MUL  R30,R24
	ADD  R22,R0
	ADC  R23,R1
	CLR  R24
	MUL  R31,R26
	MOV  R31,R0
	ADD  R22,R1
	ADC  R23,R24
	MUL  R30,R27
	ADD  R31,R0
	ADC  R22,R1
	ADC  R23,R24
	MUL  R30,R26
	MOV  R30,R0
	ADD  R31,R1
	ADC  R22,R24
	ADC  R23,R24
	RET

__MULB1W2U:
	MOV  R22,R30
	MUL  R22,R26
	MOVW R30,R0
	MUL  R22,R27
	ADD  R31,R0
	RET

__MULW12:
	RCALL __CHKSIGNW
	RCALL __MULW12U
	BRTC __MULW121
	RCALL __ANEGW1
__MULW121:
	RET

__DIVW21U:
	CLR  R0
	CLR  R1
	LDI  R25,16
__DIVW21U1:
	LSL  R26
	ROL  R27
	ROL  R0
	ROL  R1
	SUB  R0,R30
	SBC  R1,R31
	BRCC __DIVW21U2
	ADD  R0,R30
	ADC  R1,R31
	RJMP __DIVW21U3
__DIVW21U2:
	SBR  R26,1
__DIVW21U3:
	DEC  R25
	BRNE __DIVW21U1
	MOVW R30,R26
	MOVW R26,R0
	RET

__DIVD21U:
	PUSH R19
	PUSH R20
	PUSH R21
	CLR  R0
	CLR  R1
	CLR  R20
	CLR  R21
	LDI  R19,32
__DIVD21U1:
	LSL  R26
	ROL  R27
	ROL  R24
	ROL  R25
	ROL  R0
	ROL  R1
	ROL  R20
	ROL  R21
	SUB  R0,R30
	SBC  R1,R31
	SBC  R20,R22
	SBC  R21,R23
	BRCC __DIVD21U2
	ADD  R0,R30
	ADC  R1,R31
	ADC  R20,R22
	ADC  R21,R23
	RJMP __DIVD21U3
__DIVD21U2:
	SBR  R26,1
__DIVD21U3:
	DEC  R19
	BRNE __DIVD21U1
	MOVW R30,R26
	MOVW R22,R24
	MOVW R26,R0
	MOVW R24,R20
	POP  R21
	POP  R20
	POP  R19
	RET

__MODD21U:
	RCALL __DIVD21U
	MOVW R30,R26
	MOVW R22,R24
	RET

__CHKSIGNW:
	CLT
	SBRS R31,7
	RJMP __CHKSW1
	RCALL __ANEGW1
	SET
__CHKSW1:
	SBRS R27,7
	RJMP __CHKSW2
	COM  R26
	COM  R27
	ADIW R26,1
	BLD  R0,0
	INC  R0
	BST  R0,0
__CHKSW2:
	RET

__GETW1P:
	LD   R30,X+
	LD   R31,X
	SBIW R26,1
	RET

__GETD1P_INC:
	LD   R30,X+
	LD   R31,X+
	LD   R22,X+
	LD   R23,X+
	RET

__PUTDP1_DEC:
	ST   -X,R23
	ST   -X,R22
	ST   -X,R31
	ST   -X,R30
	RET

__GETW1PF:
	LPM  R0,Z+
	LPM  R31,Z
	MOV  R30,R0
	RET

__PUTDZ20:
	ST   Z,R26
	STD  Z+1,R27
	STD  Z+2,R24
	STD  Z+3,R25
	RET

__PUTPARD1:
	ST   -Y,R23
	ST   -Y,R22
	ST   -Y,R31
	ST   -Y,R30
	RET

__GET_BITFD:
	MOV  R0,R24
	MOVW R16,R30
	MOVW R18,R22
	LD   R30,X+
	LD   R31,X+
	LD   R22,X+
	LD   R23,X
	MOV  R1,R0
	TST  R1
	BREQ __GET_BITFD1
__GET_BITFD0:
	LSR  R23
	ROR  R22
	ROR  R31
	ROR  R30
	DEC  R1
	BRNE __GET_BITFD0
__GET_BITFD1:
	AND  R30,R16
	AND  R31,R17
	AND  R22,R18
	AND  R23,R19
	RET

__PUT_BITFD:
	AND  R30,R16
	AND  R31,R17
	AND  R22,R18
	AND  R23,R19
	MOVW R20,R30
	MOVW R24,R22
	TST  R0
	BREQ __PUT_BITFD1
__PUT_BITFD0:
	LSL  R16
	ROL  R17
	ROL  R18
	ROL  R19
	LSL  R20
	ROL  R21
	ROL  R24
	ROL  R25
	DEC  R0
	BRNE __PUT_BITFD0
__PUT_BITFD1:
	COM  R16
	COM  R17
	COM  R18
	COM  R19
	LD   R1,X
	LD   R0,-X
	AND  R0,R18
	AND  R1,R19
	LD   R19,-X
	LD   R18,-X
	AND  R18,R16
	AND  R19,R17
	OR   R18,R20
	OR   R19,R21
	OR   R0,R24
	OR   R1,R25
	ST   X+,R18
	ST   X+,R19
	ST   X+,R0
	ST   X,R1
	RET

__PREINC_BITFD:
	PUSH R16
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	PUSH R21
	RCALL __GET_BITFD
	ADIW R30,1
	ADC  R22,R1
	ADC  R23,R1
	RCALL __PUT_BITFD
	POP  R21
	POP  R20
	POP  R19
	POP  R18
	POP  R17
	POP  R16
	RET

__POSTINC_BITFD:
	PUSH R16
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	PUSH R21
	RCALL __GET_BITFD
	PUSH R30
	PUSH R31
	PUSH R22
	PUSH R23
	ADIW R30,1
	ADC  R22,R1
	ADC  R23,R1
	RCALL __PUT_BITFD
	POP  R23
	POP  R22
	POP  R31
	POP  R30
	POP  R21
	POP  R20
	POP  R19
	POP  R18
	POP  R17
	POP  R16
	RET

__EEPROMRDW:
	ADIW R26,1
	RCALL __EEPROMRDB
	MOV  R31,R30
	SBIW R26,1

__EEPROMRDB:
	SBIC EECR,EEWE
	RJMP __EEPROMRDB
	PUSH R31
	IN   R31,SREG
	CLI
	OUT  EEARL,R26
	OUT  EEARH,R27
	SBI  EECR,EERE
	IN   R30,EEDR
	OUT  SREG,R31
	POP  R31
	RET

__EEPROMWRW:
	RCALL __EEPROMWRB
	ADIW R26,1
	PUSH R30
	MOV  R30,R31
	RCALL __EEPROMWRB
	POP  R30
	SBIW R26,1
	RET

__EEPROMWRB:
	SBIS EECR,EEWE
	RJMP __EEPROMWRB1
	WDR
	RJMP __EEPROMWRB
__EEPROMWRB1:
	IN   R25,SREG
	CLI
	OUT  EEARL,R26
	OUT  EEARH,R27
	SBI  EECR,EERE
	IN   R24,EEDR
	CP   R30,R24
	BREQ __EEPROMWRB0
	OUT  EEDR,R30
	SBI  EECR,EEMWE
	SBI  EECR,EEWE
__EEPROMWRB0:
	OUT  SREG,R25
	RET

__COPYMML:
	CLR  R25
__COPYMM:
	PUSH R30
	PUSH R31
__COPYMM0:
	LD   R22,Z+
	ST   X+,R22
	SBIW R24,1
	BRNE __COPYMM0
	POP  R31
	POP  R30
	RET

__CPD10:
	SBIW R30,0
	SBCI R22,0
	SBCI R23,0
	RET

__CPW02:
	CLR  R0
	CP   R0,R26
	CPC  R0,R27
	RET

__SAVELOCR6:
	ST   -Y,R21
__SAVELOCR5:
	ST   -Y,R20
__SAVELOCR4:
	ST   -Y,R19
__SAVELOCR3:
	ST   -Y,R18
__SAVELOCR2:
	ST   -Y,R17
	ST   -Y,R16
	RET

__LOADLOCR6:
	LDD  R21,Y+5
__LOADLOCR5:
	LDD  R20,Y+4
__LOADLOCR4:
	LDD  R19,Y+3
__LOADLOCR3:
	LDD  R18,Y+2
__LOADLOCR2:
	LDD  R17,Y+1
	LD   R16,Y
	RET

;END OF CODE MARKER
__END_OF_CODE:
